<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Qiracle&#39;s Blog</title>
  <subtitle>no pains,no gains</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qiracle.github.io/"/>
  <updated>2020-10-03T04:11:37.312Z</updated>
  <id>http://qiracle.github.io/</id>
  
  <author>
    <name>qiracle</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>西藏游记</title>
    <link href="http://qiracle.github.io/2020/10/02/20201002/"/>
    <id>http://qiracle.github.io/2020/10/02/20201002/</id>
    <published>2020-10-01T16:00:00.000Z</published>
    <updated>2020-10-03T04:11:37.312Z</updated>
    
    <content type="html"><![CDATA[<p>西藏，新疆，内蒙是国内我最想去的三个地方，它们分别对应着雪山，沙漠和草原，这次凑了7天假，连着两个周末，总共十一天，和朋友一起去西藏逛了一圈。</p>
<p>由于只有十一天的时间，不算长，所以没有选择坐火车进藏，而是先从南京飞到重庆，再到重庆转机，飞到拉萨，目前国内能直飞拉萨的好像只有成都，重庆，西宁，西安了。进拉萨的机票不算贵，南京到重庆300多，重庆到拉萨600多，总共才1000多一点。但是有个很坑的地方是飞出拉萨的机票特别贵，回去时买的拉萨飞西安的就差不多1700。所以如果有时间的话，最好还是飞机进藏，火车出藏，这样既能欣赏到火车穿出青藏高原的沿路美景，还比较省钱。<a id="more"></a></p>
<h3 id="Day1-–-重庆"><a href="#Day1-–-重庆" class="headerlink" title="Day1 – 重庆"></a>Day1 – 重庆</h3><p>南京飞到重庆，早上差点没赶上飞机，幸好滴滴师傅给力，上了高速全程120km/h往机场赶，到了机场安检的时候已经有广播在喊我们的名字了，有惊无险。到了重庆，打车去市区的路上，一直跟司机师傅交流，问他哪好吃好玩的，中午就吃了他推荐的一家叫周师兄的火锅，他推荐的还有来凤鱼，璧山兔，不过已经没有胃口吃了。下午逛了李子坝，皇冠梯，凯旋梯，长江索道，晚上逛了洪崖洞，吃了串串，就不重点介绍这些了，因为此行的目的是西藏。</p>
<p><img src="http://qiracle.cn/img/west/01.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/02.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/03.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/04.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/05.jpg" alt=""></p>
<h3 id="Day2-–拉萨"><a href="#Day2-–拉萨" class="headerlink" title="Day2 –拉萨"></a>Day2 –拉萨</h3><p>早上尝了碗重庆小面，就出发去重庆机场，飞往拉萨的贡嘎机场，值得一提的是，飞机上一定要选个靠窗的座位，因为从飞机上俯瞰青藏高原的景色是在太壮观了。</p>
<p>到了贡嘎机场，这里海拔3600，一下飞机我身体上并没啥高原反应，朋友除了太阳穴有点疼，其他都还好。然后我们坐机场大巴到拉萨市中心，大约70分钟，车票30元。一下大巴，侧面就看到了布达拉宫，有点激动，拎着箱子跑一圈想到正面看看布达拉宫，没跑几步，就明显感到吃力，喘不过气，这大概就是高原反应吧。然后就放弃了，想着明天可以过来好好看看，不急这么一会。便打了车，去了之前定好的客栈，客栈环境还挺不错，200左右一晚，老板，老板娘人都很好，后面的西藏环行也是包他的车去的。在客栈跟老板娘聊天聊了很长时间，了解了当地的一些情况。</p>
<p>晚上去老板娘推荐的一家藏餐厅，吃了藏面，藏鸡蛋，牛肉饼，甜茶。晚上去看了当地的一个著名的演出：文成公主实景剧场。当时买的票价260，坐在不同区域价格是不一样的，有比这更贵的，也有更便宜的。个人感觉演出还不错的，主要介绍的是松赞干布迎娶文成公主，从这里以及之后游览的布达拉宫和大昭寺可以看出藏王松赞干布在当地藏族人民的声望还是很高的，是他统一了西藏的各个部落，有点像中国秦始皇的感觉吧。</p>
<p><img src="http://qiracle.cn/img/west/06.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/07.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/08.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/09.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/10.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/11.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/12.jpg" alt=""></p>
<h3 id="Day3-–-布达拉宫，大昭寺"><a href="#Day3-–-布达拉宫，大昭寺" class="headerlink" title="Day3 – 布达拉宫，大昭寺"></a>Day3 – 布达拉宫，大昭寺</h3><p>早上睡到自然醒，就去了<strong>八廓街</strong>，是拉萨著名的转经道和商业中心, 感觉没啥好看的，中午吃了家很有名的网红藏餐厅，叫<strong>央卿仓</strong>藏餐厅，点了个藏牦牛火锅，特色烤蘑菇，以及酥油茶，总共240， 味道一般，没有想象中的好吃，主要是吃不惯藏菜的口味， 其实在西藏，更多的餐厅是川菜，因为当地有很多四川人，从川菜和藏菜在全国的普及度也可以看出来，全国人民更爱吃川菜啦。吃完后，由于布达拉宫预约的是下午2点，所以，我们先去了布达拉宫广场上各种摆拍布达拉宫，毕竟是标志性建筑，50块钱人民币上印的就是它。</p>
<p>到了下午2点，开始进入<strong>布达拉宫</strong>，门票200，爬上布达拉宫是真的累，因为刚来西藏，还没完全适应这高原，基本上爬两步就休息一会。到了布达拉宫里面，里面就是各种佛像，想请的导游，因为没有导游讲解真的是啥也看不懂，但是由于疫情，里面已经没导游了 ，然后我们就跟着别的旅游团的导游，蹭着听，学习到了不少藏传佛教的知识，比如藏传佛教的两大领袖: <strong>达赖喇嘛</strong>和<strong>班禅额尔德尼</strong> 的灵童转世这一奇特的习俗。</p>
<p>出了布达拉宫，去大昭寺与小红书上认识的两个妹子碰面，然后一起逛了<strong>大昭寺</strong>，后来也是跟她们一起包车游的西藏。大昭寺里也就是一些佛像，我们也请了导游，由于之前在布达拉宫也听过了导游讲的藏传佛教，所以再听感觉也没啥意思，没逛多久就出来了 。大昭寺门票好像是100，个人感觉进了布达拉宫就没必要去大昭寺了，尤其是不信佛的人。晚上去吃了家尼泊尔餐厅，叫<strong>娜玛瑟德</strong>餐厅，还不错，尼泊尔餐厅在拉萨也挺有名的。</p>
<p><img src="http://qiracle.cn/img/west/13.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/14.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/15.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/16.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/17.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/18.jpg" alt=""></p>
<h3 id="Day4-–-巴松错"><a href="#Day4-–-巴松错" class="headerlink" title="Day4 – 巴松错"></a>Day4 – 巴松错</h3><p>从今天开始，客栈老板开着他的车带我们环行西藏，环行路线是我们从别的领队那复制过来的，后来客栈老板分析这路线其实是不太合理的，这就导致我们后来在路上的时间太长了，玩的景点就变少了。</p>
<p>从拉萨出发，向东往林芝方向开，因为林芝海拔比较多，只有2000多米，一般来西藏会先去林芝适应下高原，再慢慢的去高海拔地区地区玩。林芝在西藏属于开发的比较完善的旅游区，所以路都修的比较好，车子很好开。</p>
<p>第一站，我们先来到了<strong>巴松错</strong>，距离拉萨360公里，门票170。作为来到西藏看的第一个自然景观，还是很新奇的，用一句话描述这里就是：青山，绿水，蓝天，白云皆汇与此。还是第一次见到如此碧绿的湖面，山上盘卧的白云，感觉在山上伸手就能摸到，因为在西藏的云都压的很低，可能跟高海拔有关。</p>
<p>其实来西藏，看的最多的就是各种’’错’’了，错在藏语里的意思就是湖。这里有的错是绿色的，比如这里的巴松错，还有后面看到的色林错，有的错是蓝色的，比如羊卓雍措，纳木错。据说这和湖里的矿物质元素以及光的反射有关。</p>
<p>逛完巴松错，已经下午5点多了，我们启程去林芝市的酒店住下，晚上吃了当地有名的<strong>石锅鸡</strong>，<strong>藏香猪</strong>，这一天就over了。</p>
<p><img src="http://qiracle.cn/img/west/19.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/20.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/21.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/22.jpg" alt=""></p>
<h3 id="Day5-–-雅鲁藏布大峡谷"><a href="#Day5-–-雅鲁藏布大峡谷" class="headerlink" title="Day5 – 雅鲁藏布大峡谷"></a>Day5 – 雅鲁藏布大峡谷</h3><p>这天早上在酒店吃完早饭，上车准备出发的时候，酒店老板拿着几块白色围巾一样的东西走过来，这时司机示意我们把车门打开，说这是敬献<strong>哈达</strong>，是藏族的一种祝福礼仪，第一次切实的感受到热情的藏族人民。</p>
<p>车子开了两小时左右，就到了<strong>雅鲁藏布大峡谷</strong>景区，门票240，峡谷中穿梭奔腾的河流是雅鲁藏布江，雅鲁藏布大峡谷是世界上最大的峡谷，从雅鲁藏布大峡谷观景台可以看到中国最美山峰-<strong>-南迦巴瓦峰</strong>。因此景区内有了到“<strong>世界最大峡谷，观中国最美山峰</strong>”的标语。南迦巴瓦在藏语里的意思是“直刺天空的长矛”，南迦巴瓦峰海拔7782米，世界第28高峰，属于喜马拉雅山脉，位于喜马拉雅山脉最东端，因南迦巴瓦峰十次九不遇，常年被云雾缭绕，全年只有40天左右能看清它的全貌，因此又被称为“羞女峰”。所以，很正常，这次我们来看到的南迦巴瓦峰也是被云挡住了一部分。</p>
<p>从雅鲁藏布大峡谷出来，开车两小时，来到了<strong>鲁朗小镇</strong>，坐落在深山老林之中，这是一片典型高原山地草甸狭长地带，也是我们今晚住宿的地方，到小镇上找了个民宿，环境一般。然后就去鲁朗林海里采蘑菇。此时已经晚上8点了，但是天还是很亮，因为跟内地有两个小时的时差。</p>
<p><img src="http://qiracle.cn/img/west/23.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/24.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/25.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/26.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/27.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/28.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/29.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/30.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/31.jpg" alt=""></p>
<h3 id="Day6-–-拉姆拉错"><a href="#Day6-–-拉姆拉错" class="headerlink" title="Day6 – 拉姆拉错"></a>Day6 – 拉姆拉错</h3><p>这一天我们早上7点就出发了，这边天还没亮，前往<strong>拉姆拉错</strong>，拉姆拉错是西藏三大圣湖之一，另外两个是纳木错和玛旁雍错。 因为距离比较远，这一天基本在车上度过，车上跟司机闲聊，他说拉姆拉错近两年都没啥人去，旅行团也很少有人去那的，除非是信徒啥的，因为被奉为圣湖，班禅在寻找达赖喇嘛的转世灵童时，会来到拉姆拉错前观察湖面所显现的异象来确定寻访方向，据说有缘之人可以在湖面上看到自己的前世今生。当然我觉得这是扯淡，因为我在湖前闭眼，双手在胸前合上虔诚的跪了几分钟，然后睁眼啥也没看到。下午差不多3点，到了拉姆拉错景区，这里海拔5000米，要想看到湖，还得爬山，从山上往下看湖。这座山爬的是真累，体验到了缺氧的感觉，爬了一个多小时，终于看到了拉姆拉错，湖距离我们还是很远的，说实话，真的很普通，通俗的说就是一个大水池子，没看出啥特别的。山上也没几个游客，这个地方不是很推荐来，这就是我前面说的规划的西藏环行路线不合理的地方之一。另外近两年这个地方是不允许把拍的照片上传到网上的，所以这里就不上传湖的图片了。不过在海拔5000米的高原爬山这种体验还是挺爽的。</p>
<p><img src="http://qiracle.cn/img/west/32.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/33.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/34.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/35.jpg" alt=""></p>
<h3 id="Day7-–-羊卓雍错"><a href="#Day7-–-羊卓雍错" class="headerlink" title="Day7 – 羊卓雍错"></a>Day7 – 羊卓雍错</h3><p><strong>羊卓雍错</strong>俗称羊湖，在抖音上非常火，在这里我第一次看到了跟天一样蓝的湖水，真的是太美了，这里距离拉萨只有100多km，如果在拉萨当天就可以来回，真的是来西藏最值得去的地方之一，我无法用语言来描述这里。只能放图片了自己感受。羊湖玩完之后，我们向日喀则，这个也是此次路线不合理的地方，因为日喀则一般是作为去珠峰的中转地，去珠峰的路上会到那住宿休息一晚，而此次行程因为时间不够没法去珠峰，所以也不应该跑去这么老远的日喀则来住宿，而去日喀则的路上也就经过了个<strong>卡若拉冰川</strong>，拍了几张照，属实没啥好看的。这就导致接下来的一天，前往纳木错基本在车上度过，因为日喀则距离纳木错有500km左右。我们到日喀则已经差不多晚上9点了，我们在日喀则市里找了个新疆的清真餐厅，吃了个新疆大盘鸡，分量是真的多。</p>
<p><img src="http://qiracle.cn/img/west/36.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/37.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/38.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/39.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/40.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/41.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/42.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/43.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/44.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/45.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/46.jpg" alt=""></p>
<h3 id="Day8-–-色林错"><a href="#Day8-–-色林错" class="headerlink" title="Day8 – 色林错"></a>Day8 – 色林错</h3><p>由于前面路线规划的问题，导致今天坐了十个小时的车啊，途径的景点只有<strong>色林错</strong>，它是<strong>西藏第一大湖泊</strong>及中国第二大咸水湖，并且它的面积还在不断增大。这个湖还是很好看的，湖面呈绿色，但手机感觉总拍不出眼睛看到的感觉。在色林错待了一会，就继续开始前往纳木错景区。晚上8点左右，到了纳木错景区外，本来预定了房车在这里过夜，但是本来说好的价格可能由于今晚来的人多了，那人临时抬高价格让我们很不爽，最后没住房车，司机联系了当地的居民，住了当地居民自己空出的一个房子里，150/人。在这里环境算是不错的了，因为据说还有那种20人的大通铺。就是房子的位置有点恐怖，周围的房子没一个亮灯的，漆黑一片，厕所也没有，想上厕所只能贴近大自然了，不过也已经习惯了，，因为车上一路贴近大自然也不是一两次了….. 晚上这里的星空特别漂亮，因为海拔高，在没有云的情况下可以看到满天繁星。</p>
<p><img src="http://qiracle.cn/img/west/47.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/48.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/49.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/50.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/51.jpg" alt=""></p>
<h3 id="Day9-–-纳木错-圣象天门"><a href="#Day9-–-纳木错-圣象天门" class="headerlink" title="Day9 – 纳木错-圣象天门"></a>Day9 – 纳木错-圣象天门</h3><p>来西藏的最后一站，也是我来西藏最想去的地方，这个地方在抖音上被吹到爆了。在通往<strong>圣象天门</strong>的路上，有一段必经的30公里的搓衣板路，会颠到你怀疑人生，司机说它曾经自己开车带客走这条路，然后车门被颠坏了。之后他就不敢走这条路了，都是让游客坐景区专门的车到圣象天门，车票100，门票80。</p>
<p>圣象天门位于纳木错北岸的恰多郎卡岛上，海拔4700多米，当地人说，这里是<strong>纳木错</strong>和<strong>念青唐古拉</strong>的婚姻契约地，这里代表永恒与圣洁。下面还是直接上图感受吧。</p>
<p><img src="http://qiracle.cn/img/west/52.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/53.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/54.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/55.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/56.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/57.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/58.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/59.jpg" alt=""></p>
<h3 id="Day10-amp-amp-Day11-西安-返程"><a href="#Day10-amp-amp-Day11-西安-返程" class="headerlink" title="Day10 &amp;&amp; Day11 西安 返程"></a>Day10 &amp;&amp; Day11 西安 返程</h3><p>开始返程，从拉萨出发，到西安转机回南京，在我之前想去的西安待了一天，看了<strong>西安兵马俑</strong>，完美结束。</p>
<p><img src="http://qiracle.cn/img/west/60.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/61.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/62.jpg" alt=""></p>
<p><img src="http://qiracle.cn/img/west/63.jpg" alt=""></p>
<p>最后附上六世达赖喇嘛同时也是西藏历史上著名的诗人<strong>仓央嘉措</strong>的一首诗，它刻在了那古拉山口的石碑上：</p>
<p><strong>那一年</strong></p>
<p><strong>我磕长头匍匐在山路</strong></p>
<p><strong>不为觐见</strong></p>
<p><strong>只为贴着你的温暖</strong></p>
<p><strong>那一世</strong></p>
<p><strong>我转山转水转佛塔</strong> </p>
<p> <strong>不为修来生</strong></p>
<p><strong>只为途中与你相见</strong></p>
<p><img src="http://qiracle.cn/img/west/64.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;西藏，新疆，内蒙是国内我最想去的三个地方，它们分别对应着雪山，沙漠和草原，这次凑了7天假，连着两个周末，总共十一天，和朋友一起去西藏逛了一圈。&lt;/p&gt;
&lt;p&gt;由于只有十一天的时间，不算长，所以没有选择坐火车进藏，而是先从南京飞到重庆，再到重庆转机，飞到拉萨，目前国内能直飞拉萨的好像只有成都，重庆，西宁，西安了。进拉萨的机票不算贵，南京到重庆300多，重庆到拉萨600多，总共才1000多一点。但是有个很坑的地方是飞出拉萨的机票特别贵，回去时买的拉萨飞西安的就差不多1700。所以如果有时间的话，最好还是飞机进藏，火车出藏，这样既能欣赏到火车穿出青藏高原的沿路美景，还比较省钱。
    
    </summary>
    
      <category term="游记" scheme="http://qiracle.github.io/categories/%E6%B8%B8%E8%AE%B0/"/>
    
    
      <category term="心灵感悟" scheme="http://qiracle.github.io/tags/%E5%BF%83%E7%81%B5%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>java反射获得泛型参数getGenericSuperclass</title>
    <link href="http://qiracle.github.io/2020/06/14/20200614/"/>
    <id>http://qiracle.github.io/2020/06/14/20200614/</id>
    <published>2020-06-13T16:00:00.000Z</published>
    <updated>2020-06-14T04:11:53.750Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Student st=<span class="keyword">new</span> Student();</span><br><span class="line">Class clazz=st.getClass();</span><br><span class="line"><span class="comment">//getSuperclass()获得该类的父类</span></span><br><span class="line">System.out.println(clazz.getSuperclass());</span><br><span class="line"><span class="comment">//getGenericSuperclass()获得带有泛型的父类</span></span><br><span class="line"><span class="comment">//Type是 Java 编程语言中所有类型的公共高级接口。它们包括原始类型、参数化类型、数组类型、类型变量和基本类型。</span></span><br><span class="line">Type type=clazz.getGenericSuperclass();</span><br><span class="line">System.out.println(type);</span><br><span class="line"><span class="comment">//ParameterizedType参数化类型，即泛型</span></span><br><span class="line">ParameterizedType p=(ParameterizedType)type;</span><br><span class="line"><span class="comment">//getActualTypeArguments获取参数化类型的数组，泛型可能有多个</span></span><br><span class="line">Class c=(Class) p.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class com.test.Person</span><br><span class="line">com.test.Person&lt;com.test.Student&gt;</span><br><span class="line">class com.test.Student</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
    
    </summary>
    
      <category term="知识总结" scheme="http://qiracle.github.io/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Android" scheme="http://qiracle.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>java 动态代理</title>
    <link href="http://qiracle.github.io/2020/06/14/2020061402/"/>
    <id>http://qiracle.github.io/2020/06/14/2020061402/</id>
    <published>2020-06-13T16:00:00.000Z</published>
    <updated>2020-06-14T11:10:14.437Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代理的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ManToolsFactory</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saleManTools</span><span class="params">(String size)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AaFactory</span> <span class="keyword">implements</span> <span class="title">ManToolsFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleManTools</span><span class="params">(String size)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"按需求定制了一个size为"</span>+size+<span class="string">"的model"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarkCompany</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*持有的真实对象*/</span></span><br><span class="line">    <span class="keyword">private</span> Object factory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFactory</span><span class="params">(Object factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*通过Proxy获得动态代理对象*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(factory.getClass().getClassLoader(),</span><br><span class="line">                factory.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*通过动态代理对象方法进行增强*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  </span><br><span class="line">        Object result = method.invoke(factory, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*动态代理模式---------------*/</span></span><br><span class="line">        ManToolsFactory aafactory = <span class="keyword">new</span> AaFactory();</span><br><span class="line">        MarkCompany markCompany = <span class="keyword">new</span> MarkCompany();</span><br><span class="line"></span><br><span class="line">        markCompany.setFactory(aafactory);</span><br><span class="line">        ManToolsFactory employee1</span><br><span class="line">                = (ManToolsFactory)markCompany.getProxyInstance();</span><br><span class="line">        employee1.saleManTools(<span class="string">"E"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
    
    </summary>
    
      <category term="知识总结" scheme="http://qiracle.github.io/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Android" scheme="http://qiracle.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>java 线程池</title>
    <link href="http://qiracle.github.io/2020/03/21/20200321/"/>
    <id>http://qiracle.github.io/2020/03/21/20200321/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-03-21T07:21:58.103Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h3><p>1.减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。创建线程关闭线程花销是比较大的。</p>
<p>2.可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。<a id="more"></a></p>
<p>Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。<br>(参考  <a href="https://www.zhihu.com/question/41134816/answer/1086805195" target="_blank" rel="external">https://www.zhihu.com/question/41134816/answer/1086805195</a>)</p>
<h3 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseThreadPool</span> </span>&#123;</span><br><span class="line">   <span class="comment">//工作线程</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String taskName;</span><br><span class="line">        <span class="keyword">private</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(String taskName)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.taskName = taskName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> taskName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()</span><br><span class="line">                  +<span class="string">" process the task : "</span> + taskName);</span><br><span class="line">            SleepTools.ms(r.nextInt(<span class="number">100</span>)*<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallWorker</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">private</span> String taskName;</span><br><span class="line">        <span class="keyword">private</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CallWorker</span><span class="params">(String taskName)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.taskName = taskName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> taskName;</span><br><span class="line">        &#125;      </span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()</span><br><span class="line">                  +<span class="string">" process the task : "</span> + taskName);</span><br><span class="line">            <span class="keyword">return</span> Thread.currentThread().getName()+<span class="string">":"</span>+r.nextInt(<span class="number">100</span>)*<span class="number">5</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException, ExecutionException</span><br><span class="line">    </span>&#123;</span><br><span class="line">       ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,TimeUnit.SECONDS,</span><br><span class="line">             <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">10</span>),</span><br><span class="line">             <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++) &#123;</span><br><span class="line">            Worker worker = <span class="keyword">new</span> Worker(<span class="string">"worker_"</span>+i);</span><br><span class="line">            pool.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++) &#123;</span><br><span class="line">            CallWorker callWorker = <span class="keyword">new</span> CallWorker(<span class="string">"callWorker_"</span>+i);</span><br><span class="line">            Future&lt;String&gt; result = pool.submit(callWorker);</span><br><span class="line">            System.out.println(result.get());</span><br><span class="line">        &#125;</span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程池中几个参数的含义"><a href="#线程池中几个参数的含义" class="headerlink" title="线程池中几个参数的含义"></a>线程池中几个参数的含义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor mExecutor = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize,<span class="comment">// 核心线程数  </span></span><br><span class="line">                        maximumPoolSize, <span class="comment">// 最大线程数  </span></span><br><span class="line">                        keepAliveTime, <span class="comment">// 闲置线程存活时间  </span></span><br><span class="line">                        TimeUnit.MILLISECONDS,<span class="comment">// 时间单位  </span></span><br><span class="line">                        <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(),<span class="comment">// 线程队列  </span></span><br><span class="line">                        Executors.defaultThreadFactory(),<span class="comment">// 线程工厂  </span></span><br><span class="line">                        <span class="keyword">new</span> AbortPolicy()<span class="comment">// 队列已满,而且当前线程数已经超过最大线程数时的异常处理策略  </span></span><br><span class="line">                );</span><br></pre></td></tr></table></figure>
<h3 id="四种拒绝策略"><a href="#四种拒绝策略" class="headerlink" title="四种拒绝策略"></a>四种拒绝策略</h3><p>CallerRunsPolicy : 当线程池和队列都满时，任务将会被任务的调用方线程执行，如果线程池关闭，那么任务将会被抛弃<br>AbortPolicy ：当线程池和队列都满时，再有任务进来直接抛出RejectedExecutionException异常<br>DiscardPolicy: 当线程池和队列都满时，再有任务进来，默默的将任务抛弃<br>DiscardOldestPolicy： 当线程池和队列都满时，再有任务进来，抛弃最老的未处理的任务即当前队列中排在最前面的任务，然后重试该新进来的任务，如果线程池关闭，那么任务将会被抛弃</p>
<h3 id="阻塞队列BlockingQueue"><a href="#阻塞队列BlockingQueue" class="headerlink" title="阻塞队列BlockingQueue"></a>阻塞队列BlockingQueue</h3><p><strong>add(Object):</strong>  把 Object 加到 BlockingQueue 里,即如果 BlockingQueue 可以容纳,则返回 true, 否则招聘异常</p>
<p><strong>offer(Object): </strong>表示如果可能的话,将 Object 加到 BlockingQueue 里, 即如果 BlockingQueue 可以容纳,则返回true,否则返回false.</p>
<p><strong>put(anObject): </strong>把 Object 加到 BlockingQueue 里, 如果 BlockQueue 没有空间,则调用此方法的线程被<strong>阻塞</strong>直到BlockingQueue里面有空间再继续.</p>
<p><strong>poll(time):</strong> 取走 BlockingQueue 里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null</p>
<p><strong>take(): </strong>取走 BlockingQueue 里排在首位的对象,若 BlockingQueue 为空, <strong>阻塞</strong>进入等待状态直到Blocking有新的对象被加入为止</p>
<h3 id="核心线程数的设置"><a href="#核心线程数的设置" class="headerlink" title="核心线程数的设置"></a>核心线程数的设置</h3><p>任务类型：<br>cpu密集型 不要超过cpu并行线程数：Runtime.getRuntime().availableProcessors()+1</p>
<p>io密集型 Runtime.getRuntime().availableProcessors() x2</p>
<h3 id="线程进入顺序"><a href="#线程进入顺序" class="headerlink" title="线程进入顺序"></a>线程进入顺序</h3><p>corePoolSize —&gt; BlockingQueue —&gt; maximumPoolSize </p>
<p>若最大线程数也满了，再进入的线程按设置的拒绝策略执行。</p>
<p><img src="http://qiracle.cn/img/20200321/2020032101.png" alt="java内存" title="线程池"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么要使用线程池&quot;&gt;&lt;a href=&quot;#为什么要使用线程池&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用线程池&quot;&gt;&lt;/a&gt;为什么要使用线程池&lt;/h3&gt;&lt;p&gt;1.减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。创建线程关闭线程花销是比较大的。&lt;/p&gt;
&lt;p&gt;2.可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。
    
    </summary>
    
      <category term="知识总结" scheme="http://qiracle.github.io/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="java" scheme="http://qiracle.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio 导入classes.jar包</title>
    <link href="http://qiracle.github.io/2020/01/01/20200101/"/>
    <id>http://qiracle.github.io/2020/01/01/20200101/</id>
    <published>2019-12-31T16:00:00.000Z</published>
    <updated>2020-01-01T07:45:53.285Z</updated>
    
    <content type="html"><![CDATA[<p>Android SDK 中有很多带有 @hide 注解的 api，这些API为系统隐藏的 api，上层应用无法直接调用。我们开发时如果必须使用有两种方式，一是利用java反射机制。二则是在我们项目中导入 Android 系统源码编译出的classes.jar 包，该 jar 包生成在out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/classes.jar。这里我重点介绍Android Studio如何导入classes.jar.<a id="more"></a></p>
<p>1.考虑到 libs 目录下可能会有其他 jar 包，我们在app目录下建立 syslibs 文件夹，并将 classes.jar 包放入该路径，因为这里的 classes.jar 包只用于编译，无须打包进 apk 中。</p>
<p>2.右键工程–&gt;【Open Module Settings】，点击左侧【Dependencies】，选择app，点击【+】选择【2 Jar Dependency】，添加jar包，如下图。</p>
<p><img src="http://qiracle.cn/img/20200101/0101.png" alt=""></p>
<p>3.经过步骤2之后，Module的build.gradle中，dependencies自动增加依赖配置 如下：</p>
<p><code>implementation files(&#39;syslibs\\classes.jar&#39;)</code></p>
<p>修改为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compileOnly files(&apos;syslibs\\classes.jar&apos;)</span><br></pre></td></tr></table></figure>
<p>这么做是因为我们使用该jar包只用于编译，不打包进apk中，该包里包含的是Android SDK，当apk运行到手机里时，手机里有运行所需的sdk环境。</p>
<p>4.project 的 build.gradle添加如下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gradle.projectsEvaluated &#123;</span><br><span class="line">    tasks.withType(JavaCompile) &#123;</span><br><span class="line">        options.compilerArgs.add(&apos;-Xbootclasspath/p:app\\syslibs\\classes.jar&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加位置如下:</p>
<p><img src="http://qiracle.cn/img/20200101/0102.png" alt=""></p>
<p>5.修改jar包优先级，在Moduels的app.iml文件中找到我们的classes.jar包所在行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;orderEntry type=&quot;library&quot; name=&quot;Gradle: __local_aars__:D.\AndroidStudioProjects\Blue\app\syslibs\classes.jar:unspecified@jar&quot; level=&quot;project&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>将其移动到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;orderEntry type=&quot;jdk&quot; jdkName=&quot;Android API 28 Platform&quot; jdkType=&quot;Android SDK&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>之上。</p>
<p>这么做是为了让项目编译时优先用我们提供的jar包里的SDK，而不是原有Android SDK。</p>
<p>6.经过第5步之后，就能正常使用我们jar里的SDK了，但是，每次编译之后，app.iml 中的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;orderEntry type=&quot;jdk&quot; jdkName=&quot;Android API 28 Platform&quot; jdkType=&quot;Android SDK&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>又会被移动到最上面。下次编译时我们又得将他移动到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;orderEntry type=&quot;library&quot; name=&quot;Gradle: __local_aars__:D.\AndroidStudioProjects\Blue\app\syslibs\classes.jar:unspecified@jar&quot; level=&quot;project&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>的后面，这样比较麻烦。网上提供了一种一劳永逸的方法，将下面的代码加入到Moudle的build.gradle里：</p>
<pre><code>preBuild {
    doLast {

    def imlFile = file(project.name + &quot;.iml&quot;)

    println &apos;Change &apos; + project.name + &apos;.iml order&apos;

    try {

        def parsedXml = (new XmlParser()).parse(imlFile)

        def jdkNode = parsedXml.component[1].orderEntry.find { it.&apos;@type&apos; == &apos;jdk&apos; }

        parsedXml.component[1].remove(jdkNode)

        def sdkString = &quot;Android API &quot; + android.compileSdkVersion.substring(&quot;android-&quot;.length()) + &quot; Platform&quot;

        new Node(parsedXml.component[1], &apos;orderEntry&apos;, [&apos;type&apos;: &apos;jdk&apos;, &apos;jdkName&apos;: sdkString, &apos;jdkType&apos;: &apos;Android SDK&apos;])

        groovy.xml.XmlUtil.serialize(parsedXml, new FileOutputStream(imlFile))

    } catch (FileNotFoundException e) {

        // nop, iml not found

    }

   }
}
</code></pre><p>加入位置如下：</p>
<p><img src="http://qiracle.cn/img/20200101/0103.png" alt=""></p>
<p>至此，classes.jar导入完成，我们可以在Android Studio里可以直接调用系统隐藏的api里，如果遇到某些系统隐藏的api在使用时报红，一般为ide为bug，可以尝试clean project，然后rebuild project恢复正常了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android SDK 中有很多带有 @hide 注解的 api，这些API为系统隐藏的 api，上层应用无法直接调用。我们开发时如果必须使用有两种方式，一是利用java反射机制。二则是在我们项目中导入 Android 系统源码编译出的classes.jar 包，该 jar 包生成在out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/classes.jar。这里我重点介绍Android Studio如何导入classes.jar.
    
    </summary>
    
      <category term="知识总结" scheme="http://qiracle.github.io/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Android" scheme="http://qiracle.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 自定义属性</title>
    <link href="http://qiracle.github.io/2019/12/01/20191201/"/>
    <id>http://qiracle.github.io/2019/12/01/20191201/</id>
    <published>2019-11-30T16:00:00.000Z</published>
    <updated>2019-12-01T07:29:29.341Z</updated>
    
    <content type="html"><![CDATA[<p>本文以 ToggleButton 为例，介绍 Android 自定义属性的基本流程，代码在：<a href="https://github.com/qiracle/ToggleButton" target="_blank" rel="external">https://github.com/qiracle/ToggleButton</a> 。<a id="more"></a></p>
<h3 id="定义-attrs-xml"><a href="#定义-attrs-xml" class="headerlink" title="定义 attrs.xml"></a>定义 attrs.xml</h3><p>在values目录下增加 attrs.xml 文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 声名属性集的名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">"MyToggleBtn"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 声名一个属性  name是my_background   类型为 引用类型      引用资源ID --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"my_background"</span> <span class="attr">format</span>=<span class="string">"reference"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 声名一个属性  name是my_slide_btn   类型为 引用类型      引用资源ID --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"my_slide_btn"</span> <span class="attr">format</span>=<span class="string">"reference"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 声名一个属性  name是curr_state   类型为 boolean 类型--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"curr_state"</span> <span class="attr">format</span>=<span class="string">"boolean"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="在布局文件中引用"><a href="#在布局文件中引用" class="headerlink" title="在布局文件中引用"></a>在布局文件中引用</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"</span><br><span class="line">    &lt;!--命名空间 qiracle ，给下面使用--&gt;</span><br><span class="line">    xmlns:qiracle="http://schemas.android.com/apk/res-auto" </span><br><span class="line">    xmlns:tools="http://schemas.android.com/tools"</span><br><span class="line">    android:layout_width="match_parent"</span><br><span class="line">    android:layout_height="match_parent"</span><br><span class="line">    tools:context=".MainActivity"&gt;</span><br><span class="line"></span><br><span class="line">    &lt;cn.qiracle.customattr.MyToggleButton</span><br><span class="line">        android:id="@+id/my_toggle_btn"</span><br><span class="line">        android:layout_width="wrap_content"</span><br><span class="line">        android:layout_height="wrap_content"</span><br><span class="line">        android:layout_centerHorizontal="true"</span><br><span class="line">        android:layout_centerVertical="true"</span><br><span class="line">        qiracle:my_background="@drawable/switch_background"</span><br><span class="line">        qiracle:my_slide_btn="@drawable/slide_button"</span><br><span class="line">        qiracle:curr_state="false"</span><br><span class="line">        testAttrs="hello"</span><br><span class="line">        /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure>
<h3 id="在代码里设置属性"><a href="#在代码里设置属性" class="headerlink" title="在代码里设置属性"></a>在代码里设置属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">	 * 在布局文件中声名的view，创建时由系统自动调用。</span><br><span class="line">	 * <span class="doctag">@param</span> context	上下文对象</span><br><span class="line">	 * <span class="doctag">@param</span> attrs		属性集</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyToggleButton</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(context, attrs);</span><br><span class="line">       </span><br><span class="line">		</span><br><span class="line">		<span class="comment">//无命名空间测试</span></span><br><span class="line">		</span><br><span class="line">		String testAttrs = attrs.getAttributeValue(<span class="keyword">null</span>, <span class="string">"testAttrs"</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"testAttrs===:"</span>+testAttrs);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">		 * AttributeSet  对XML文件解析后的结果，封装为 AttributeSet 对象。</span><br><span class="line">		 * 存储的都是原始数据。仅对数据进行简单加工。</span><br><span class="line">		 */</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> count = attrs.getAttributeCount();</span><br><span class="line">		<span class="comment">// 打印MyToggleButton所有属性 ，也就是上面布局文件里的9个</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">			String name = attrs.getAttributeName(i);</span><br><span class="line">			String value = attrs.getAttributeValue(i);</span><br><span class="line"><span class="comment">//			System.out.println("name : "+name+"  value : "+value);</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//获得自定义的属性</span></span><br><span class="line">		TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.MyToggleBtn);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> N = ta.getIndexCount();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">			<span class="comment">/*</span><br><span class="line">			 * 获得某个属性的ID值</span><br><span class="line">			 */</span></span><br><span class="line">			<span class="keyword">int</span> itemId = ta.getIndex(i);</span><br><span class="line">			<span class="keyword">switch</span> (itemId) &#123;</span><br><span class="line">			<span class="keyword">case</span> R.styleable.MyToggleBtn_curr_state:</span><br><span class="line">				currState = ta.getBoolean(itemId, <span class="keyword">false</span>);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> R.styleable.MyToggleBtn_my_background:</span><br><span class="line">				backgroundId = ta.getResourceId(itemId, -<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">if</span>(backgroundId == -<span class="number">1</span>)&#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"请设置背景图片"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				backgroundBitmap = BitmapFactory.decodeResource(getResources(), backgroundId);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> R.styleable.MyToggleBtn_my_slide_btn:</span><br><span class="line">				slideBtnId = ta.getResourceId(itemId, -<span class="number">1</span>);</span><br><span class="line">				slideBtn = BitmapFactory.decodeResource(getResources(), slideBtnId);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		ta.recycle(); <span class="comment">//回收ta，不回收as会提示</span></span><br><span class="line">		</span><br><span class="line">		initView();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文以 ToggleButton 为例，介绍 Android 自定义属性的基本流程，代码在：&lt;a href=&quot;https://github.com/qiracle/ToggleButton&quot;&gt;https://github.com/qiracle/ToggleButton&lt;/a&gt; 。
    
    </summary>
    
      <category term="知识总结" scheme="http://qiracle.github.io/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Android" scheme="http://qiracle.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 性能优化之布局优化</title>
    <link href="http://qiracle.github.io/2019/11/02/20191102/"/>
    <id>http://qiracle.github.io/2019/11/02/20191102/</id>
    <published>2019-11-01T16:00:00.000Z</published>
    <updated>2019-12-01T13:02:26.731Z</updated>
    
    <content type="html"><![CDATA[<p>在Android应用开发中，常用的布局方式主要有<strong>LinearLayout、RelativeLayout、FrameLayout</strong>等，通过这些布局可以实现各种各样的界面。我们需要知道如何高效地使用这些布局方式来组织UI控件，布局的好坏影响到绘制的时间，本节将通过减少<strong>Layout层级</strong>，<strong>减少测量</strong>、<strong>绘制时间</strong>，<strong>提高复用性</strong>三个方面来优化布局，优化的目的就是减少层级，让布局扁平化，以提高绘制的时间，提高布局的复用性节省开发和维护成本。 <a id="more"></a></p>
<h3 id="减少层级"><a href="#减少层级" class="headerlink" title="减少层级"></a>减少层级</h3><p>层级越少，测试和绘制的时间就越短，通常减少层级有以下两个常用方案：<br>合理使用 RelativeLayout 和 LinearLayout。<br>合理使用Merge。</p>
<h4 id="1-RelativeLayout与LinearLayout"><a href="#1-RelativeLayout与LinearLayout" class="headerlink" title="(1)RelativeLayout与LinearLayout"></a><strong>(1)RelativeLayout与LinearLayout</strong></h4><p>使用 RelativeLayout 减少层级：</p>
<p>!<img src="http://qiracle.cn/img/20191102/2019110201.png" alt=""></p>
<p>通过Hierarchy View来查看下层级情况:</p>
<p>!<img src="http://qiracle.cn/img/20191102/2019110202.png" alt=""></p>
<p>可以看到一共有7级，使用RelativeLayout进行优化，达到相同的布局效果，并且RelativeLayout允许子元素指定它们相对于其他元素或父元素的位置，有最大自由度的布局属性，而且布局层次最浅，占用内存最少。</p>
<p>!<img src="http://qiracle.cn/img/20191102/2019110203.png" alt=""></p>
<p>这样就可以减少两个层级，用一个RelativeLayout就可以达到显示的效果，再使用Hierarchy View来查看层级，可以看到减少到5层。</p>
<p><img src="http://qiracle.cn/img/20191102/2019110404.png" alt=""></p>
<p><strong>但ReativeLayout也存在性能低的问题，原因是RelativeLayout会对子View做两次测量</strong>，在RelativeLayout中子View的排列方式是基于彼此的依赖关系，因为这个依赖关系可能和布局中View的顺序并不相同，在确定每个子View的位置时，需要先给所有子View做一次排序。如果在RelativeLayout中允许子View横向和纵向互相依赖，就需要横向、纵向分别进行一次排序测量。<strong>但如果在LinearLayout中有weight属性，也需要进行两次测量，因为没有更多的依赖关系，所以仍然会比RelativeLayout的效率高，在布局上RelativeLayout不如LinearLayout快</strong>。</p>
<p><strong>但是如果布局本身层次太深，还是推荐用RelativeLayout减少布局本身层次</strong>，相较于测量两次，虽然会增加一些计算时间，但在体验上影响不会特别大，如果优化掉两层仅仅是增加一次测量，还是非常值得的，布局层次深会增加内存消耗，甚至引起栈溢出等问题，即使耗点时间，也不能让应用不可用。</p>
<p>根据以上分析，可以总结出以下几点布局原则：<br><strong>尽量使用RelativeLayout和LinearLayout。</strong><br><strong>在布局层级相同的情况下，使用LinearLayout。</strong><br><strong>用LinearLayout有时会使嵌套层级变多，应该使用RelativeLayout，使界面尽量扁平化。</strong></p>
<p><strong>注意</strong><br>由于Android的碎片化程度很高，市面上的屏幕尺寸也是各式各样，使用RelativeLayout能使构建的布局适应性更强，构建出来的UI布局对多屏幕的适配效果更好，通过指定UI控件间的相对位置，使不同屏幕上布局的表现基本保持一致。当然，也不是所有情况下都得使用相对布局，根据具体情况选择和搭配使用其他布局方式来实现最优布局。</p>
<h4 id="2-Merge的使用"><a href="#2-Merge的使用" class="headerlink" title="(2)Merge的使用"></a>(2)Merge的使用</h4><p>从名字上就可以看出，Merge就是合并的意思。使用它可以有效优化某些符合条件的多余的层级。使用Merge的场合主要有以下两处：</p>
<p><strong>在自定义View中使用，父元素尽量是FrameLayout或者LinearLayout。</strong><br><strong>在Activity中整体布局，根元素需要是FrameLayout。</strong></p>
<p>我们仍以前面的布局为例，在页面增加一个自定义控件TopBar:</p>
<p><img src="http://qiracle.cn/img/20191102/2019110205.png" alt=""></p>
<p>其中TopBar的XML布局如下:</p>
<p><img src="http://qiracle.cn/img/20191102/2019110206.png" alt=""></p>
<p>显示结果下图所示。这种布局在一些列表的Item中非常常见，而且列表中Item本身的层级比较深，因此优化显得更有意义。</p>
<p>我们使用HierarchyView查看增加TopBar后的布局层级，如图。可以看到，就是这么简单的一个布局，却把层级增加了两级，从图中很明显地看出TopBar后一层的LinearLayout是多余的，这时可以使用Merge把这一层消除。</p>
<p><img src="http://qiracle.cn/img/20191102/2019110207.png" alt=""></p>
<p><img src="http://qiracle.cn/img/20191102/2019110208.png" alt=""></p>
<p>使用Merge来优化布局，使用Merge标签替换LinearLayout后，原来的LinearLayout属性也没有用了，修改后的代码如下</p>
<p><img src="http://qiracle.cn/img/20191102/2019110209.png" alt=""></p>
<p>运行后再使用Hierarchy View查看当前层级</p>
<p><img src="http://qiracle.cn/img/20191102/2019110210.png" alt=""></p>
<p>这样就把多余的LinearLayout消除了，原理是在Android布局的源码中，如果是Merge标签，那么直接将其中的子元素添加到Merge标签Parent中，这样就保证了不会引入额外的层级。</p>
<p><strong>注意</strong><br>如果Merge代替的布局元素为LinearLayout，在自定义布局代码中将LinearLayout的属性添加到引用上，如垂直或水平布局、背景色等。</p>
<p>但Merge不是所有地方都可以任意使用，有以下几点<strong>要求：</strong></p>
<p><strong>Merge只能用在布局XML文件的根元素。</strong></p>
<p><strong>使用merge来加载一个布局时，必须指定一个ViewGroup作为其父元素，并且要设置加载的attachToRoot参数为true(参照inf late(int, ViewGroup, boolean))。</strong></p>
<p><strong>不能在ViewStub中使用Merge标签。原因就是ViewStub的inf late方法中根本没有attachToRoot的设置。</strong></p>
<p>这一节讲了如何减少层级，那么在Android系统中，多少层才是合理的呢？当然是越少越好，但从Lint检查的配置上看，超过10层才会报警，实际上在开发时，随着产品设计的丰富和多样性，很容易超过10层，根据实际开发过程中超过15层就要重视并准备做优化，20层就必须修改了。在实在没有办法优化的情况下，需要把复杂的层级用自绘控件来实现，自绘控件中的图层层级再多，在布局上也只是一层，但这样也会带来过度绘制的问题，后面会讲。</p>
<p><strong>注意</strong><br>在Activiy的总布局中使用Merge，但又想设置整体的属性(布局方式或背景色)，可以不使用setContentView方法加载Layout，而使用(id/content)将FrameLayout取出来，在代码中手动加载布局，但如果层级压力不大(小于10级)，则没有必要，因为这样代码的维护性较差。</p>
<h3 id="提高显示速度"><a href="#提高显示速度" class="headerlink" title="提高显示速度"></a>提高显示速度</h3><p>我们在开发的过程中会碰到这样的场景或者显示逻辑：某个布局当中的子布局非常多，但并不是所有元素都同时显示出来，而是二选一或者N选一，打开这个界面根据不同的场景和属性显示不同的Layout。例如：一个页面对不同的用户(未登录、普通用户、会员)来说，显示的布局不同。或者，有些用户喜欢对不同的元素使用INVISIBLE或者GONE隐藏，通过设计元素的visable属性来控制，这样虽然达到了隐藏的目的，但效率非常低，原因是即使将元素隐藏，它们仍在布局中，仍会测试和解析这些布局。Android提供了ViewStub控件来解决这个场景。</p>
<p><strong>ViewStub</strong>是一个轻量级的View，它是一个看不见的，并且不占布局位置，占用资源非常小的视图对象。可以为ViewStub指定一个布局，加载布局时，只有ViewStub会被初始化，然后当ViewStub被设置为可见时，或是调用了ViewStub.inf late()时，ViewStub所指向的布局会被加载和实例化，然后ViewStub的布局属性都会传给它指向的布局。这样，就可以使用ViewStub来设置是否显示某个布局。</p>
<p>下面的代码是两个ViewStub通过不同的初始化来加载两个不同的布局，以满足用户的需求。</p>
<p><img src="http://qiracle.cn/img/20191102/2019110211.png" alt=""></p>
<p>在调用时，根据需求切换不同的Layout，这样可以提高页面初始化的速度，使用代码如下：</p>
<p><img src="http://qiracle.cn/img/20191102/2019110212.png" alt=""></p>
<p>ViewStub显示有两种方式，上面代码使用的是inf ate方法，也可以直接使用ViewStub.setVisibiltity(View.Visible)方法。<br>使用ViewStub时需要<strong>注意</strong>以下几点：</p>
<ol>
<li><p>ViewStub只能加载一次，之后ViewStub对象会被置为空。换句话说，某个被ViewStub指定的布局被加载后，就不能再通过ViewStub来控制它了。所以它不适用于需要按需显示隐藏的情况。</p>
</li>
<li><p>ViewStub只能用来加载一个布局文件，而不是某个具体的View，当然也可以把View写在某个布局文件中。如果想操作一个具体的View，还是使用visibility属性。</p>
</li>
<li>VIewStub中不能嵌套Merge标签。</li>
</ol>
<p>不过这些限制都无伤大雅，我们还是能够用ViewStub来做很多事情，ViewStub的主要使用场景如下：<br>在程序运行期间，某个布局在加载后，就不会有变化，除非销毁该页面再重新加载。<br>想要控制显示与隐藏的是一个布局文件，而非某个View。</p>
<p><strong>注意</strong><br>因为ViewStub只能Inf late一次之后会被置空无法继续使用ViewStub来控制布局。所以当需要在运行时不止一次显示和隐藏某个布局时，使用ViewStub是无法实现的。这时只能使用View的可见性来控制。</p>
<h3 id="布局复用"><a href="#布局复用" class="headerlink" title="布局复用"></a>布局复用</h3><p>我们在开发应用时还会碰到另一个常见的场景，就是一个相同的布局在很多页面(Activity或Fragment)会用到，如果给这些页面的布局文件都统一加上相同的布局代码，维护起来就很麻烦，可读性也差，一旦需要修改，很容易有漏掉的地方，Android的布局复用可以通过<include>标签来实现，就像提取代码公用部分一样，在编写Android布局文件时，也可以将相同的部分提取出来，在使用时，用<include>添加进去。</include></include></p>
<p>例如，在大部分应用中，基本上所有的应用都会带有头部栏(TopBar)，主要是显示标题和返回键功能，这样只需要维护一份代码，就可以修改所有的显示效果。</p>
<p><strong>提示</strong><br>类似于TopBar的这类常用控件，包括菜单，可以把具体实现抽象到页面的基类(BaseActivity)中，这样布局和具体的实现都收归到一个地方，方便维护。<br>提高布局效率的方法总体来说就是减少层级，提高绘制速度和布局复用。影响布局效率主要有以下几点：</p>
<p>布局的层级越少，加载速度越快。<br>减少同一层级控件的数量，加载速度会变快。<br>一个控件的属性越少，解析越快。</p>
<p><strong>根据本节的分析，对优化的总结如下：</strong><br><strong>尽量多使用RelativeLayout或LinearLayout，不要使用绝对布局AbsoluteLayout。</strong><br><strong>将可复用的组件抽取出来并通过&lt; include /&gt;标签使用。</strong><br><strong>使用&lt; ViewStub /&gt;标签加载一些不常用的布局。</strong><br><strong>使用&lt; merge /&gt;标签减少布局的嵌套层次。</strong><br><strong>尽可能少用wrap_content， wrap_content会增加布局measure时的计算成本，已知宽高为固定值时，不用wrap_content。</strong><br><strong>删除控件中的无用属性。</strong></p>
<h3 id="避免过度绘制"><a href="#避免过度绘制" class="headerlink" title="避免过度绘制"></a>避免过度绘制</h3><p>过度绘制(Overdraw)是指在屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次重叠的UI结构(如带背景的TextView)中，如果不可见的UI也在做绘制的操作，就会导致某些像素区域被绘制了多次，从而浪费多余的CPU以及GPU资源。</p>
<p>当设计上追求更华丽的视觉效果时，我们很容易陷入采用复杂的多层次重叠视图来实现这种视觉效果的怪圈。这很容易导致大量的性能问题，为了获得最佳性能，必须尽量减少Overdraw情况发生。</p>
<p>我们一般在XML布局和自定义控件中绘制，因此可以看出导致过度绘制的主要原因是：<br>XML布局-&gt;控件有重叠且都有设置背景<br>View自绘-&gt; View.OnDraw里面同一个区域被绘制多次</p>
<p>如何查看是否有过度绘制：</p>
<p>在手机的“设置”→“开发者选项”中打开“显示GPU过度重绘”开关(注：对未默认开启硬件加速的界面需要同时打开“强制进行GPU渲染”开关)。</p>
<p>打开后可以根据不同的颜色观察UI上的Overdraw情况，蓝色、淡绿、淡红、深红代表4种不同程度的Overdraw情况，不同颜色的含义如下：<br>无色：没有过度绘制，每个像素绘制了1次。<br>蓝色：每个像素多绘制了1次。大片的蓝色还是可以接受的。如果整个窗口是蓝色的，可以尝试优化减少一次绘制。<br>绿色：每个像素多绘制了2次。<br>淡红：每个像素多绘制了3次。一般来说，这个区域不超过屏幕的1/4是可以接受的。<br>深红：每个像素多绘制了4次或者更多。严重影响性能，需要优化，避免深红色区域。<br>我们的目标是尽量减少红色Overdraw，看到更多的蓝色区域。</p>
<h4 id="如何避免过度绘制"><a href="#如何避免过度绘制" class="headerlink" title="如何避免过度绘制"></a>如何避免过度绘制</h4><p><strong>1.布局上的优化</strong></p>
<p>在XML布局上，如果出现了过度绘制的情况，可以使用Hierarchy View来查看具体的层级情况，可以通过XML布局优化来减少层级。需要注意的是，在使用XML文件布局时，会设置很多背景，如果不是必需的，尽量移除。布局优化总结为以下几点：<br>移除XML中非必需的背景，或根据条件设置。</p>
<p>移除Window默认的背景。</p>
<p>按需显示占位背景图片。</p>
<p>使用Android自带的一些主题时，activity往往会被设置一个默认的背景，这个背景由DecorView持有。当自定义布局有一个全屏的背景时，比如设置了这个界面的全屏黑色背景，DecorView的背景此时对我们来说是无用的，但是它会产生一次Overdraw。因此没有必要的话，也可以移除，代码如下：</p>
<p><img src="http://qiracle.cn/img/20191102/2019110213.png" alt=""></p>
<p>注意<br>针对 ListView 中的 Avatar ImageView 的设置，在 getView 的代码中，判断是否获取对应的 Bitmap，获取 Avatar的图像之后，把 ImageView 的 Background 设置为 Transparent，只有当图像没有获取到时，才设置对应的Background占位图片，这样可以避免因为给Avatar设置背景图而导致的过度渲染。</p>
<p><strong>2.自定义View优化</strong></p>
<p>事实上，由于我们的产品设计总是追求更华丽的视觉效果，仅仅通过布局优化很难做到最好，这时可以对复杂的控件使用自定义View来实现，虽然自定义View减少了Layout的层级，但在实际绘制时也是会过度绘制的。原因是有些过于复杂的自定义View(通常重写了onDraw方法)， Android系统无法检测在onDraw中具体会执行什么操作，无法监控并自动优化，也就无法避免Overdraw了。</p>
<p>但是在自定义View中可以通过<strong>canvas.clipRect()</strong>来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。canvas.clipRect()可以很好地帮助那些有多组重叠组件的自定义View来控制显示的区域。clipRect方法还可以帮助节约CPU与GPU资源，在clipRect区域之外的绘制指令都不会被执行，那些部分内容在矩形区域内的组件，仍然会得到绘制，并且可以使用<strong>canvas.quickreject()</strong>来判断是否没和某个矩形相交，从而跳过那些非矩形区域内的绘制操作。接下来介绍使用一个自定义View避免OverDraw的案例。</p>
<p><strong>快速判断Canvas是否需要绘制：Canvas.QuickReject：</strong></p>
<p>在绘制一个单元之前，首先判断该单元的区域是否在Canvas的剪切域内。若不在，直接返回，避免CPU和GPU的计算和渲染工作。</p>
<p><strong>避免绘制越界：Canvas.ClipRect：</strong></p>
<p>每个绘制单元都有自己的绘制区域，绘制前，Canvas.ClipRect(Region.Op.INTERSECT)帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内，才会被绘制，其他的区域被忽视。这个API可以很好地帮助那些有多组重叠组件的自定义View来控制显示的区域。clipRect方法还可以帮助节约CPU与GPU资源，在clipRect区域之外的绘制指令都不会被执行，那些部分内容在矩形区域内的组件，仍然会得到绘制。</p>
<p>本文参考：罗彧成的《Android应用性能优化最佳实践》一书。强烈推荐此书！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Android应用开发中，常用的布局方式主要有&lt;strong&gt;LinearLayout、RelativeLayout、FrameLayout&lt;/strong&gt;等，通过这些布局可以实现各种各样的界面。我们需要知道如何高效地使用这些布局方式来组织UI控件，布局的好坏影响到绘制的时间，本节将通过减少&lt;strong&gt;Layout层级&lt;/strong&gt;，&lt;strong&gt;减少测量&lt;/strong&gt;、&lt;strong&gt;绘制时间&lt;/strong&gt;，&lt;strong&gt;提高复用性&lt;/strong&gt;三个方面来优化布局，优化的目的就是减少层级，让布局扁平化，以提高绘制的时间，提高布局的复用性节省开发和维护成本。
    
    </summary>
    
      <category term="知识总结" scheme="http://qiracle.github.io/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="转载" scheme="http://qiracle.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>读《深入理解Java虚拟机》总结&lt;三.java中的新生代和老年代内存&gt;</title>
    <link href="http://qiracle.github.io/2019/09/21/20190921/"/>
    <id>http://qiracle.github.io/2019/09/21/20190921/</id>
    <published>2019-09-20T16:00:00.000Z</published>
    <updated>2019-09-21T07:42:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>新生代：新生代中98%的对象都是朝生夕死 （1个eden 区（80%） 和 2个survivor区（10%））。<br>老年代：存活对象存留的时间比较久。</p>
<p>MinorGC：发生在新生代的垃圾回收。很频繁，速度快。<br>FullGC：发生在老年代的垃圾回收。发生FullGC通常会伴随一次MinorGC（并非绝对），FullGC会比MinorGc慢10倍以上。<a id="more"></a></p>
<h3 id="内存分配与回收策略："><a href="#内存分配与回收策略：" class="headerlink" title="内存分配与回收策略："></a>内存分配与回收策略：</h3><p>1.对象优先在Eden区进行分配</p>
<p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次MinorGC</p>
<p>2.对象直接进入老年代</p>
<p>所谓大对象就是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串及数组，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾回收以获取足够的连续空间来安置他们。</p>
<p>3.长期存活的对象将进入老年代</p>
<p>虚拟机既然采用了分代收集的思想来管理内存，那内存回收时就必须能识别哪些对象应当放在新生代，哪些对象应放在老年代。为了做到这点，虚拟机给每个对象定义了一个对象年龄计数器。如果对象在Eden出生经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当他的年龄增加到一定程度（默认15）时，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过设置参数-XX:MaxTenuringThreshold。</p>
<p>4 动态对象年龄判定</p>
<p>为了更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
<p>5 空间分配担保</p>
<p>在发生MinorGC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则改为直接进行一次Full GC。如果小于，则查看HandlePromotionFailure设置是否允许担保失败：如果允许，那只会进行MinorGC；如果不允许，则也要改为进行一次FullGC。取平均值进行比较其实仍然是一种动态概率的手段，也就是说如果某次MinorGC存活后的对象突增，远远高于平均值得话，依然会导致担保失败。如果出现了担保失败，那只好在失败后重新发起FullGC。虽然担保失败时绕的圈子是最大的，但大部分情况下还是会将HandlePromotionFailure 开关打开，避免Full GC过于频繁。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;新生代：新生代中98%的对象都是朝生夕死 （1个eden 区（80%） 和 2个survivor区（10%））。&lt;br&gt;老年代：存活对象存留的时间比较久。&lt;/p&gt;
&lt;p&gt;MinorGC：发生在新生代的垃圾回收。很频繁，速度快。&lt;br&gt;FullGC：发生在老年代的垃圾回收。发生FullGC通常会伴随一次MinorGC（并非绝对），FullGC会比MinorGc慢10倍以上。
    
    </summary>
    
      <category term="知识总结" scheme="http://qiracle.github.io/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Android" scheme="http://qiracle.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android layout_weight 计算方式</title>
    <link href="http://qiracle.github.io/2019/09/15/20190915/"/>
    <id>http://qiracle.github.io/2019/09/15/20190915/</id>
    <published>2019-09-14T16:00:00.000Z</published>
    <updated>2019-09-15T01:17:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>假设：LinearLayout为android:orientation=”horizontal”， layout_weight属性值分别为1、2、2</p>
<p>第一种情况：每个控件的宽度属性都为android:layout_width=”0dp”，那么额外的空为（手机的宽度假设为X）X-0-0-0=X，那么根据sdk上所述：<a id="more"></a><br>第一个控件的宽度为 0+(1/(1+2+2))<em>X=X/5<br>第二个控件的宽度为 0+(2/(1+2+2))</em>X=2X/5<br>第三个控件的宽度为 0+(2/(1+2+2))*X=2X/5</p>
<p>第二种情况：每个控件的宽度属性都为android:layout_width=”match_parent”，那么额外的空间就是X-X-X-X=-2X<br>第一个控件的宽度为 X+(1/(1+2+2))<em>(-2X)=3X/5<br>第二个控件的宽度为 X+(2/(1+2+2))</em>(-2X)=X/5<br>第三个控件的宽度为 X+(2/(1+2+2))*(-2X)=X/5</p>
<p>第三种情况：其中第一个控件宽度属性为android:layout_width=”match_parent”，其他两个控件宽度为android:layout_width=”0dp”，额外的空间为X-X-0-0=0<br>第一个控件的宽度为 X+(1/(1+2+2))<em>0=X<br>第二个控件的宽度为 0+(2/(1+2+2))</em>0=0<br>第三个控件的宽度为 0+(2/(1+2+2))*0=0</p>
<p>最终结论：layout_weight的公式<br>控件的宽度/高度 = 控件的width/height值+（该控件的weight值/所有控件的weight的和）×额外的空间<br>额外的空间=手机的宽度/高度-所有控件的宽度/高度 </p>
<p>注：如果属性为android:layout_width=”wrap_content” 则计算时，总宽/高要减去控件本身占据的宽/高 </p>
<p>转自：<a href="https://blog.csdn.net/Dazlly/article/details/13767343" target="_blank" rel="external">https://blog.csdn.net/Dazlly/article/details/13767343</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设：LinearLayout为android:orientation=”horizontal”， layout_weight属性值分别为1、2、2&lt;/p&gt;
&lt;p&gt;第一种情况：每个控件的宽度属性都为android:layout_width=”0dp”，那么额外的空为（手机的宽度假设为X）X-0-0-0=X，那么根据sdk上所述：
    
    </summary>
    
      <category term="知识总结" scheme="http://qiracle.github.io/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Android" scheme="http://qiracle.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android屏幕适配 px,dp,dpi及density的关系与深入理解</title>
    <link href="http://qiracle.github.io/2019/09/15/2019091502/"/>
    <id>http://qiracle.github.io/2019/09/15/2019091502/</id>
    <published>2019-09-14T16:00:00.000Z</published>
    <updated>2019-09-15T01:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="PX-pixel"><a href="#PX-pixel" class="headerlink" title="PX(pixel):"></a><strong>PX(pixel):</strong></h4><p>即传统计算机语言中描述的像素，在Android则代表绝对像素。</p>
<p>之所以Android中不推荐使用这种单位，正是因为不同生产厂商，不同品牌，不同屏幕的设备，其分辨率亦不一。</p>
<p>举例来说，我们现在将某个Button的width设为160px，则会出现如下情况：</p>
<p>在分辨率为“320宽”的设备里，该按钮显示占屏幕宽度一半；</p>
<p>在分辨率为“640宽”的设备里，该按钮显示占屏幕宽度的四分之一；</p>
<a id="more"></a>
<h4 id="DPI-Dots-Per-Inch"><a href="#DPI-Dots-Per-Inch" class="headerlink" title="DPI(Dots Per Inch):"></a><strong>DPI(Dots Per Inch):</strong></h4><p>为了避免上面说到的使用px在屏幕适配中带来的问题，Android引入了一个新的单位：dp/dip。</p>
<p>而在理解“dp”之前，我们更有必要先了解一下另一个概念。正是：dpi。</p>
<p>也有人讲<strong>dpi称为“屏幕密度”</strong>。其含义则是：每英寸所打印的点数，<strong>既每一英寸的屏幕所包含的像素数。</strong></p>
<p>举例来说，假设现在有一台“宽2英寸，长3英寸”的设备，则：</p>
<p>当该设备分辨率为“320x480”，则dpi值为160。<br>当该设备分辨率为“640x960”，则dpi值为320。<br>而“dpi”值越高的设备，其屏幕显示画面的效果也就越精细。</p>
<p>使用场景：</p>
<p>正是因为dpi值其代表的特性，所以android项目的资源文件下存在以下目录：</p>
<p>drawable-ldpi    ( 当dpi为120时，使用此目录下的资源)<br>drawable-mdpi    ( 当dpi为160时，使用此目录下的资源)<br>drawable-hdpi    ( 当dpi为240时，使用此目录下的资源)<br>drawable-xhdpi   ( 当dpi为320时，使用此目录下的资源)<br>drawable-xxhdpi  ( 当dpi为480时，使用此目录下的资源)<br>Android正是根据设备DPI值得不同，选择清晰度不同的资源使用，完成屏幕的适配。</p>
<h4 id="DP-DIP-device-independent-pixels"><a href="#DP-DIP-device-independent-pixels" class="headerlink" title="DP/DIP(device independent pixels):"></a><strong>DP/DIP(device independent pixels):</strong></h4><p>与我们之前谈到的绝对密度“px”对应，Android中引入的“dp”代表的则是“设备独立像素”。</p>
<p>该单位是为支持WVGA、HVGA和QVGA而使用的，其不再依赖像素本身，而是和屏幕密度相关。</p>
<p><strong>在Android当中规定：在屏幕密度为“160dpi”的情况下，则刚好“1dp = 1px”。</strong></p>
<p>注：当屏幕密度为“320dpi”时，则“1dp = 2px”，以此类推…….</p>
<p>也正是因此，让我们得以保证了：控件在不同密度的屏幕上显示一致，既完成屏幕适配。</p>
<p>使用场景：</p>
<p>让我们回到上面说到的使用px造成的控件显示问题，此时我们将使用新的单位“dp”。于是：</p>
<p>在分辨率320x480（既dpi为160）的设备下，则160dp等价于160px，按钮占屏幕宽的一半。<br>在分辨率640x960（既dpi为320）的设备下，则160dp等价于320px，按钮依然占屏幕宽的一半。</p>
<h4 id="Density："><a href="#Density：" class="headerlink" title="Density："></a><strong>Density：</strong></h4><p>就这个单词本身直接翻译的意思而言，其也代表“密度”。但需要注意的是，在Android中，其实并非如此。<br>注意我们这里指的是，通过代码“context.getResources().getDisplayMetrics().density”获取的“density”值。<br>而<strong>通过该方法获取到的该值，实际上是等价于“dpi / 160”的一个结果值</strong>。也就是说：<br><strong>“getResources().getDisplayMetrics().density” = “getResources().getDisplayMetrics().densityDpi / 160”</strong></p>
<p>看到这样一个解析，聪明的人大概已经能预见什么了。我们似乎发现了某种关联：<br>在Android里：“dpi = 160，则1dp = 1px”、“dpi = 320，则1dp = 2px”。以此类推。<br>到此你已经发现，dp，px与160之间存在着某种规律：“1dp = (dpi / 160)px”<br>换算一下，最终得到公式: <strong>dp = density * px</strong> 。</p>
<p>到了这里我们明白了，其实Android提供的该值，也就是为了让我们在dp与px之间做转换。<br>归根结底，其目的还是为了帮助我们做屏幕适配。</p>
<p>使用场景：<br>虽然使用dp在xml文件中定义控件尺寸，能够很好的帮助我们完成适配。<br>但很多时候，我们也会需要在Java代码中动态的去设定控件的尺寸。</p>
<p><strong>但由于在代码中的尺寸设定，基本都被默认为了px单位。</strong><br>所以这个时候就可以借助“density”来帮我们完成dp与px的转换，从而完成适配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dip2px</span><span class="params">(Context context, <span class="keyword">float</span> dipValue)</span></span>&#123; </span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> scale = context.getResources().getDisplayMetrics().density; </span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">int</span>)(dipValue * scale + <span class="number">0.5f</span>); </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​        </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">px2dip</span><span class="params">(Context context, <span class="keyword">float</span> pxValue)</span></span>&#123; </span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> scale = context.getResources().getDisplayMetrics().density; </span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)(pxValue / scale + <span class="number">0.5f</span>); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>原文链接：<a href="https://blog.csdn.net/ghost_Programmer/article/details/50042805" target="_blank" rel="external">https://blog.csdn.net/ghost_Programmer/article/details/50042805</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;PX-pixel&quot;&gt;&lt;a href=&quot;#PX-pixel&quot; class=&quot;headerlink&quot; title=&quot;PX(pixel):&quot;&gt;&lt;/a&gt;&lt;strong&gt;PX(pixel):&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;即传统计算机语言中描述的像素，在Android则代表绝对像素。&lt;/p&gt;
&lt;p&gt;之所以Android中不推荐使用这种单位，正是因为不同生产厂商，不同品牌，不同屏幕的设备，其分辨率亦不一。&lt;/p&gt;
&lt;p&gt;举例来说，我们现在将某个Button的width设为160px，则会出现如下情况：&lt;/p&gt;
&lt;p&gt;在分辨率为“320宽”的设备里，该按钮显示占屏幕宽度一半；&lt;/p&gt;
&lt;p&gt;在分辨率为“640宽”的设备里，该按钮显示占屏幕宽度的四分之一；&lt;/p&gt;
    
    </summary>
    
      <category term="知识总结" scheme="http://qiracle.github.io/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Android" scheme="http://qiracle.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio 配置 JNI</title>
    <link href="http://qiracle.github.io/2019/08/24/20190824/"/>
    <id>http://qiracle.github.io/2019/08/24/20190824/</id>
    <published>2019-08-23T16:00:00.000Z</published>
    <updated>2019-11-02T07:19:46.862Z</updated>
    
    <content type="html"><![CDATA[<p>JNI 是java 语言调用C/C++函数的接口。与JNI相关的开发工具包是NDK。下面记录Android Studio 里用 java代码调用 JNI的基本过程。当前环境：</p>
<p>Android Studio：3.1.2. </p>
<p>NDK：20.0.5<a id="more"></a></p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>下载NDK:</p>
<p><img src="http://qiracle.cn/img/20190824/2019082400.png" alt=""></p>
<p>###1.创建Java类</p>
<p>定义一个工具类，里面定义了native方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.qiracle.jnidemo.jni;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JniUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">                System.loadLibrary(<span class="string">"JniLib"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">getJniString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://qiracle.cn/img/20190824/2019082401.png" alt=""></p>
<h3 id="2-创建JNI文件夹"><a href="#2-创建JNI文件夹" class="headerlink" title="2.创建JNI文件夹"></a>2.创建JNI文件夹</h3><p>在main文件夹下创建jni文件夹：</p>
<p><img src="http://qiracle.cn/img/20190824/2019082402.png" alt=""></p>
<h3 id="3-生成头文件"><a href="#3-生成头文件" class="headerlink" title="3.生成头文件"></a>3.生成头文件</h3><p>两种方式：</p>
<p>1.通过命令行</p>
<p>javac JniUtils.java 编译生成 JniUtils.class文件。然后回退到包外目录javah -jni  cn.qiracle.jnidemo.jni.JniUtils。将生成的.h文件移动到main下的jni目录下。</p>
<p>2.配置外部工具</p>
<p>点击<code>File - Setting - Tools - External Tools</code> 打开外部工具配置页，点击 <code>+</code> 新建一个工具。</p>
<p><img src="http://qiracle.cn/img/20190824/2019082403.png" alt=""></p>
<p>Program: <code>$JDKPath$\bin\javah.exe</code> </p>
<p>Arguments: <code>-classpath . -jni -d $ModuleFileDir$\src\main\jni $FileClass$</code> </p>
<p>Working directory: <code>$ModuleFileDir$\src\main\Java</code></p>
<p>点击 <code>OK</code> 保存后就新建了一个工具。此时我们右击 <code>JniUtils.java</code>，在菜单中选择 <code>External Tools - javah</code> 就可以快速生成头文件并放到 jni 目录。</p>
<p><img src="http://qiracle.cn/img/20190824/2019082405.png" alt=""></p>
<h3 id="4-编写C代码"><a href="#4-编写C代码" class="headerlink" title="4.编写C代码"></a>4.编写C代码</h3><p>在jni目录下新建一个cn_qiracle_jnidemo_jni_JniUtils.cpp文件。内容如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"cn_qiracle_jnidemo_jni_JniUtils.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">Java_cn_qiracle_jnidemo_jni_JniUtils_getJniString</span></span><br><span class="line"><span class="params">(JNIEnv *env,jclass jobj)</span> </span>&#123;</span><br><span class="line"><span class="comment">//new 一个字符串，返回Hello World</span></span><br><span class="line"><span class="keyword">return</span> (*env).NewStringUTF(<span class="string">"Hello jni"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里输出 hello jni</p>
<h3 id="5-创建mk文件"><a href="#5-创建mk文件" class="headerlink" title="5.创建mk文件"></a>5.创建mk文件</h3><p>mk 文件用于告诉 ndk-build 该如何编译 c 源码。详情见<a href="https://developer.android.com/ndk/guides/build" target="_blank" rel="external">官方指南</a>。</p>
<p>在jni目录下创建Android.mk:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := $(call my-dir)</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE := JniLib</span><br><span class="line">LOCAL_SRC_FILES =: cn_qiracle_jnidemo_jni_JniUtils.cpp</span><br><span class="line">include $(BUILD_SHARED_LIBRARY)</span><br></pre></td></tr></table></figure>
<p>创建 <code>Application.mk</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">APP_MODULES := JniLib</span><br><span class="line">APP_ABI := all</span><br></pre></td></tr></table></figure>
<h3 id="6-gradle配置"><a href="#6-gradle配置" class="headerlink" title="6.gradle配置"></a>6.gradle配置</h3><p>在 module 的 build.gradle 里，<code>amndroid.defaultConfig</code> 下加入下面配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ndk &#123;</span><br><span class="line">           moduleName &quot;JniLib&quot;</span><br><span class="line">       &#125;</span><br><span class="line">       sourceSets.main&#123;</span><br><span class="line">           jni.srcDirs = []</span><br><span class="line">           jniLibs.srcDir &quot;src/main/libs&quot;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-编译"><a href="#6-编译" class="headerlink" title="6.编译"></a>6.编译</h3><p>这里我们配置使用外部工具：</p>
<p><img src="http://qiracle.cn/img/20190824/2019082404.png" alt=""></p>
<ul>
<li>Program: <code>D:\SDK\ndk-bundle\build\ndk-build.cmd</code> （注意这里是ndk-build路径）</li>
<li>Working directory: <code>$ProjectFileDir$\app\src\main</code></li>
</ul>
<p>任意找个第地方右击，选择 <code>External Tools - ndk-build</code> 即可编译 c 源码。成功后可以看见创建了 <code>libs</code> 目录，里面包含了不同平台下的 so 文件。</p>
<p><img src="http://qiracle.cn/img/20190824/2019082406.png" alt=""></p>
<h3 id="7-验证"><a href="#7-验证" class="headerlink" title="7.验证"></a>7.验证</h3><p>在MainActivity.java里调用native方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Toast.makeText(this,JniUtils.getJniString(),Toast.LENGTH_SHORT).show();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://qiracle.cn/img/20190824/2019082407.png" alt=""></p>
<p>参考：</p>
<p><a href="https://www.jianshu.com/p/09ff3300f453" target="_blank" rel="external">https://www.jianshu.com/p/09ff3300f453</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JNI 是java 语言调用C/C++函数的接口。与JNI相关的开发工具包是NDK。下面记录Android Studio 里用 java代码调用 JNI的基本过程。当前环境：&lt;/p&gt;
&lt;p&gt;Android Studio：3.1.2. &lt;/p&gt;
&lt;p&gt;NDK：20.0.5
    
    </summary>
    
      <category term="知识总结" scheme="http://qiracle.github.io/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Android" scheme="http://qiracle.github.io/tags/Android/"/>
    
      <category term="JNI" scheme="http://qiracle.github.io/tags/JNI/"/>
    
  </entry>
  
  <entry>
    <title>Android AIDL的基本用法</title>
    <link href="http://qiracle.github.io/2019/08/10/20190810/"/>
    <id>http://qiracle.github.io/2019/08/10/20190810/</id>
    <published>2019-08-09T16:00:00.000Z</published>
    <updated>2019-10-26T07:23:58.201Z</updated>
    
    <content type="html"><![CDATA[<p>AIDL 是 Android 中实现跨进程通信的一种方式。下面是一个简单的实现案例，通过 AIDL 实现客户端调用服务端的接口， 实现跨进程通信。<a id="more"></a></p>
<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>首先，创建一个服务端工程 AIDLServer。main下面创建aidl文件夹，然后在aidl文件夹下创建包和aidl文件，如下：</p>
<p><img src="http://qiracle.cn/img/20190810/2019081001.png" alt=""></p>
<p>IMyAidlInterface.aidl 文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// IMyAidlInterface.aidl</span><br><span class="line">package cn.qiracle.aidlserver;</span><br><span class="line"></span><br><span class="line">// Declare any non-default types here with import statements</span><br><span class="line"></span><br><span class="line">interface IMyAidlInterface &#123;</span><br><span class="line">     void print();</span><br><span class="line">     int add(int a, int b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里定义了AIDL接口IMyAidlInterface，接口里定义了两个待实现的方法。然后 重新构建下工程，这样在build目录下就会生成IMyAidlInterface.java 文件。</p>
<p>接着定义一个Service，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.qiracle.aidlserver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Service;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBinder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyBinder</span> <span class="keyword">extends</span> <span class="title">IMyAidlInterface</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            Log.i(<span class="string">"qiracle"</span>, <span class="string">"my aidl test"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            Log.i(<span class="string">"qiracle"</span>, <span class="string">"a + b:"</span> + (a + b));</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个Service里 ，内部类MyBinder继承IMyAidlInterface.Stub ，然后实现接口里待实现的方法。这两个方法就是提供给客户端进行调用的。</p>
<p>最后，清单文件里记得注册下服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;service</span><br><span class="line">    android:name=&quot;.MyService&quot;</span><br><span class="line">    android:enabled=&quot;true&quot;</span><br><span class="line">    android:exported=&quot;true&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;cn.qiracle.aidlservice&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure>
<p>然后启动服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(<span class="string">"cn.qiracle.aidlservice"</span>);</span><br><span class="line">intent.setPackage(<span class="string">"cn.qiracle.aidlserver"</span>);</span><br><span class="line">startService(intent);</span><br></pre></td></tr></table></figure>
<p>以上就是AIDL的服务端简单实现。主要就是定义一个AIDL接口，然后在服务里实现这个接口，提供给客户端调用。下面介绍客户端部分。</p>
<h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><p>先建立一个客户端的工程，跟服务端工程一样，需要在main下建立aidl目录，然后在aidl目录下新建包和aidl文件，这里的包名和aidl文件名必须和服务端保持一致。如下：</p>
<p><img src="http://qiracle.cn/img/20190810/2019081002.png" alt=""></p>
<p>IMyAidlInterface.aidl 的内容也和 服务端的 IMyAidlInterface.aidl 保持一致</p>
<p>然后，在Activity里绑定服务，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(<span class="string">"cn.qiracle.aidlservice"</span>);</span><br><span class="line">intent.setPackage(<span class="string">"cn.qiracle.aidlserver"</span>);</span><br><span class="line"></span><br><span class="line">bindService(intent, <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">        iMyAidlInterface = IMyAidlInterface.Stub.asInterface(service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,BIND_AUTO_CREATE);</span><br></pre></td></tr></table></figure>
<p>可以通过按钮的点击事件，调用服务端的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">    Toast.makeText(getApplicationContext(),<span class="string">"click"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        iMyAidlInterface.print();</span><br><span class="line">        iMyAidlInterface.add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是客户端实现。</p>
<p>开始运行，注意需要先运行服务端，开启Service，然后运行客户端，绑定服务，通过点击按钮，可以看到服务端控制台有日志打印。</p>
<p>以上，我们就通过AIDL实现了跨进程的调用，方法的实现在服务端，方法的调用在客户端。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AIDL 是 Android 中实现跨进程通信的一种方式。下面是一个简单的实现案例，通过 AIDL 实现客户端调用服务端的接口， 实现跨进程通信。
    
    </summary>
    
      <category term="知识总结" scheme="http://qiracle.github.io/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Android" scheme="http://qiracle.github.io/tags/Android/"/>
    
      <category term="AIDL" scheme="http://qiracle.github.io/tags/AIDL/"/>
    
  </entry>
  
  <entry>
    <title>Android 知识点总结（一）</title>
    <link href="http://qiracle.github.io/2019/08/03/20190803/"/>
    <id>http://qiracle.github.io/2019/08/03/20190803/</id>
    <published>2019-08-02T16:00:00.000Z</published>
    <updated>2019-08-03T07:19:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><ol>
<li><p>Handler 的回调方法是在 Looper.loop()所调用的线程进行的；</p>
</li>
<li><p>Handler 的创建需要先调用 Looper.prepare() ，然后再手动调用 loop()方法开启循环；</p>
</li>
<li><p>App 启动时会在ActivityThread.main()方法中创建主线程的 Looper ,并开启循环，所以主线程使用 Handler 不用调用第2点的逻辑；<a id="more"></a></p>
</li>
<li><p>延时消息并不会阻塞消息队列；</p>
</li>
<li><p>异步消息不会马上执行，插入队列的方式跟同步消息一样，唯一的区别是当有消息屏障时，异步消息可以继续执行，同步消息则不行；</p>
</li>
<li><p>Callback.handleMessage() 的优先级比 Handler.handleMessage()要高*</p>
</li>
<li><p>Handler.post(Runnable)传递的 Runnale 对象并不会在新的线程执行；</p>
</li>
<li><p>Message 的创建推荐使用 Message.obtain() 来获取，内部采用缓存消息池实现；</p>
</li>
<li><p>不要在 handleMessage()中对消息进行异步处理；</p>
</li>
<li><p>可以通过removeCallbacksAndMessages(null)或者静态类加弱引用的方式防止内存泄漏；</p>
</li>
<li><p>Looper.loop()不会造成应用卡死，里面使用了 Linux 的 epoll 机制。</p>
</li>
</ol>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>源码中的注释是这么来解释Context的：Context提供了关于应用环境全局信息的接口。<strong>它是一个抽象类，它的执行被Android系统所提供</strong>。它允许获取以应用为特征的资源和类型，是一个统领一些资源（应用程序环境变量等）的上下文。就是说，它描述一个应用程序环境的信息（即上下文）；是一个抽象类，Android提供了该抽象类的具体实现类；通过它我们可以获取应用程序的资源和类（包括应用级别操作，如启动Activity，发广播，接受Intent等）。既然上面Context是一个抽象类，那么肯定有他的实现类咯，我们在Context的源码中通过IDE可以查看到他的子类最终可以得到如下关系图：</p>
<p><img src="http://94.191.72.22/blog/image/20190803/2019080301.png" alt=""></p>
<p>Context类本身是一个纯abstract类，它有两个具体的实现子类：ContextImpl和ContextWrapper。其中ContextWrapper类，如其名所言，这只是一个包装而已，ContextWrapper构造函数中必须包含一个真正的Context引用，同时ContextWrapper中提供了attachBaseContext（）用于给ContextWrapper对象中指定真正的Context对象，调用ContextWrapper的方法都会被转向其所包含的真正的Context对象。ContextThemeWrapper类，如其名所言，其内部包含了与主题（Theme）相关的接口，这里所说的主题就是指在AndroidManifest.xml中通过android：theme为Application元素或者Activity元素指定的主题。当然，只有Activity才需要主题，Service是不需要主题的，因为Service是没有界面的后台场景，所以Service直接继承于ContextWrapper，Application同理。而ContextImpl类则真正实现了Context中的所以函数，应用程序中所调用的各种Context类的方法，其实现均来自于该类。一句话总结：<strong>Context的两个子类分工明确，其中ContextImpl是Context的具体实现类，ContextWrapper是Context的包装类。Activity，Application，Service虽都继承自ContextWrapper（Activity继承自ContextWrapper的子类ContextThemeWrapper），但它们初始化的过程中都会创建ContextImpl对象，由ContextImpl实现Context中的方法。</strong></p>
<p><strong>一个应用程序有几个Context？</strong></p>
<p>实这个问题本身并没有什么意义，关键还是在于对Context的理解，从上面的关系图我们已经可以得出答案了，在应用程序中Context的具体实现子类就是：Activity，Service，Application。<strong>那么Context数量=Activity数量+Service数量+1</strong>。当然如果你足够细心，可能会有疑问：我们常说四大组件，这里怎么只有Activity，Service持有Context，那Broadcast Receiver，Content Provider呢？Broadcast Receiver，Content Provider并不是Context的子类，他们所持有的Context都是其他地方传过去的，所以并不计入Context总数。上面的关系图也从另外一个侧面告诉我们Context类在整个Android系统中的地位是多么的崇高，因为很显然Activity，Service，Application都是其子类，其地位和作用不言而喻。</p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p><strong>Activity</strong></p>
<p>Activity并不负责视图控制，它只是控制生命周期和处理事件。真正控制视图的是Window。一个Activity包含了一个Window，Window才是真正代表一个窗口。<strong>Activity就像一个控制器，统筹视图的添加与显示，以及通过其他回调方法，来与Window、以及View进行交互。</strong></p>
<p><strong>Window</strong></p>
<p>Window是视图的承载器，内部持有一个 DecorView，而这个DecorView才是 view 的根布局。<strong>Window是一个抽象类，实际在Activity中持有的是其子类PhoneWindow。PhoneWindow中有个内部类DecorView，通过创建DecorView来加载Activity中设置的布局R.layout.activity_main</strong>。Window 通过WindowManager将DecorView加载其中，并将DecorView交给ViewRoot，进行视图绘制以及其他交互。</p>
<p><strong>DecorView</strong></p>
<p>DecorView是FrameLayout的子类，它可以被认为是Android视图树的根节点视图。DecorView作为顶级View，一般情况下它内部包含一个竖直方向的LinearLayout，<strong>在这个LinearLayout里面有上下三个部分，上面是个ViewStub，延迟加载的视图（应该是设置ActionBar，根据Theme设置），中间的是标题栏(根据Theme设置，有的布局没有)，下面的是内容栏。</strong></p>
<p><strong>ViewRoot</strong></p>
<p>ViewRoot可能比较陌生，但是其作用非常重大。所有View的绘制以及事件分发等交互都是通过它来执行或传递的。</p>
<p><strong>ViewRoot对应ViewRootImpl类，它是连接WindowManagerService和DecorView的纽带，View的三大流程（测量（measure），布局（layout），绘制（draw））均通过ViewRoot来完成。</strong></p>
<p>ViewRoot并不属于View树的一份子。从源码实现上来看，它既非View的子类，也非View的父类，但是，它实现了ViewParent接口，这让它可以作为View的名义上的父视图。RootView继承了Handler类，可以接收事件并分发，Android的所有触屏事件、按键事件、界面刷新等事件都是通过ViewRoot进行分发的。</p>
<p><img src="http://94.191.72.22/blog/image/20190803/2019080302.png" alt=""></p>
<p>要知道，当用户点击屏幕产生一个触摸行为，这个触摸行为则是通过底层硬件来传递捕获，然后交给ViewRootImpl，接着将事件传递给DecorView，而DecorView再交给PhoneWindow，PhoneWindow再交给Activity，然后接下来就是我们常见的View事件分发了。</p>
<p><strong>硬件 -&gt; ViewRootImpl -&gt; DecorView -&gt; PhoneWindow -&gt; Activity</strong></p>
<p><strong>通过以上了解可以知道，Activity就像个控制器，不负责视图部分。Window像个承载器，装着内部视图。DecorView就是个顶层视图，是所有View的最外层布局。ViewRoot像个连接器，负责沟通，通过硬件的感知来通知视图，进行用户之间的交互。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Handler&quot;&gt;&lt;a href=&quot;#Handler&quot; class=&quot;headerlink&quot; title=&quot;Handler&quot;&gt;&lt;/a&gt;Handler&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Handler 的回调方法是在 Looper.loop()所调用的线程进行的；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Handler 的创建需要先调用 Looper.prepare() ，然后再手动调用 loop()方法开启循环；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;App 启动时会在ActivityThread.main()方法中创建主线程的 Looper ,并开启循环，所以主线程使用 Handler 不用调用第2点的逻辑；
    
    </summary>
    
      <category term="知识总结" scheme="http://qiracle.github.io/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Android" scheme="http://qiracle.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Boardcast 权限的使用</title>
    <link href="http://qiracle.github.io/2019/05/12/20190512/"/>
    <id>http://qiracle.github.io/2019/05/12/20190512/</id>
    <published>2019-05-11T16:00:00.000Z</published>
    <updated>2019-08-03T06:26:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-广播的接收权限"><a href="#1-广播的接收权限" class="headerlink" title="1. 广播的接收权限"></a>1. 广播的接收权限</h3><p>设置广播接收权限的<strong>目的</strong>在于避免自己应用发送的广播被其他恶意应用接收到。简单来说就是定义<strong>谁能接收我的广播</strong>，用法如下：</p>
<p>首先发送方的应用在清单文件里自定义一个权限：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">"cn.qiracle.RECEIVER"</span></span><br><span class="line">    <span class="attr">android:protectionLevel</span>=<span class="string">"signature"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里 protectionLevel 选择 signature 或者 signatureOrSystem 更加安全。<a id="more"></a></p>
<p>然后发送广播时调用如下 sendBoradcast 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static final String PERMISSION_RECEIVER= &quot;cn.qiracle.RECEIVER&quot;;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">sendBroadcast(intent,PERMISSION_RECEIVER);</span><br></pre></td></tr></table></figure>
<p>此时接收方app若是想接收到这个广播，需要在接收方应用的清单文件里添加如下权限：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"cn.qiracle.RECEIVER"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-广播的发送权限"><a href="#2-广播的发送权限" class="headerlink" title="2.广播的发送权限"></a>2.广播的发送权限</h3><p>设置广播的发送权限<strong>目的</strong>在于避免自己的应用里的 receiver 被其他恶意应用发送的带有同样 action 的广播所骚扰。简单来说就是定义<strong>谁能给我发送广播</strong>。用法如下：</p>
<p>首先在接收方应用的清单文件里自定义一个权限：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">"cn.qiracle.SEND"</span></span><br><span class="line">    <span class="attr">android:protectionLevel</span>=<span class="string">"signature"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后注册广播时采用如下regiserReceiver方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PERMISSION_SEND = <span class="string">"cn.qiracle.SEND"</span>;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">registerReceiver(<span class="keyword">new</span> MyReceiver(),intentFilter,PERMISSION_SEND,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>上面是动态注册，静态注册广播方式如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">".receiver.MyReceiver"</span></span><br><span class="line">    <span class="attr">android:permission</span>=<span class="string">"cn.qiracle.SEND"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"cn.qiracle.MYRECEIVER"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>推荐使用动态注册</strong>的方式，因为笔者尝试发现自定义权限时，静态注册的方式在 <strong>Android8.0 </strong>及以上会不起作用。</p>
<p>此时广播的发送方 app 要想给这个应用发送广播，必须在清单文件里添加如下权限：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"cn.qiracle.SEND"</span> /&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-广播的接收权限&quot;&gt;&lt;a href=&quot;#1-广播的接收权限&quot; class=&quot;headerlink&quot; title=&quot;1. 广播的接收权限&quot;&gt;&lt;/a&gt;1. 广播的接收权限&lt;/h3&gt;&lt;p&gt;设置广播接收权限的&lt;strong&gt;目的&lt;/strong&gt;在于避免自己应用发送的广播被其他恶意应用接收到。简单来说就是定义&lt;strong&gt;谁能接收我的广播&lt;/strong&gt;，用法如下：&lt;/p&gt;
&lt;p&gt;首先发送方的应用在清单文件里自定义一个权限：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;permission&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;android:name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;cn.qiracle.RECEIVER&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;android:protectionLevel&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;signature&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里 protectionLevel 选择 signature 或者 signatureOrSystem 更加安全。
    
    </summary>
    
      <category term="知识总结" scheme="http://qiracle.github.io/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Android" scheme="http://qiracle.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>读《深入理解Java虚拟机》总结&lt;二.java内存模型与线程&gt;</title>
    <link href="http://qiracle.github.io/2019/02/17/20190217/"/>
    <id>http://qiracle.github.io/2019/02/17/20190217/</id>
    <published>2019-02-16T16:00:00.000Z</published>
    <updated>2019-10-26T07:23:24.173Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p>java内存模型规定了所有变量都存储在主内存中。<strong>此处的变量是指实例字段，静态字段和构成数组对象的元素。但不包括局部变量与方法参数</strong>。因为后者是线程私有的，不会被共享。除主内存之外，每个线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取，赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间也无法之间访问对方工作内存中的变量。线程间变量值得传递均需要通过主内存来完成。 <a id="more"></a></p>
<p>一个变量如何从主内存拷贝到工作内存，如何从工作内存同步回主内存之类的实现细节，java内存模型定义了以下八种操作来完成:</p>
<ul>
<li>lock(锁定)：作用于主内存的变量，把一个变量标记为一条线程独占状态</li>
<li>unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li>
<li>read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
<li>load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中</li>
<li>use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行<a href="https://www.baidu.com/s?wd=%E5%BC%95%E6%93%8E&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="external">引擎</a></li>
<li>assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量</li>
<li>store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作</li>
<li>write(写入)：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中</li>
</ul>
<p><img src="http://qiracle.cn/img/20190217/1.png" alt="java内存模型" title="java内存模型"></p>
<h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h3><p>用于修饰变量。主要作用有两个：</p>
<p>1.保证修改的可见性</p>
<p>2.禁止指令重排序</p>
<p>volatile不保证操作的原子性</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;主内存与工作内存&quot;&gt;&lt;a href=&quot;#主内存与工作内存&quot; class=&quot;headerlink&quot; title=&quot;主内存与工作内存&quot;&gt;&lt;/a&gt;主内存与工作内存&lt;/h3&gt;&lt;p&gt;java内存模型规定了所有变量都存储在主内存中。&lt;strong&gt;此处的变量是指实例字段，静态字段和构成数组对象的元素。但不包括局部变量与方法参数&lt;/strong&gt;。因为后者是线程私有的，不会被共享。除主内存之外，每个线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取，赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间也无法之间访问对方工作内存中的变量。线程间变量值得传递均需要通过主内存来完成。
    
    </summary>
    
      <category term="总结" scheme="http://qiracle.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="java" scheme="http://qiracle.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>读《深入理解Java虚拟机》总结&lt;一自动内存管理机制&gt;</title>
    <link href="http://qiracle.github.io/2019/02/16/20190216/"/>
    <id>http://qiracle.github.io/2019/02/16/20190216/</id>
    <published>2019-02-15T16:00:00.000Z</published>
    <updated>2019-10-26T07:22:44.232Z</updated>
    
    <content type="html"><![CDATA[<p>这一周来比较空闲，读了《深入理解java虚拟机一书》以提高自己对java底层的认知，还没看完，只是挑选了书中自己比较感兴趣的两个章节来看，写下此篇博客一是为了总结，二是为了方便今后回顾。下面是第一部分<strong>自动内存管理机制</strong> <a id="more"></a></p>
<h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p><img src="http://qiracle.cn/img/20190216/1.png" alt="java内存" title="java内存"></p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器时一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。为了线程切换后能够恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程直接的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<h4 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h4><p>与程序计数器一样，java虚拟机栈也是线程私有的，它的生命周期与线程相同。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackoverflowError异常；如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。</p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行java方法服务，而本地方法栈则是为虚拟机使用到的Native方法服务。。本地方法栈也会抛出StackoverflowError和OutOfMemoryError异常。</p>
<h4 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h4><p>对于大多数应用来说，java堆是java虚拟机所管理的内存中最大的一块。java堆是所以线程共享的一块内存区域，在虚拟机启动时创建。java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存完成实例分配，并且堆无法再扩展时，将会抛出OutOfMemoryError异常。</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区与java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。垃圾回收行为在这个区域是比较少出现的，这个区域内存回收目标主要是针对常量池的回收和对类型的卸载。。当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池时方法区的一部分。Class文件除了有类的版本，字段，方法，接口等描述信息外，还有一项信息就是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区运行时常量池中。运行期间也可能将新的常量放入池中，如String类的intern()方法。</p>
<h3 id="确定对象是否存活的算法"><a href="#确定对象是否存活的算法" class="headerlink" title="确定对象是否存活的算法"></a>确定对象是否存活的算法</h3><p>垃圾回收器在对堆进行回收前，第一件事情就是要确定这些对象有哪些还存活着，哪些已经死去。</p>
<h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>给对象中添加一个引用计算器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。。</p>
<p>java语言没有选用引用计数法来管理内存，其中最主要的原因是它很难解决对象之间的相互循环引用的问题。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReferenceCountGC objA = new ReferenceCountGC();</span><br><span class="line">ReferenceCountGC objB = new ReferenceCountGC();</span><br><span class="line">objA.instance = objB;</span><br><span class="line">objB.instance = objA;</span><br><span class="line">objA = null;</span><br><span class="line">objB = null;</span><br></pre></td></tr></table></figure>
<h4 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h4><p>在主流的商用程序语言中，都是使用根搜索算法判断对象是否存活的。基本思路是通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象待GC Roots没有任何引用链相连，则证明此对象是不可用的。</p>
<p>Java语言里，可作为GC Roots对象包括下面几种：</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区中的类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI的引用对象</li>
</ul>
<h3 id="java中的四种引用"><a href="#java中的四种引用" class="headerlink" title="java中的四种引用"></a>java中的四种引用</h3><p><strong>强引用：</strong>代码至中普遍存在。类似 Object obj  = new Object()。主要强引用还在，垃圾回收器永远不会回收掉被引用的对象。</p>
<p><strong>软引用：</strong>当内存不够时，即系统将要发生内存溢出异常之前，将会把这些对象列进回收范围并进行二次回收。java中提供SoftReference类实现软引用。</p>
<p><strong>弱引用：</strong>被弱引用关联的对象只能生存到下次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够，都会回收掉被弱引用关联的对象。java中提供WeakReference类实现软引用。</p>
<p><strong>虚引用</strong>：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望这个对象在被收集器回收时收到一个系统通知。java中提供PhantomReference类实现软引用。</p>
<h3 id="对象死亡过程"><a href="#对象死亡过程" class="headerlink" title="对象死亡过程"></a>对象死亡过程</h3><p>在跟搜索算法中不可达的对象也并非是非死不可的。这些不可达的对象先会被判断是否有必要执行finalize()方法，<strong>当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过</strong>，虚拟机会将这两种情况都视为“没有必要执行”。</p>
<p>finalize()方法是对象逃脱死亡命运的最后一次机会，如果对象想要在finalize()方法中成功拯救自己，只要重新与引用链上的任何一个对象建立关联即可。譬如把自己(this)赋值给某个类变量或者某个对象的成员变量。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGc</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGc Save_HooK = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalized</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.finalized();</span><br><span class="line">    FinalizeEscapeGc.Save_HooK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会再次被执行。</strong></p>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a><strong>标记-清除算法</strong></h4><p>首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。它的主要缺点有两个:</p>
<p>一是效率问题，标记和清楚过程效率都不高</p>
<p>二是空间问题，标记清除后会产生大量不连续的内存碎片。</p>
<p><img src="http://qiracle.cn/img/20190216/2.png" alt="标记-清除" title="标记-清除"></p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a><strong>复制算法</strong></h4><p>它将可用内存按容量划分为大小相同的两块，每次只使用其中的一块，当一块内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。这种算法的代价是将内存缩小为原来的一半未免太高了一些。</p>
<p><img src="http://qiracle.cn/img/20190216/3.png" alt="复制" title="复制"></p>
<p>现在的商用虚拟机都采用这种收集算法来回收新生代，IBM的专门研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1:1的比例来划分空间。而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活的对象一次性拷贝到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例为8:1。当Survivor空间不够时，需要依赖其他内存（老年代）进行分配担保。</p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a><strong>标记-整理算法</strong></h4><p>复制算法在对象存活率较高时需要执行较多的复制操作，更关键是如果不想浪费50%空间，就需要额外的空间进行担保，以应对内存中所有对象都100%存活的极端情况，所以老年代一般不能直接选用这种算法。</p>
<p>标记-整理算法的标记过程仍然与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><img src="http://qiracle.cn/img/20190216/4.png" alt="标记-整理" title="标记-整理"></p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a><strong>分代收集算法</strong></h4><p>根据对象的存活周期不同将内存划分为几块，一般是把Java堆分为新生代和老年代。在新生代中，每次垃圾收集时发现大批对象死去，只有少量存活，那就选用复制算法。老年代中因为对象存活率高，没有额外空间对它进行分配担保，就必须使用“标记-清理”，“标记-整理”算法来进行回收。</p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><img src="http://qiracle.cn/img/20190216/5.png" alt="垃圾收集器" title="垃圾收集器"></p>
<p>如果两个收集器之间存在连线，就说明他们可以搭配使用。下面就只说下Serial收集器：</p>
<h5 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h5><p>Serial收集器是最基本，历史最悠久的收集器，这是一个单线程的收集器。它在进行垃圾收集时，必须暂停其他所有工作线程指到它收集结束。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一周来比较空闲，读了《深入理解java虚拟机一书》以提高自己对java底层的认知，还没看完，只是挑选了书中自己比较感兴趣的两个章节来看，写下此篇博客一是为了总结，二是为了方便今后回顾。下面是第一部分&lt;strong&gt;自动内存管理机制&lt;/strong&gt;
    
    </summary>
    
      <category term="总结" scheme="http://qiracle.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="java" scheme="http://qiracle.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>CentOS下编译Hadoop</title>
    <link href="http://qiracle.github.io/2019/01/06/20190106/"/>
    <id>http://qiracle.github.io/2019/01/06/20190106/</id>
    <published>2019-01-05T16:00:00.000Z</published>
    <updated>2019-01-20T11:55:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="系统及软件版本准备"><a href="#系统及软件版本准备" class="headerlink" title="系统及软件版本准备"></a>系统及软件版本准备</h3><p>CentOS-6.7-64bit</p>
<p>Hadoop-2.8.3-src</p>
<p>java-1.8.0_141</p>
<p>apache-maven-3.3.9</p>
<p>protobuf-2.5.0</p>
<p>findbugs-1.3.9 <a id="more"></a></p>
<p>相关软件下载地址： 链接：<a href="https://pan.baidu.com/s/1FfRRPiosrhWpRIPYtcsEgg" target="_blank" rel="external">https://pan.baidu.com/s/1FfRRPiosrhWpRIPYtcsEgg</a><br>提取码：l84n </p>
<h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><h3 id="1-java-1-8-0-141"><a href="#1-java-1-8-0-141" class="headerlink" title="1.java-1.8.0_141"></a>1.java-1.8.0_141</h3><p>下载 jdk-8u141-linux-x64.tar.gz， 解压到 /root/apps/jdk1.8.0_141。解压命令:</p>
<p><code>tar -xf jdk-8u141-linux-x64.tar.gz</code></p>
<p>配置环境变量：</p>
<p><code>vi  /etc/profile</code></p>
<p>在文件最下面加上:</p>
<p><code>export JAVA_HOME=/root/apps/jdk1.8.0_141</code><br><code>export PATH=$PATH:$JAVA_HOME/bin</code><br><code>export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</code></p>
<p>添加完记得用下面的命令让其立即生效:</p>
<p><code>source /etc/profile</code></p>
<p><strong>注意：下面每次配置完环境变量都需要使用这个命令</strong></p>
<p>检查是否安装成功:</p>
<p><code>java -version</code></p>
<p>如果输出下面信息，则表示安装成功：</p>
<blockquote>
<p>java version “1.8.0_141”<br>Java(TM) SE Runtime Environment (build 1.8.0_141-b15)<br>Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode)</p>
</blockquote>
<h3 id="2-apache-maven-3-3-9"><a href="#2-apache-maven-3-3-9" class="headerlink" title="2.apache-maven-3.3.9"></a>2.apache-maven-3.3.9</h3><p>下载apache-maven-3.3.9-bin.zip，并使用 下面命令解压：</p>
<p><code>unzip apache-maven-3.3.9-bin.zip</code></p>
<p>我将其解压到了 /opt/software/a:pache-maven-3.3.9. 同样，配置环境变量，在/etc/profile中添加下面信息：</p>
<p><code>export MAVEN_HOME=/opt/software/apache-maven-3.3.9</code><br><code>export MAVEN_OPTS=&quot;-Xms256m -Xmx512m&quot;</code><br><code>export PATH=$MAVEN_HOME/bin:$JAVA_HOME/bin:$PATH</code></p>
<p>验证是否安装成功:</p>
<p><code>mvn -version</code></p>
<p>出现下列信息表明安装成功：</p>
<blockquote>
<p>Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)<br>Maven home: /opt/software/apache-maven-3.3.9<br>Java version: 1.8.0_141, vendor: Oracle Corporation<br>Java home: /root/apps/jdk1.8.0_141/jre<br>Default locale: en_US, platform encoding: UTF-8<br>OS name: “linux”, version: “2.6.32-573.el6.x86_64”, arch: “amd64”, family: “unix”</p>
</blockquote>
<h3 id="3-protobuf-2-5-0"><a href="#3-protobuf-2-5-0" class="headerlink" title="3.protobuf-2.5.0"></a>3.protobuf-2.5.0</h3><p>下载 protobuf-2.5.0.tar.gz ，解压到/opt/software/protobuf-2.5.0，接下来:</p>
<p> <code>cd protobuf-2.5.0</code></p>
<p><code>yum install -y gcc gcc-c++ make cmake</code></p>
<p> ./configure –prefix=/usr/local/protobuf</p>
<p> make &amp;&amp; make install</p>
<p>同样导入环境变量：</p>
<p><code>export PROTOC_HOME=/usr/local/protobuf</code><br><code>export PATH=$PROTOC_HOME/bin:$FINDBUGS_HOME/bin:$MAVEN_HOME/bin:$JAVA_HOME/bin:$PATH</code></p>
<p>验证是否安装成功：</p>
<p><code>protoc --version</code></p>
<p>出现下面信息表明安装成功：</p>
<blockquote>
<p>libprotoc 2.5.0</p>
</blockquote>
<h3 id="4-findbugs-1-3-9"><a href="#4-findbugs-1-3-9" class="headerlink" title="4. findbugs-1.3.9"></a>4. findbugs-1.3.9</h3><p>下载findbugs-1.3.9.zip ，通过unzip findbugs-1.3.9.zip 解压到/opt/software/findbugs-1.3.9。</p>
<p>同样需要配置环境变量</p>
<p><code>export FINDBUGS_HOME=/opt/software/findbugs-1.3.9</code><br><code>export PATH=$FINDBUGS_HOME/bin:$MAVEN_HOME/bin:$JAVA_HOME/bin:$PATH</code></p>
<p>验证是否安装成功：</p>
<p><code>findbugs -version</code></p>
<p>出现下面信息表示安装成功：</p>
<blockquote>
<p>1.3.9</p>
</blockquote>
<h3 id="5-其他依赖的安装"><a href="#5-其他依赖的安装" class="headerlink" title="5.其他依赖的安装"></a>5.其他依赖的安装</h3><p><code>yum install -y openssl openssl-devel svn ncurses-devel zlib-devel libtool</code><br><code>yum install -y snappy snappy-devel bzip2 bzip2-devel lzo lzo-devel lzop autoconf automake</code></p>
<h3 id="6-编译"><a href="#6-编译" class="headerlink" title="6.编译"></a>6.编译</h3><p>下载hadoop-2.8.3-src.tar.gz并解压 tar -xf hadoop-2.8.3-src.tar.gz 到 /root/hadoop-2.8.3-src。运行下面命令：</p>
<p><code>cd hadoop-2.8.3-src</code></p>
<p><code>mvn clean package -Pdist,native -DskipTests -Dtar</code></p>
<p>编译过程中需要下载很多东西，需要很长时间，同时因为网络原因可能会一直卡在某个地方，这时可以ctrl+c中止然后重新运行上面命令。最后如果出现 BUILD SUCCESS 字样则表明编译成功.</p>
<p>编译好的tar包在 /root/hadoop-2.8.3-src/hadoop-dist/target/hadoop-2.8.1.tar.gz下</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;系统及软件版本准备&quot;&gt;&lt;a href=&quot;#系统及软件版本准备&quot; class=&quot;headerlink&quot; title=&quot;系统及软件版本准备&quot;&gt;&lt;/a&gt;系统及软件版本准备&lt;/h3&gt;&lt;p&gt;CentOS-6.7-64bit&lt;/p&gt;
&lt;p&gt;Hadoop-2.8.3-src&lt;/p&gt;
&lt;p&gt;java-1.8.0_141&lt;/p&gt;
&lt;p&gt;apache-maven-3.3.9&lt;/p&gt;
&lt;p&gt;protobuf-2.5.0&lt;/p&gt;
&lt;p&gt;findbugs-1.3.9
    
    </summary>
    
      <category term="教程" scheme="http://qiracle.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="hadoop" scheme="http://qiracle.github.io/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>java IO流总结</title>
    <link href="http://qiracle.github.io/2018/11/28/20181128/"/>
    <id>http://qiracle.github.io/2018/11/28/20181128/</id>
    <published>2018-11-27T16:00:00.000Z</published>
    <updated>2019-10-26T07:22:29.219Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java-IO流简介"><a href="#java-IO流简介" class="headerlink" title="java IO流简介"></a>java IO流简介</h3><p>java IO流可 分为输入流 和 输出流。这里的输入和输出是相对于程序而言的，外部数据输入到程序中时，我们用输入流，程序中的数据输出到外部时，我们用输出流。</p>
<p>输入流又可分为字节输入流和字符输入流。字节输入流的基类为InputStream，我们常用到它的子类FileInputStream, 字符输入流的基类为Reader，我们常用到它的子类FileReader。</p>
<p>输出流又可分为字节输出流和字符输出流。字节输出流的基类为OutputStream，我们常用到它的子类FileOutputStream, 字符输出流的基类为Writer，我们常用到它的子类FileWriter。</p>
<a id="more"></a>
<p><strong>那什么时候该用字节流，什么时候该用字符流呢？</strong></p>
<p>一般来说，在输入输出一些二进制对象的时候比如图片，音乐，视频文件，我们用字节流。 在输入输出一些文本文件的时候比如文字，我们用字符流。字符其实可以理解为是字节+对应的编码表（utf-8,gbk等）构成的，相同的一段字节，用不同的编码格式，最后得到的字符是不一样的（生活常见的乱码就是这样产生的）</p>
<p>另外，java在字节流和字符流中间提供了一层吧转换流，，可以将字节流转化为字符流。输入的转换流为InputStreamReader（InputStream is），输出的转换流为OutputStreamReader（OutputStream os ）。</p>
<p>解释了这么多，不如用一图来总结一下：</p>
<p><img src="http://qiracle.cn/img/20181128/io.bmp" alt="IO流"></p>
<p>　　</p>
<h3 id="IO-流在代码中的实际应用"><a href="#IO-流在代码中的实际应用" class="headerlink" title="IO 流在代码中的实际应用"></a>IO 流在代码中的实际应用</h3><p>java提供了操作IO流的API，在代码中如何使用呢？ 接下来，直接附上几个比较实用的demo，可参考运用到自己的代码里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">public class CopyMp3Demo &#123;</span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		long start = System.currentTimeMillis();</span><br><span class="line">		method1(&quot;e:\\music.mp3&quot;, &quot;copy1.mp3&quot;);</span><br><span class="line">		method2(&quot;e:\\music.mp3&quot;, &quot;copy2.mp3&quot;);</span><br><span class="line">		method3(&quot;e:\\music.mp3&quot;, &quot;copy3.mp3&quot;);</span><br><span class="line">		method4(&quot;e:\\music.mp3&quot;, &quot;copy4.mp3&quot;);</span><br><span class="line"></span><br><span class="line">		long end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot; 总共耗时：&quot; + (end - start) + &quot;毫秒&quot;);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 基本字节流一次读写一个字节</span><br><span class="line">	public static void method1(String src, String dest) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		FileInputStream fis = new FileInputStream(src);</span><br><span class="line">		FileOutputStream fos = new FileOutputStream(dest);</span><br><span class="line"></span><br><span class="line">		int by = 0;</span><br><span class="line">		while ((by = fis.read()) != -1) &#123;</span><br><span class="line">			fos.write(by);</span><br><span class="line">		&#125;</span><br><span class="line">		fis.close();</span><br><span class="line">		fos.close();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 基本字节流一次读写一个字节数组</span><br><span class="line">	public static void method2(String src, String dest) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		FileInputStream fis = new FileInputStream(src);</span><br><span class="line">		FileOutputStream fos = new FileOutputStream(dest);</span><br><span class="line"></span><br><span class="line">		int len = 0;</span><br><span class="line">		byte[] bys = new byte[1024];</span><br><span class="line">		while ((len = fis.read(bys)) != -1) &#123;</span><br><span class="line">			fos.write(bys, 0, len);</span><br><span class="line">		&#125;</span><br><span class="line">		fis.close();</span><br><span class="line">		fos.close();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 高效字节流一次读写一个字节：</span><br><span class="line"></span><br><span class="line">	public static void method3(String src, String dest) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));</span><br><span class="line">		BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dest));</span><br><span class="line"></span><br><span class="line">		int by = 0;</span><br><span class="line">		while ((by = bis.read()) != -1) &#123;</span><br><span class="line">			bos.write(by);</span><br><span class="line">		&#125;</span><br><span class="line">		bis.close();</span><br><span class="line">		bos.close();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 高效字节流一次读写一个字节数组：</span><br><span class="line"></span><br><span class="line">	public static void method4(String src, String dest) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));</span><br><span class="line">		BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dest));</span><br><span class="line"></span><br><span class="line">		int len = 0;</span><br><span class="line">		byte[] bys = new byte[1024];</span><br><span class="line">		while ((len = bis.read(bys)) != -1) &#123;</span><br><span class="line">			bos.write(bys, 0, len);</span><br><span class="line">		&#125;</span><br><span class="line">		bis.close();</span><br><span class="line">		bos.close();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们的目的是利用IO流将E盘根目录下的music.mp3文件拷贝到项目工程目录下，前面说了，拷贝音乐文件用字节流，这里提供了四种拷贝方式，可以比较拷贝所需时间，其中第一种方式(基本字节流一次读写一个字节 )最慢，第四种（高效字节流一次读写一个字节数组）最快，中间两种差不多。</p>
<p>说一下这里的BufferedInputStream是输入流（对应的输出流BufferedOutputStream）的缓冲流，又称装饰流，一般我们建议在基本流外面包上装饰流，因为这样可极大提升效率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">//字符流读写数据的五种方式</span><br><span class="line">public class CopyTxtDemo &#123;</span><br><span class="line">	public static void main(String[] args) throws IOException &#123;</span><br><span class="line">		String SrcString = &quot;a.txt&quot;;</span><br><span class="line">		String DestString = &quot;b.txt&quot;;</span><br><span class="line">		// method1(SrcString,DestString);</span><br><span class="line">		// method3(SrcString,DestString);</span><br><span class="line">		// method4(SrcString,DestString);</span><br><span class="line">		method5(SrcString, DestString);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 基本字符流一次读写一个字符</span><br><span class="line">	private static void method1(String srcString, String destString) throws IOException &#123;</span><br><span class="line">		FileReader fr = new FileReader(srcString);</span><br><span class="line">		FileWriter fw = new FileWriter(destString);</span><br><span class="line"></span><br><span class="line">		int len = 0;</span><br><span class="line">		while ((len = fr.read()) != -1) &#123;</span><br><span class="line">			fw.write(len);</span><br><span class="line">		&#125;</span><br><span class="line">		fr.close();</span><br><span class="line">		fw.close();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 基本字符流一次读写一个字符数组</span><br><span class="line">	private static void method2(String srcString, String destString) throws IOException &#123;</span><br><span class="line">		FileReader fr = new FileReader(srcString);</span><br><span class="line">		FileWriter fw = new FileWriter(destString);</span><br><span class="line"></span><br><span class="line">		char[] chs = new char[1024];</span><br><span class="line">		int len = 0;</span><br><span class="line">		while ((len = fr.read(chs)) != -1) &#123;</span><br><span class="line">			fw.write(chs, 0, len);</span><br><span class="line">		&#125;</span><br><span class="line">		fr.close();</span><br><span class="line">		fw.close();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 高效字符流一次读写一个字符</span><br><span class="line">	private static void method3(String srcString, String destString) throws IOException &#123;</span><br><span class="line">		BufferedReader br = new BufferedReader(new FileReader(srcString));</span><br><span class="line">		BufferedWriter bw = new BufferedWriter(new FileWriter(destString));</span><br><span class="line"></span><br><span class="line">		int len = 0;</span><br><span class="line">		while ((len = br.read()) != -1) &#123;</span><br><span class="line">			bw.write(len);</span><br><span class="line">		&#125;</span><br><span class="line">		br.close();</span><br><span class="line">		bw.close();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 高效字符流一次读写一个字符数组</span><br><span class="line">	private static void method4(String srcString, String destString) throws IOException &#123;</span><br><span class="line">		BufferedReader br = new BufferedReader(new FileReader(srcString));</span><br><span class="line">		BufferedWriter bw = new BufferedWriter(new FileWriter(destString));</span><br><span class="line"></span><br><span class="line">		char[] chs = new char[1024];</span><br><span class="line">		int len = 0;</span><br><span class="line">		while ((len = br.read(chs)) != -1) &#123;</span><br><span class="line">			bw.write(chs, 0, len);</span><br><span class="line">		&#125;</span><br><span class="line">		br.close();</span><br><span class="line">		bw.close();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 高效字符流一次读写一行</span><br><span class="line">	private static void method5(String srcString, String destString) throws IOException &#123;</span><br><span class="line">		BufferedReader br = new BufferedReader(new FileReader(srcString));</span><br><span class="line">		BufferedWriter bw = new BufferedWriter(new FileWriter(destString));</span><br><span class="line"></span><br><span class="line">		String len = null;</span><br><span class="line">		while ((len = br.readLine()) != null) &#123;</span><br><span class="line">			bw.write(len);</span><br><span class="line">			bw.newLine();</span><br><span class="line">			bw.flush();</span><br><span class="line">		&#125;</span><br><span class="line">		br.close();</span><br><span class="line">		bw.close();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的目的是将项目工程下的“a.txt”文件拷贝到b.txt里。前面说了拷贝文本文件用字符流。前四种拷贝方式就不说了，跟字节流差不多，第五种比较特殊，一次读写一行。</p>
<p><strong>注意：上述代码最好加上try–catch，并在finally里关闭流。如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(String src, String dest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	BufferedInputStream bis =<span class="keyword">null</span>;</span><br><span class="line">	BufferedOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(src));</span><br><span class="line">		bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(dest));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> by = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> ((by = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">			bos.write(by);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">		bos.close();</span><br><span class="line">		bis.close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java-IO流简介&quot;&gt;&lt;a href=&quot;#java-IO流简介&quot; class=&quot;headerlink&quot; title=&quot;java IO流简介&quot;&gt;&lt;/a&gt;java IO流简介&lt;/h3&gt;&lt;p&gt;java IO流可 分为输入流 和 输出流。这里的输入和输出是相对于程序而言的，外部数据输入到程序中时，我们用输入流，程序中的数据输出到外部时，我们用输出流。&lt;/p&gt;
&lt;p&gt;输入流又可分为字节输入流和字符输入流。字节输入流的基类为InputStream，我们常用到它的子类FileInputStream, 字符输入流的基类为Reader，我们常用到它的子类FileReader。&lt;/p&gt;
&lt;p&gt;输出流又可分为字节输出流和字符输出流。字节输出流的基类为OutputStream，我们常用到它的子类FileOutputStream, 字符输出流的基类为Writer，我们常用到它的子类FileWriter。&lt;/p&gt;
    
    </summary>
    
      <category term="知识总结" scheme="http://qiracle.github.io/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="java" scheme="http://qiracle.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Android 中的jar包，aar包以及module</title>
    <link href="http://qiracle.github.io/2018/10/28/20181028/"/>
    <id>http://qiracle.github.io/2018/10/28/20181028/</id>
    <published>2018-10-27T16:00:00.000Z</published>
    <updated>2018-11-25T08:40:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android  Studio中引入第三方资源一般有三种方式：jar包，aar包，module.</p>
<p>1.jar包的导入</p>
<p>第一种：<br>一般用于比较流行的第三方库上，直接将你在GitHub上看到的jar包compile放入build.gradle的dependencies里面，然后sync同步一下就可以了。例如：导入v7包。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies&#123;</span><br><span class="line">......</span><br><span class="line">compile ‘com.android.support:appcompat-v7:24.2.1’</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二种：<br>我们已经从网上下好了（或者别人给你的）jar，需要将他导入到AS工程里，首先将jar包放到libs里面，然后还是在build.gradle的dependencies里面添加compile路径，最后sync一下。例如：导入volley。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies&#123;</span><br><span class="line">.....</span><br><span class="line">compile files(‘libs/volley.jar’)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.aar包导入<br>aar包是Android特有的一种引用包，Android Archive，它跟jar包的区别在于：<br>jar包：只包含class文件和清单文件，不包含资源文件，比如图片等所有的 res下的资源文件；<br>aar包：class以及res下的所有的资源文件全部包含。<br>aar包的引用也很简单，以上是一个正常的module（工程应用，而非作为第三方library使用的）引用aar文件为例，首先也是将拿到的aar包放进libs下。然后按如下配置，最后sync一下就可以了，列如，导入一个叫abc.aar的包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;  </span><br><span class="line">    flatDir &#123;  </span><br><span class="line">        dirs &apos;libs&apos;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;    // 此在android标签下添加</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">.....</span><br><span class="line">   compile(name: &apos;abc.aar, ext: &apos;aar&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，以上是一个正常的module（工程应用，而非作为第三方library使用的）引用aar文件需要配置的步骤。</p>
<p>下面说一下当一个library类型的module需要引用aar文件时：<br>a.在该library中按照上面的代码，在library的module下的bulid.gradle中配置。</p>
<p>b.任何依赖此library的module必须声明在它的build.gradle声明此 aar 的 lib 所在的位置，这个位置根据文件路径所确定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android&#123;    //android节点下配置</span><br><span class="line">    repositories &#123;</span><br><span class="line">          flatDir &#123;</span><br><span class="line">            dirs &apos;libs&apos;, &apos;../../../../library_module/libs&apos;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c. 配置完b步骤后，还要在project的build.gradle文件中配置，如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        flatDir &#123;</span><br><span class="line">            dirs &apos;../../../library_module/libs&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>梳理一下这里的依赖关系：<br>aar-&gt;library module-&gt;依赖此library的module-&gt;project</p>
<p>3.module的导入<br>module的导入在上一篇博客中<a href="http://qiracle.cn/2018/10/21/20181021/" target="_blank" rel="external">Android Studio中module的导入</a> 已经讲过。这里主要说一下module是可以打包成aar包的，通过gradle的assembeRelease或assembleDebug可以将module打包成aar包（分别对应release版本和debug版本）。<br>另外，笔者曾经遇到一个大坑，那就是当aar包引用第三方module的时候，编译不会报错，但是运行时会一直报类找不到的错误，因为在打包aar包时不会将第三方module打包进aar包里面。这里如果将第三方module先打包成aar包，给工程调用就不会出现这样的问题了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android  Studio中引入第三方资源一般有三种方式：jar包，aar包，module.&lt;/p&gt;
&lt;p&gt;1.jar包的导入&lt;/p&gt;
&lt;p&gt;第一种：&lt;br&gt;一般用于比较流行的第三方库上，直接将你在GitHub上看到的jar包compile放入build.gradle的dependencies里面，然后sync同步一下就可以了。例如：导入v7包。&lt;br&gt;
    
    </summary>
    
      <category term="教程" scheme="http://qiracle.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Android" scheme="http://qiracle.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio 导入 module</title>
    <link href="http://qiracle.github.io/2018/10/21/20181021/"/>
    <id>http://qiracle.github.io/2018/10/21/20181021/</id>
    <published>2018-10-20T16:00:00.000Z</published>
    <updated>2019-10-26T07:22:14.195Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>在当前工程里，点击 File-&gt;New-&gt;import module.  在弹出的对话框里选择需要导入的 module 的路径。这里将 module 名字改成了 :mylib . <a id="more"></a>
<img src="http://qiracle.cn/img/20181021/module_1.png" alt=""></li>
</ol>
<p>这一步之后会在主工程的build.gradle生成如下代码：</p>
<p><img src="http://qiracle.cn/img/20181021/module_4.png" alt=""></p>
<p>这里原本是 compile project(path: ‘:mylib’)。 但是我这里的gradle是3之后的版本，所以需要将compile替换成implementation。</p>
<p>2.如果导入的 mylib 之前是一个工程应用，则需要更改 mylib 里的 build.gradle。具体修改如下：</p>
<p>   <img src="http://qiracle.cn/img/20181021/module_2.png" alt=""><br>   需要将图中的 com.android.application 改成 com.android.library 以及删除applicationId这一行。</p>
<p>   改完后记得sync一下。</p>
<p>   3.修改主工程下的 setting.gradle. 添加如下：</p>
<p>   <img src="http://qiracle.cn/img/20181021/module_3.png" alt=""></p>
<p>同样改完之后sync一下。</p>
<p>这样，module的导入就完成了，我们可以试试调用module里的方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;在当前工程里，点击 File-&amp;gt;New-&amp;gt;import module.  在弹出的对话框里选择需要导入的 module 的路径。这里将 module 名字改成了 :mylib .
    
    </summary>
    
      <category term="教程" scheme="http://qiracle.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Android" scheme="http://qiracle.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
