{"meta":{"title":"Qiracle's Blog","subtitle":"no pains,no gains","description":"qiracle,Android,java,前端","author":"qiracle","url":"http://qiracle.github.io"},"pages":[],"posts":[{"title":"读《深入理解Java虚拟机》总结<三.java中的新生代和老年代内存>","slug":"20190921","date":"2019-09-20T16:00:00.000Z","updated":"2019-09-21T07:42:11.000Z","comments":true,"path":"2019/09/21/20190921/","link":"","permalink":"http://qiracle.github.io/2019/09/21/20190921/","excerpt":"概念新生代：新生代中98%的对象都是朝生夕死 （1个eden 区（80%） 和 2个survivor区（10%））。老年代：存活对象存留的时间比较久。 MinorGC：发生在新生代的垃圾回收。很频繁，速度快。FullGC：发生在老年代的垃圾回收。发生FullGC通常会伴随一次MinorGC（并非绝对），FullGC会比MinorGc慢10倍以上。","text":"概念新生代：新生代中98%的对象都是朝生夕死 （1个eden 区（80%） 和 2个survivor区（10%））。老年代：存活对象存留的时间比较久。 MinorGC：发生在新生代的垃圾回收。很频繁，速度快。FullGC：发生在老年代的垃圾回收。发生FullGC通常会伴随一次MinorGC（并非绝对），FullGC会比MinorGc慢10倍以上。 内存分配与回收策略：1.对象优先在Eden区进行分配 大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次MinorGC 2.对象直接进入老年代 所谓大对象就是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串及数组，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾回收以获取足够的连续空间来安置他们。 3.长期存活的对象将进入老年代 虚拟机既然采用了分代收集的思想来管理内存，那内存回收时就必须能识别哪些对象应当放在新生代，哪些对象应放在老年代。为了做到这点，虚拟机给每个对象定义了一个对象年龄计数器。如果对象在Eden出生经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当他的年龄增加到一定程度（默认15）时，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过设置参数-XX:MaxTenuringThreshold。 4 动态对象年龄判定 为了更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。 5 空间分配担保 在发生MinorGC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则改为直接进行一次Full GC。如果小于，则查看HandlePromotionFailure设置是否允许担保失败：如果允许，那只会进行MinorGC；如果不允许，则也要改为进行一次FullGC。取平均值进行比较其实仍然是一种动态概率的手段，也就是说如果某次MinorGC存活后的对象突增，远远高于平均值得话，依然会导致担保失败。如果出现了担保失败，那只好在失败后重新发起FullGC。虽然担保失败时绕的圈子是最大的，但大部分情况下还是会将HandlePromotionFailure 开关打开，避免Full GC过于频繁。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiracle.github.io/tags/Android/"}]},{"title":"Android屏幕适配 px,dp,dpi及density的关系与深入理解","slug":"2019091502","date":"2019-09-14T16:00:00.000Z","updated":"2019-09-15T01:43:40.000Z","comments":true,"path":"2019/09/15/2019091502/","link":"","permalink":"http://qiracle.github.io/2019/09/15/2019091502/","excerpt":"PX(pixel):即传统计算机语言中描述的像素，在Android则代表绝对像素。 之所以Android中不推荐使用这种单位，正是因为不同生产厂商，不同品牌，不同屏幕的设备，其分辨率亦不一。 举例来说，我们现在将某个Button的width设为160px，则会出现如下情况： 在分辨率为“320宽”的设备里，该按钮显示占屏幕宽度一半； 在分辨率为“640宽”的设备里，该按钮显示占屏幕宽度的四分之一；","text":"PX(pixel):即传统计算机语言中描述的像素，在Android则代表绝对像素。 之所以Android中不推荐使用这种单位，正是因为不同生产厂商，不同品牌，不同屏幕的设备，其分辨率亦不一。 举例来说，我们现在将某个Button的width设为160px，则会出现如下情况： 在分辨率为“320宽”的设备里，该按钮显示占屏幕宽度一半； 在分辨率为“640宽”的设备里，该按钮显示占屏幕宽度的四分之一； DPI(Dots Per Inch):为了避免上面说到的使用px在屏幕适配中带来的问题，Android引入了一个新的单位：dp/dip。 而在理解“dp”之前，我们更有必要先了解一下另一个概念。正是：dpi。 也有人讲dpi称为“屏幕密度”。其含义则是：每英寸所打印的点数，既每一英寸的屏幕所包含的像素数。 举例来说，假设现在有一台“宽2英寸，长3英寸”的设备，则： 当该设备分辨率为“320x480”，则dpi值为160。当该设备分辨率为“640x960”，则dpi值为320。而“dpi”值越高的设备，其屏幕显示画面的效果也就越精细。 使用场景： 正是因为dpi值其代表的特性，所以android项目的资源文件下存在以下目录： drawable-ldpi ( 当dpi为120时，使用此目录下的资源)drawable-mdpi ( 当dpi为160时，使用此目录下的资源)drawable-hdpi ( 当dpi为240时，使用此目录下的资源)drawable-xhdpi ( 当dpi为320时，使用此目录下的资源)drawable-xxhdpi ( 当dpi为480时，使用此目录下的资源)Android正是根据设备DPI值得不同，选择清晰度不同的资源使用，完成屏幕的适配。 DP/DIP(device independent pixels):与我们之前谈到的绝对密度“px”对应，Android中引入的“dp”代表的则是“设备独立像素”。 该单位是为支持WVGA、HVGA和QVGA而使用的，其不再依赖像素本身，而是和屏幕密度相关。 在Android当中规定：在屏幕密度为“160dpi”的情况下，则刚好“1dp = 1px”。 注：当屏幕密度为“320dpi”时，则“1dp = 2px”，以此类推……. 也正是因此，让我们得以保证了：控件在不同密度的屏幕上显示一致，既完成屏幕适配。 使用场景： 让我们回到上面说到的使用px造成的控件显示问题，此时我们将使用新的单位“dp”。于是： 在分辨率320x480（既dpi为160）的设备下，则160dp等价于160px，按钮占屏幕宽的一半。在分辨率640x960（既dpi为320）的设备下，则160dp等价于320px，按钮依然占屏幕宽的一半。 Density：就这个单词本身直接翻译的意思而言，其也代表“密度”。但需要注意的是，在Android中，其实并非如此。注意我们这里指的是，通过代码“context.getResources().getDisplayMetrics().density”获取的“density”值。而通过该方法获取到的该值，实际上是等价于“dpi / 160”的一个结果值。也就是说：“getResources().getDisplayMetrics().density” = “getResources().getDisplayMetrics().densityDpi / 160” 看到这样一个解析，聪明的人大概已经能预见什么了。我们似乎发现了某种关联：在Android里：“dpi = 160，则1dp = 1px”、“dpi = 320，则1dp = 2px”。以此类推。到此你已经发现，dp，px与160之间存在着某种规律：“1dp = (dpi / 160)px”换算一下，最终得到公式: dp = density * px 。 到了这里我们明白了，其实Android提供的该值，也就是为了让我们在dp与px之间做转换。归根结底，其目的还是为了帮助我们做屏幕适配。 使用场景：虽然使用dp在xml文件中定义控件尺寸，能够很好的帮助我们完成适配。但很多时候，我们也会需要在Java代码中动态的去设定控件的尺寸。 但由于在代码中的尺寸设定，基本都被默认为了px单位。所以这个时候就可以借助“density”来帮我们完成dp与px的转换，从而完成适配。 1234public static int dip2px(Context context, float dipValue)&#123; final float scale = context.getResources().getDisplayMetrics().density; return (int)(dipValue * scale + 0.5f); &#125; ​ 1234public static int px2dip(Context context, float pxValue)&#123; final float scale = context.getResources().getDisplayMetrics().density; return (int)(pxValue / scale + 0.5f); &#125; 原文链接：https://blog.csdn.net/ghost_Programmer/article/details/50042805","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiracle.github.io/tags/Android/"}]},{"title":"Android layout_weight 计算方式","slug":"20190915","date":"2019-09-14T16:00:00.000Z","updated":"2019-09-15T01:17:21.000Z","comments":true,"path":"2019/09/15/20190915/","link":"","permalink":"http://qiracle.github.io/2019/09/15/20190915/","excerpt":"假设：LinearLayout为android:orientation=”horizontal”， layout_weight属性值分别为1、2、2 第一种情况：每个控件的宽度属性都为android:layout_width=”0dp”，那么额外的空为（手机的宽度假设为X）X-0-0-0=X，那么根据sdk上所述：","text":"假设：LinearLayout为android:orientation=”horizontal”， layout_weight属性值分别为1、2、2 第一种情况：每个控件的宽度属性都为android:layout_width=”0dp”，那么额外的空为（手机的宽度假设为X）X-0-0-0=X，那么根据sdk上所述：第一个控件的宽度为 0+(1/(1+2+2))X=X/5第二个控件的宽度为 0+(2/(1+2+2))X=2X/5第三个控件的宽度为 0+(2/(1+2+2))*X=2X/5 第二种情况：每个控件的宽度属性都为android:layout_width=”match_parent”，那么额外的空间就是X-X-X-X=-2X第一个控件的宽度为 X+(1/(1+2+2))(-2X)=3X/5第二个控件的宽度为 X+(2/(1+2+2))(-2X)=X/5第三个控件的宽度为 X+(2/(1+2+2))*(-2X)=X/5 第三种情况：其中第一个控件宽度属性为android:layout_width=”match_parent”，其他两个控件宽度为android:layout_width=”0dp”，额外的空间为X-X-0-0=0第一个控件的宽度为 X+(1/(1+2+2))0=X第二个控件的宽度为 0+(2/(1+2+2))0=0第三个控件的宽度为 0+(2/(1+2+2))*0=0 最终结论：layout_weight的公式控件的宽度/高度 = 控件的width/height值+（该控件的weight值/所有控件的weight的和）×额外的空间额外的空间=手机的宽度/高度-所有控件的宽度/高度 注：如果属性为android:layout_width=”wrap_content” 则计算时，总宽/高要减去控件本身占据的宽/高 转自：https://blog.csdn.net/Dazlly/article/details/13767343","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiracle.github.io/tags/Android/"}]},{"title":"Android Studio 配置 JNI","slug":"20190824","date":"2019-08-23T16:00:00.000Z","updated":"2019-10-26T07:24:17.678Z","comments":true,"path":"2019/08/24/20190824/","link":"","permalink":"http://qiracle.github.io/2019/08/24/20190824/","excerpt":"JNI 是java 语言调用C/C++函数的接口。与JNI相关的开发工具包是NDK。下面记录Android Studio 里用 java代码调用 JNI的基本过程。当前环境： Android Studio：3.1.2. NDK：20.0.5","text":"JNI 是java 语言调用C/C++函数的接口。与JNI相关的开发工具包是NDK。下面记录Android Studio 里用 java代码调用 JNI的基本过程。当前环境： Android Studio：3.1.2. NDK：20.0.5 准备下载NDK: ###1.创建Java类 定义一个工具类，里面定义了native方法： 123456789package cn.qiracle.jnidemo.jni;public class JniUtils &#123; static &#123; System.loadLibrary(\"JniLib\"); &#125; public static native String getJniString();&#125; 2.创建JNI文件夹在main文件夹下创建jni文件夹： 3.生成头文件两种方式： 1.通过命令行 javac JniUtils.java 编译生成 JniUtils.class文件。然后回退到包外目录javah -jni cn.qiracle.jnidemo.jni.JniUtils。将生成的.h文件移动到main下的jni目录下。 2.配置外部工具 点击File - Setting - Tools - External Tools 打开外部工具配置页，点击 + 新建一个工具。 Program: $JDKPath$\\bin\\javah.exe Arguments: -classpath . -jni -d $ModuleFileDir$\\src\\main\\jni $FileClass$ Working directory: $ModuleFileDir$\\src\\main\\Java 点击 OK 保存后就新建了一个工具。此时我们右击 JniUtils.java，在菜单中选择 External Tools - javah 就可以快速生成头文件并放到 jni 目录。 4.编写C代码在jni目录下新建一个cn_qiracle_jnidemo_jni_JniUtils.cpp文件。内容如下： 1234567#include \"cn_qiracle_jnidemo_jni_JniUtils.h\"JNIEXPORT jstring JNICALL Java_cn_qiracle_jnidemo_jni_JniUtils_getJniString(JNIEnv *env,jclass jobj) &#123;//new 一个字符串，返回Hello Worldreturn (*env).NewStringUTF(\"Hello jni\");&#125; 这里输出 hello jni 5.创建mk文件mk 文件用于告诉 ndk-build 该如何编译 c 源码。详情见官方指南。 在jni目录下创建Android.mk: 1234567LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := JniLibLOCAL_SRC_FILES =: cn_qiracle_jnidemo_jni_JniUtils.cppinclude $(BUILD_SHARED_LIBRARY) 创建 Application.mk： 12APP_MODULES := JniLibAPP_ABI := all 6.gradle配置在 module 的 build.gradle 里，amndroid.defaultConfig 下加入下面配置： 1234567ndk &#123; moduleName &quot;JniLib&quot; &#125; sourceSets.main&#123; jni.srcDirs = [] jniLibs.srcDir &quot;src/main/libs&quot; &#125; 6.编译这里我们配置使用外部工具： Program: D:\\SDK\\ndk-bundle\\build\\ndk-build.cmd （注意这里是ndk-build路径） Working directory: $ProjectFileDir$\\app\\src\\main 任意找个第地方右击，选择 External Tools - ndk-build 即可编译 c 源码。成功后可以看见创建了 libs 目录，里面包含了不同平台下的 so 文件。 7.验证在MainActivity.java里调用native方法： 1Toast.makeText(this,JniUtils.getJniString(),Toast.LENGTH_SHORT).show(); 运行结果： 参考： https://www.jianshu.com/p/09ff3300f453","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiracle.github.io/tags/Android/"},{"name":"JNI","slug":"JNI","permalink":"http://qiracle.github.io/tags/JNI/"}]},{"title":"Android AIDL的基本用法","slug":"20190810","date":"2019-08-09T16:00:00.000Z","updated":"2019-10-26T07:23:58.201Z","comments":true,"path":"2019/08/10/20190810/","link":"","permalink":"http://qiracle.github.io/2019/08/10/20190810/","excerpt":"AIDL 是 Android 中实现跨进程通信的一种方式。下面是一个简单的实现案例，通过 AIDL 实现客户端调用服务端的接口， 实现跨进程通信。","text":"AIDL 是 Android 中实现跨进程通信的一种方式。下面是一个简单的实现案例，通过 AIDL 实现客户端调用服务端的接口， 实现跨进程通信。 Server首先，创建一个服务端工程 AIDLServer。main下面创建aidl文件夹，然后在aidl文件夹下创建包和aidl文件，如下： IMyAidlInterface.aidl 文件内容如下： 123456789// IMyAidlInterface.aidlpackage cn.qiracle.aidlserver;// Declare any non-default types here with import statementsinterface IMyAidlInterface &#123; void print(); int add(int a, int b);&#125; 这里定义了AIDL接口IMyAidlInterface，接口里定义了两个待实现的方法。然后 重新构建下工程，这样在build目录下就会生成IMyAidlInterface.java 文件。 接着定义一个Service，如下： 12345678910111213141516171819202122232425262728293031package cn.qiracle.aidlserver;import android.app.Service;import android.content.Intent;import android.os.IBinder;import android.os.RemoteException;import android.util.Log;public class MyService extends Service &#123; public MyService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; return new MyBinder(); &#125; class MyBinder extends IMyAidlInterface.Stub &#123; @Override public void print() throws RemoteException &#123; Log.i(\"qiracle\", \"my aidl test\"); &#125; @Override public int add(int a, int b) throws RemoteException &#123; Log.i(\"qiracle\", \"a + b:\" + (a + b)); return a + b; &#125; &#125;&#125; 在这个Service里 ，内部类MyBinder继承IMyAidlInterface.Stub ，然后实现接口里待实现的方法。这两个方法就是提供给客户端进行调用的。 最后，清单文件里记得注册下服务 12345678&lt;service android:name=&quot;.MyService&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;cn.qiracle.aidlservice&quot; /&gt; &lt;/intent-filter&gt;&lt;/service&gt; 然后启动服务 1234Intent intent = new Intent();intent.setAction(\"cn.qiracle.aidlservice\");intent.setPackage(\"cn.qiracle.aidlserver\");startService(intent); 以上就是AIDL的服务端简单实现。主要就是定义一个AIDL接口，然后在服务里实现这个接口，提供给客户端调用。下面介绍客户端部分。 Client先建立一个客户端的工程，跟服务端工程一样，需要在main下建立aidl目录，然后在aidl目录下新建包和aidl文件，这里的包名和aidl文件名必须和服务端保持一致。如下： IMyAidlInterface.aidl 的内容也和 服务端的 IMyAidlInterface.aidl 保持一致 然后，在Activity里绑定服务，如下： 123456789101112131415Intent intent = new Intent();intent.setAction(\"cn.qiracle.aidlservice\");intent.setPackage(\"cn.qiracle.aidlserver\");bindService(intent, new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; iMyAidlInterface = IMyAidlInterface.Stub.asInterface(service); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125;&#125;,BIND_AUTO_CREATE); 可以通过按钮的点击事件，调用服务端的方法。 123456789public void click(View view)&#123; Toast.makeText(getApplicationContext(),\"click\",Toast.LENGTH_SHORT).show(); try &#123; iMyAidlInterface.print(); iMyAidlInterface.add(1,2); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125;&#125; 以上就是客户端实现。 开始运行，注意需要先运行服务端，开启Service，然后运行客户端，绑定服务，通过点击按钮，可以看到服务端控制台有日志打印。 以上，我们就通过AIDL实现了跨进程的调用，方法的实现在服务端，方法的调用在客户端。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiracle.github.io/tags/Android/"},{"name":"AIDL","slug":"AIDL","permalink":"http://qiracle.github.io/tags/AIDL/"}]},{"title":"Android 知识点总结（一）","slug":"20190803","date":"2019-08-02T16:00:00.000Z","updated":"2019-08-03T07:19:32.000Z","comments":true,"path":"2019/08/03/20190803/","link":"","permalink":"http://qiracle.github.io/2019/08/03/20190803/","excerpt":"Handler Handler 的回调方法是在 Looper.loop()所调用的线程进行的； Handler 的创建需要先调用 Looper.prepare() ，然后再手动调用 loop()方法开启循环； App 启动时会在ActivityThread.main()方法中创建主线程的 Looper ,并开启循环，所以主线程使用 Handler 不用调用第2点的逻辑；","text":"Handler Handler 的回调方法是在 Looper.loop()所调用的线程进行的； Handler 的创建需要先调用 Looper.prepare() ，然后再手动调用 loop()方法开启循环； App 启动时会在ActivityThread.main()方法中创建主线程的 Looper ,并开启循环，所以主线程使用 Handler 不用调用第2点的逻辑； 延时消息并不会阻塞消息队列； 异步消息不会马上执行，插入队列的方式跟同步消息一样，唯一的区别是当有消息屏障时，异步消息可以继续执行，同步消息则不行； Callback.handleMessage() 的优先级比 Handler.handleMessage()要高* Handler.post(Runnable)传递的 Runnale 对象并不会在新的线程执行； Message 的创建推荐使用 Message.obtain() 来获取，内部采用缓存消息池实现； 不要在 handleMessage()中对消息进行异步处理； 可以通过removeCallbacksAndMessages(null)或者静态类加弱引用的方式防止内存泄漏； Looper.loop()不会造成应用卡死，里面使用了 Linux 的 epoll 机制。 Context源码中的注释是这么来解释Context的：Context提供了关于应用环境全局信息的接口。它是一个抽象类，它的执行被Android系统所提供。它允许获取以应用为特征的资源和类型，是一个统领一些资源（应用程序环境变量等）的上下文。就是说，它描述一个应用程序环境的信息（即上下文）；是一个抽象类，Android提供了该抽象类的具体实现类；通过它我们可以获取应用程序的资源和类（包括应用级别操作，如启动Activity，发广播，接受Intent等）。既然上面Context是一个抽象类，那么肯定有他的实现类咯，我们在Context的源码中通过IDE可以查看到他的子类最终可以得到如下关系图： Context类本身是一个纯abstract类，它有两个具体的实现子类：ContextImpl和ContextWrapper。其中ContextWrapper类，如其名所言，这只是一个包装而已，ContextWrapper构造函数中必须包含一个真正的Context引用，同时ContextWrapper中提供了attachBaseContext（）用于给ContextWrapper对象中指定真正的Context对象，调用ContextWrapper的方法都会被转向其所包含的真正的Context对象。ContextThemeWrapper类，如其名所言，其内部包含了与主题（Theme）相关的接口，这里所说的主题就是指在AndroidManifest.xml中通过android：theme为Application元素或者Activity元素指定的主题。当然，只有Activity才需要主题，Service是不需要主题的，因为Service是没有界面的后台场景，所以Service直接继承于ContextWrapper，Application同理。而ContextImpl类则真正实现了Context中的所以函数，应用程序中所调用的各种Context类的方法，其实现均来自于该类。一句话总结：Context的两个子类分工明确，其中ContextImpl是Context的具体实现类，ContextWrapper是Context的包装类。Activity，Application，Service虽都继承自ContextWrapper（Activity继承自ContextWrapper的子类ContextThemeWrapper），但它们初始化的过程中都会创建ContextImpl对象，由ContextImpl实现Context中的方法。 一个应用程序有几个Context？ 实这个问题本身并没有什么意义，关键还是在于对Context的理解，从上面的关系图我们已经可以得出答案了，在应用程序中Context的具体实现子类就是：Activity，Service，Application。那么Context数量=Activity数量+Service数量+1。当然如果你足够细心，可能会有疑问：我们常说四大组件，这里怎么只有Activity，Service持有Context，那Broadcast Receiver，Content Provider呢？Broadcast Receiver，Content Provider并不是Context的子类，他们所持有的Context都是其他地方传过去的，所以并不计入Context总数。上面的关系图也从另外一个侧面告诉我们Context类在整个Android系统中的地位是多么的崇高，因为很显然Activity，Service，Application都是其子类，其地位和作用不言而喻。 视图Activity Activity并不负责视图控制，它只是控制生命周期和处理事件。真正控制视图的是Window。一个Activity包含了一个Window，Window才是真正代表一个窗口。Activity就像一个控制器，统筹视图的添加与显示，以及通过其他回调方法，来与Window、以及View进行交互。 Window Window是视图的承载器，内部持有一个 DecorView，而这个DecorView才是 view 的根布局。Window是一个抽象类，实际在Activity中持有的是其子类PhoneWindow。PhoneWindow中有个内部类DecorView，通过创建DecorView来加载Activity中设置的布局R.layout.activity_main。Window 通过WindowManager将DecorView加载其中，并将DecorView交给ViewRoot，进行视图绘制以及其他交互。 DecorView DecorView是FrameLayout的子类，它可以被认为是Android视图树的根节点视图。DecorView作为顶级View，一般情况下它内部包含一个竖直方向的LinearLayout，在这个LinearLayout里面有上下三个部分，上面是个ViewStub，延迟加载的视图（应该是设置ActionBar，根据Theme设置），中间的是标题栏(根据Theme设置，有的布局没有)，下面的是内容栏。 ViewRoot ViewRoot可能比较陌生，但是其作用非常重大。所有View的绘制以及事件分发等交互都是通过它来执行或传递的。 ViewRoot对应ViewRootImpl类，它是连接WindowManagerService和DecorView的纽带，View的三大流程（测量（measure），布局（layout），绘制（draw））均通过ViewRoot来完成。 ViewRoot并不属于View树的一份子。从源码实现上来看，它既非View的子类，也非View的父类，但是，它实现了ViewParent接口，这让它可以作为View的名义上的父视图。RootView继承了Handler类，可以接收事件并分发，Android的所有触屏事件、按键事件、界面刷新等事件都是通过ViewRoot进行分发的。 要知道，当用户点击屏幕产生一个触摸行为，这个触摸行为则是通过底层硬件来传递捕获，然后交给ViewRootImpl，接着将事件传递给DecorView，而DecorView再交给PhoneWindow，PhoneWindow再交给Activity，然后接下来就是我们常见的View事件分发了。 硬件 -&gt; ViewRootImpl -&gt; DecorView -&gt; PhoneWindow -&gt; Activity 通过以上了解可以知道，Activity就像个控制器，不负责视图部分。Window像个承载器，装着内部视图。DecorView就是个顶层视图，是所有View的最外层布局。ViewRoot像个连接器，负责沟通，通过硬件的感知来通知视图，进行用户之间的交互。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiracle.github.io/tags/Android/"}]},{"title":"Android Boardcast 权限的使用","slug":"20190512","date":"2019-05-11T16:00:00.000Z","updated":"2019-08-03T06:26:48.000Z","comments":true,"path":"2019/05/12/20190512/","link":"","permalink":"http://qiracle.github.io/2019/05/12/20190512/","excerpt":"1. 广播的接收权限设置广播接收权限的目的在于避免自己应用发送的广播被其他恶意应用接收到。简单来说就是定义谁能接收我的广播，用法如下： 首先发送方的应用在清单文件里自定义一个权限： 12&lt;permission android:name=\"cn.qiracle.RECEIVER\" android:protectionLevel=\"signature\" /&gt; 这里 protectionLevel 选择 signature 或者 signatureOrSystem 更加安全。","text":"1. 广播的接收权限设置广播接收权限的目的在于避免自己应用发送的广播被其他恶意应用接收到。简单来说就是定义谁能接收我的广播，用法如下： 首先发送方的应用在清单文件里自定义一个权限： 12&lt;permission android:name=\"cn.qiracle.RECEIVER\" android:protectionLevel=\"signature\" /&gt; 这里 protectionLevel 选择 signature 或者 signatureOrSystem 更加安全。 然后发送广播时调用如下 sendBoradcast 方法： 1234private static final String PERMISSION_RECEIVER= &quot;cn.qiracle.RECEIVER&quot;;......sendBroadcast(intent,PERMISSION_RECEIVER); 此时接收方app若是想接收到这个广播，需要在接收方应用的清单文件里添加如下权限： 1&lt;uses-permission android:name=\"cn.qiracle.RECEIVER\" /&gt; 2.广播的发送权限设置广播的发送权限目的在于避免自己的应用里的 receiver 被其他恶意应用发送的带有同样 action 的广播所骚扰。简单来说就是定义谁能给我发送广播。用法如下： 首先在接收方应用的清单文件里自定义一个权限： 12&lt;permission android:name=\"cn.qiracle.SEND\" android:protectionLevel=\"signature\" /&gt; 然后注册广播时采用如下regiserReceiver方法： 1234private static final String PERMISSION_SEND = \"cn.qiracle.SEND\";......registerReceiver(new MyReceiver(),intentFilter,PERMISSION_SEND,null); 上面是动态注册，静态注册广播方式如下： 123456&lt;receiver android:name=\".receiver.MyReceiver\" android:permission=\"cn.qiracle.SEND\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"cn.qiracle.MYRECEIVER\"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 推荐使用动态注册的方式，因为笔者尝试发现自定义权限时，静态注册的方式在 Android8.0 及以上会不起作用。 此时广播的发送方 app 要想给这个应用发送广播，必须在清单文件里添加如下权限： 1&lt;uses-permission android:name=\"cn.qiracle.SEND\" /&gt;","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiracle.github.io/tags/Android/"}]},{"title":"读《深入理解Java虚拟机》总结<二.java内存模型与线程>","slug":"20190217","date":"2019-02-16T16:00:00.000Z","updated":"2019-10-26T07:23:24.173Z","comments":true,"path":"2019/02/17/20190217/","link":"","permalink":"http://qiracle.github.io/2019/02/17/20190217/","excerpt":"主内存与工作内存java内存模型规定了所有变量都存储在主内存中。此处的变量是指实例字段，静态字段和构成数组对象的元素。但不包括局部变量与方法参数。因为后者是线程私有的，不会被共享。除主内存之外，每个线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取，赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间也无法之间访问对方工作内存中的变量。线程间变量值得传递均需要通过主内存来完成。","text":"主内存与工作内存java内存模型规定了所有变量都存储在主内存中。此处的变量是指实例字段，静态字段和构成数组对象的元素。但不包括局部变量与方法参数。因为后者是线程私有的，不会被共享。除主内存之外，每个线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取，赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间也无法之间访问对方工作内存中的变量。线程间变量值得传递均需要通过主内存来完成。 一个变量如何从主内存拷贝到工作内存，如何从工作内存同步回主内存之类的实现细节，java内存模型定义了以下八种操作来完成: lock(锁定)：作用于主内存的变量，把一个变量标记为一条线程独占状态 unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用 load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中 use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎 assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量 store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作 write(写入)：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中 volatile 关键字用于修饰变量。主要作用有两个： 1.保证修改的可见性 2.禁止指令重排序 volatile不保证操作的原子性","categories":[{"name":"总结","slug":"总结","permalink":"http://qiracle.github.io/categories/总结/"}],"tags":[{"name":"java","slug":"java","permalink":"http://qiracle.github.io/tags/java/"}]},{"title":"读《深入理解Java虚拟机》总结<一自动内存管理机制>","slug":"20190216","date":"2019-02-15T16:00:00.000Z","updated":"2019-10-26T07:22:44.232Z","comments":true,"path":"2019/02/16/20190216/","link":"","permalink":"http://qiracle.github.io/2019/02/16/20190216/","excerpt":"这一周来比较空闲，读了《深入理解java虚拟机一书》以提高自己对java底层的认知，还没看完，只是挑选了书中自己比较感兴趣的两个章节来看，写下此篇博客一是为了总结，二是为了方便今后回顾。下面是第一部分自动内存管理机制","text":"这一周来比较空闲，读了《深入理解java虚拟机一书》以提高自己对java底层的认知，还没看完，只是挑选了书中自己比较感兴趣的两个章节来看，写下此篇博客一是为了总结，二是为了方便今后回顾。下面是第一部分自动内存管理机制 运行时数据区域 程序计数器程序计数器时一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。为了线程切换后能够恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程直接的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 java虚拟机栈与程序计数器一样，java虚拟机栈也是线程私有的，它的生命周期与线程相同。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackoverflowError异常；如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。 本地方法栈本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行java方法服务，而本地方法栈则是为虚拟机使用到的Native方法服务。。本地方法栈也会抛出StackoverflowError和OutOfMemoryError异常。 java堆对于大多数应用来说，java堆是java虚拟机所管理的内存中最大的一块。java堆是所以线程共享的一块内存区域，在虚拟机启动时创建。java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存完成实例分配，并且堆无法再扩展时，将会抛出OutOfMemoryError异常。 方法区方法区与java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。垃圾回收行为在这个区域是比较少出现的，这个区域内存回收目标主要是针对常量池的回收和对类型的卸载。。当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 运行时常量池运行时常量池时方法区的一部分。Class文件除了有类的版本，字段，方法，接口等描述信息外，还有一项信息就是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区运行时常量池中。运行期间也可能将新的常量放入池中，如String类的intern()方法。 确定对象是否存活的算法垃圾回收器在对堆进行回收前，第一件事情就是要确定这些对象有哪些还存活着，哪些已经死去。 引用计数算法给对象中添加一个引用计算器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。。 java语言没有选用引用计数法来管理内存，其中最主要的原因是它很难解决对象之间的相互循环引用的问题。如下： 123456ReferenceCountGC objA = new ReferenceCountGC();ReferenceCountGC objB = new ReferenceCountGC();objA.instance = objB;objB.instance = objA;objA = null;objB = null; 根搜索算法在主流的商用程序语言中，都是使用根搜索算法判断对象是否存活的。基本思路是通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象待GC Roots没有任何引用链相连，则证明此对象是不可用的。 Java语言里，可作为GC Roots对象包括下面几种： 虚拟机栈中引用的对象 方法区中的类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI的引用对象 java中的四种引用强引用：代码至中普遍存在。类似 Object obj = new Object()。主要强引用还在，垃圾回收器永远不会回收掉被引用的对象。 软引用：当内存不够时，即系统将要发生内存溢出异常之前，将会把这些对象列进回收范围并进行二次回收。java中提供SoftReference类实现软引用。 弱引用：被弱引用关联的对象只能生存到下次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够，都会回收掉被弱引用关联的对象。java中提供WeakReference类实现软引用。 虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望这个对象在被收集器回收时收到一个系统通知。java中提供PhantomReference类实现软引用。 对象死亡过程在跟搜索算法中不可达的对象也并非是非死不可的。这些不可达的对象先会被判断是否有必要执行finalize()方法，当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机会将这两种情况都视为“没有必要执行”。 finalize()方法是对象逃脱死亡命运的最后一次机会，如果对象想要在finalize()方法中成功拯救自己，只要重新与引用链上的任何一个对象建立关联即可。譬如把自己(this)赋值给某个类变量或者某个对象的成员变量。如下： 12345678910public class FinalizeEscapeGc&#123; public static FinalizeEscapeGc Save_HooK = null; @Override protected void finalized() throws Throwable&#123; super.finalized(); FinalizeEscapeGc.Save_HooK = this; &#125; &#125; 如何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会再次被执行。 垃圾回收算法标记-清除算法首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。它的主要缺点有两个: 一是效率问题，标记和清楚过程效率都不高 二是空间问题，标记清除后会产生大量不连续的内存碎片。 复制算法它将可用内存按容量划分为大小相同的两块，每次只使用其中的一块，当一块内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。这种算法的代价是将内存缩小为原来的一半未免太高了一些。 现在的商用虚拟机都采用这种收集算法来回收新生代，IBM的专门研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1:1的比例来划分空间。而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活的对象一次性拷贝到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例为8:1。当Survivor空间不够时，需要依赖其他内存（老年代）进行分配担保。 标记-整理算法复制算法在对象存活率较高时需要执行较多的复制操作，更关键是如果不想浪费50%空间，就需要额外的空间进行担保，以应对内存中所有对象都100%存活的极端情况，所以老年代一般不能直接选用这种算法。 标记-整理算法的标记过程仍然与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存。 分代收集算法根据对象的存活周期不同将内存划分为几块，一般是把Java堆分为新生代和老年代。在新生代中，每次垃圾收集时发现大批对象死去，只有少量存活，那就选用复制算法。老年代中因为对象存活率高，没有额外空间对它进行分配担保，就必须使用“标记-清理”，“标记-整理”算法来进行回收。 垃圾收集器 如果两个收集器之间存在连线，就说明他们可以搭配使用。下面就只说下Serial收集器： Serial收集器Serial收集器是最基本，历史最悠久的收集器，这是一个单线程的收集器。它在进行垃圾收集时，必须暂停其他所有工作线程指到它收集结束。","categories":[{"name":"总结","slug":"总结","permalink":"http://qiracle.github.io/categories/总结/"}],"tags":[{"name":"java","slug":"java","permalink":"http://qiracle.github.io/tags/java/"}]},{"title":"CentOS下编译Hadoop","slug":"20190106","date":"2019-01-05T16:00:00.000Z","updated":"2019-01-20T11:55:32.000Z","comments":true,"path":"2019/01/06/20190106/","link":"","permalink":"http://qiracle.github.io/2019/01/06/20190106/","excerpt":"系统及软件版本准备CentOS-6.7-64bit Hadoop-2.8.3-src java-1.8.0_141 apache-maven-3.3.9 protobuf-2.5.0 findbugs-1.3.9","text":"系统及软件版本准备CentOS-6.7-64bit Hadoop-2.8.3-src java-1.8.0_141 apache-maven-3.3.9 protobuf-2.5.0 findbugs-1.3.9 相关软件下载地址： 链接：https://pan.baidu.com/s/1FfRRPiosrhWpRIPYtcsEgg提取码：l84n 软件安装1.java-1.8.0_141下载 jdk-8u141-linux-x64.tar.gz， 解压到 /root/apps/jdk1.8.0_141。解压命令: tar -xf jdk-8u141-linux-x64.tar.gz 配置环境变量： vi /etc/profile 在文件最下面加上: export JAVA_HOME=/root/apps/jdk1.8.0_141export PATH=$PATH:$JAVA_HOME/binexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 添加完记得用下面的命令让其立即生效: source /etc/profile 注意：下面每次配置完环境变量都需要使用这个命令 检查是否安装成功: java -version 如果输出下面信息，则表示安装成功： java version “1.8.0_141”Java(TM) SE Runtime Environment (build 1.8.0_141-b15)Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode) 2.apache-maven-3.3.9下载apache-maven-3.3.9-bin.zip，并使用 下面命令解压： unzip apache-maven-3.3.9-bin.zip 我将其解压到了 /opt/software/a:pache-maven-3.3.9. 同样，配置环境变量，在/etc/profile中添加下面信息： export MAVEN_HOME=/opt/software/apache-maven-3.3.9export MAVEN_OPTS=&quot;-Xms256m -Xmx512m&quot;export PATH=$MAVEN_HOME/bin:$JAVA_HOME/bin:$PATH 验证是否安装成功: mvn -version 出现下列信息表明安装成功： Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)Maven home: /opt/software/apache-maven-3.3.9Java version: 1.8.0_141, vendor: Oracle CorporationJava home: /root/apps/jdk1.8.0_141/jreDefault locale: en_US, platform encoding: UTF-8OS name: “linux”, version: “2.6.32-573.el6.x86_64”, arch: “amd64”, family: “unix” 3.protobuf-2.5.0下载 protobuf-2.5.0.tar.gz ，解压到/opt/software/protobuf-2.5.0，接下来: cd protobuf-2.5.0 yum install -y gcc gcc-c++ make cmake ./configure –prefix=/usr/local/protobuf make &amp;&amp; make install 同样导入环境变量： export PROTOC_HOME=/usr/local/protobufexport PATH=$PROTOC_HOME/bin:$FINDBUGS_HOME/bin:$MAVEN_HOME/bin:$JAVA_HOME/bin:$PATH 验证是否安装成功： protoc --version 出现下面信息表明安装成功： libprotoc 2.5.0 4. findbugs-1.3.9下载findbugs-1.3.9.zip ，通过unzip findbugs-1.3.9.zip 解压到/opt/software/findbugs-1.3.9。 同样需要配置环境变量 export FINDBUGS_HOME=/opt/software/findbugs-1.3.9export PATH=$FINDBUGS_HOME/bin:$MAVEN_HOME/bin:$JAVA_HOME/bin:$PATH 验证是否安装成功： findbugs -version 出现下面信息表示安装成功： 1.3.9 5.其他依赖的安装yum install -y openssl openssl-devel svn ncurses-devel zlib-devel libtoolyum install -y snappy snappy-devel bzip2 bzip2-devel lzo lzo-devel lzop autoconf automake 6.编译下载hadoop-2.8.3-src.tar.gz并解压 tar -xf hadoop-2.8.3-src.tar.gz 到 /root/hadoop-2.8.3-src。运行下面命令： cd hadoop-2.8.3-src mvn clean package -Pdist,native -DskipTests -Dtar 编译过程中需要下载很多东西，需要很长时间，同时因为网络原因可能会一直卡在某个地方，这时可以ctrl+c中止然后重新运行上面命令。最后如果出现 BUILD SUCCESS 字样则表明编译成功. 编译好的tar包在 /root/hadoop-2.8.3-src/hadoop-dist/target/hadoop-2.8.1.tar.gz下","categories":[{"name":"教程","slug":"教程","permalink":"http://qiracle.github.io/categories/教程/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"http://qiracle.github.io/tags/hadoop/"}]},{"title":"java IO流总结","slug":"20181128","date":"2018-11-27T16:00:00.000Z","updated":"2019-10-26T07:22:29.219Z","comments":true,"path":"2018/11/28/20181128/","link":"","permalink":"http://qiracle.github.io/2018/11/28/20181128/","excerpt":"java IO流简介java IO流可 分为输入流 和 输出流。这里的输入和输出是相对于程序而言的，外部数据输入到程序中时，我们用输入流，程序中的数据输出到外部时，我们用输出流。 输入流又可分为字节输入流和字符输入流。字节输入流的基类为InputStream，我们常用到它的子类FileInputStream, 字符输入流的基类为Reader，我们常用到它的子类FileReader。 输出流又可分为字节输出流和字符输出流。字节输出流的基类为OutputStream，我们常用到它的子类FileOutputStream, 字符输出流的基类为Writer，我们常用到它的子类FileWriter。","text":"java IO流简介java IO流可 分为输入流 和 输出流。这里的输入和输出是相对于程序而言的，外部数据输入到程序中时，我们用输入流，程序中的数据输出到外部时，我们用输出流。 输入流又可分为字节输入流和字符输入流。字节输入流的基类为InputStream，我们常用到它的子类FileInputStream, 字符输入流的基类为Reader，我们常用到它的子类FileReader。 输出流又可分为字节输出流和字符输出流。字节输出流的基类为OutputStream，我们常用到它的子类FileOutputStream, 字符输出流的基类为Writer，我们常用到它的子类FileWriter。 那什么时候该用字节流，什么时候该用字符流呢？ 一般来说，在输入输出一些二进制对象的时候比如图片，音乐，视频文件，我们用字节流。 在输入输出一些文本文件的时候比如文字，我们用字符流。字符其实可以理解为是字节+对应的编码表（utf-8,gbk等）构成的，相同的一段字节，用不同的编码格式，最后得到的字符是不一样的（生活常见的乱码就是这样产生的） 另外，java在字节流和字符流中间提供了一层吧转换流，，可以将字节流转化为字符流。输入的转换流为InputStreamReader（InputStream is），输出的转换流为OutputStreamReader（OutputStream os ）。 解释了这么多，不如用一图来总结一下： IO 流在代码中的实际应用java提供了操作IO流的API，在代码中如何使用呢？ 接下来，直接附上几个比较实用的demo，可参考运用到自己的代码里 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class CopyMp3Demo &#123; public static void main(String[] args) throws Exception &#123; long start = System.currentTimeMillis(); method1(&quot;e:\\\\music.mp3&quot;, &quot;copy1.mp3&quot;); method2(&quot;e:\\\\music.mp3&quot;, &quot;copy2.mp3&quot;); method3(&quot;e:\\\\music.mp3&quot;, &quot;copy3.mp3&quot;); method4(&quot;e:\\\\music.mp3&quot;, &quot;copy4.mp3&quot;); long end = System.currentTimeMillis(); System.out.println(&quot; 总共耗时：&quot; + (end - start) + &quot;毫秒&quot;); &#125; // 基本字节流一次读写一个字节 public static void method1(String src, String dest) throws Exception &#123; FileInputStream fis = new FileInputStream(src); FileOutputStream fos = new FileOutputStream(dest); int by = 0; while ((by = fis.read()) != -1) &#123; fos.write(by); &#125; fis.close(); fos.close(); &#125; // 基本字节流一次读写一个字节数组 public static void method2(String src, String dest) throws Exception &#123; FileInputStream fis = new FileInputStream(src); FileOutputStream fos = new FileOutputStream(dest); int len = 0; byte[] bys = new byte[1024]; while ((len = fis.read(bys)) != -1) &#123; fos.write(bys, 0, len); &#125; fis.close(); fos.close(); &#125; // 高效字节流一次读写一个字节： public static void method3(String src, String dest) throws Exception &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dest)); int by = 0; while ((by = bis.read()) != -1) &#123; bos.write(by); &#125; bis.close(); bos.close(); &#125; // 高效字节流一次读写一个字节数组： public static void method4(String src, String dest) throws Exception &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dest)); int len = 0; byte[] bys = new byte[1024]; while ((len = bis.read(bys)) != -1) &#123; bos.write(bys, 0, len); &#125; bis.close(); bos.close(); &#125;&#125; 这里我们的目的是利用IO流将E盘根目录下的music.mp3文件拷贝到项目工程目录下，前面说了，拷贝音乐文件用字节流，这里提供了四种拷贝方式，可以比较拷贝所需时间，其中第一种方式(基本字节流一次读写一个字节 )最慢，第四种（高效字节流一次读写一个字节数组）最快，中间两种差不多。 说一下这里的BufferedInputStream是输入流（对应的输出流BufferedOutputStream）的缓冲流，又称装饰流，一般我们建议在基本流外面包上装饰流，因为这样可极大提升效率。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//字符流读写数据的五种方式public class CopyTxtDemo &#123; public static void main(String[] args) throws IOException &#123; String SrcString = &quot;a.txt&quot;; String DestString = &quot;b.txt&quot;; // method1(SrcString,DestString); // method3(SrcString,DestString); // method4(SrcString,DestString); method5(SrcString, DestString); &#125; // 基本字符流一次读写一个字符 private static void method1(String srcString, String destString) throws IOException &#123; FileReader fr = new FileReader(srcString); FileWriter fw = new FileWriter(destString); int len = 0; while ((len = fr.read()) != -1) &#123; fw.write(len); &#125; fr.close(); fw.close(); &#125; // 基本字符流一次读写一个字符数组 private static void method2(String srcString, String destString) throws IOException &#123; FileReader fr = new FileReader(srcString); FileWriter fw = new FileWriter(destString); char[] chs = new char[1024]; int len = 0; while ((len = fr.read(chs)) != -1) &#123; fw.write(chs, 0, len); &#125; fr.close(); fw.close(); &#125; // 高效字符流一次读写一个字符 private static void method3(String srcString, String destString) throws IOException &#123; BufferedReader br = new BufferedReader(new FileReader(srcString)); BufferedWriter bw = new BufferedWriter(new FileWriter(destString)); int len = 0; while ((len = br.read()) != -1) &#123; bw.write(len); &#125; br.close(); bw.close(); &#125; // 高效字符流一次读写一个字符数组 private static void method4(String srcString, String destString) throws IOException &#123; BufferedReader br = new BufferedReader(new FileReader(srcString)); BufferedWriter bw = new BufferedWriter(new FileWriter(destString)); char[] chs = new char[1024]; int len = 0; while ((len = br.read(chs)) != -1) &#123; bw.write(chs, 0, len); &#125; br.close(); bw.close(); &#125; // 高效字符流一次读写一行 private static void method5(String srcString, String destString) throws IOException &#123; BufferedReader br = new BufferedReader(new FileReader(srcString)); BufferedWriter bw = new BufferedWriter(new FileWriter(destString)); String len = null; while ((len = br.readLine()) != null) &#123; bw.write(len); bw.newLine(); bw.flush(); &#125; br.close(); bw.close(); &#125;&#125; 上面代码的目的是将项目工程下的“a.txt”文件拷贝到b.txt里。前面说了拷贝文本文件用字符流。前四种拷贝方式就不说了，跟字节流差不多，第五种比较特殊，一次读写一行。 注意：上述代码最好加上try–catch，并在finally里关闭流。如下： 12345678910111213141516171819202122public static void method3(String src, String dest) throws Exception &#123; BufferedInputStream bis =null; BufferedOutputStream bos = null; try &#123; bis = new BufferedInputStream(new FileInputStream(src)); bos = new BufferedOutputStream(new FileOutputStream(dest)); int by = 0; while ((by = bis.read()) != -1) &#123; bos.write(by); &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; bos.close(); bis.close(); &#125; &#125;","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"java","slug":"java","permalink":"http://qiracle.github.io/tags/java/"}]},{"title":"Android 中的jar包，aar包以及module","slug":"20181028","date":"2018-10-27T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2018/10/28/20181028/","link":"","permalink":"http://qiracle.github.io/2018/10/28/20181028/","excerpt":"Android Studio中引入第三方资源一般有三种方式：jar包，aar包，module. 1.jar包的导入 第一种：一般用于比较流行的第三方库上，直接将你在GitHub上看到的jar包compile放入build.gradle的dependencies里面，然后sync同步一下就可以了。例如：导入v7包。","text":"Android Studio中引入第三方资源一般有三种方式：jar包，aar包，module. 1.jar包的导入 第一种：一般用于比较流行的第三方库上，直接将你在GitHub上看到的jar包compile放入build.gradle的dependencies里面，然后sync同步一下就可以了。例如：导入v7包。1234dependencies&#123;......compile ‘com.android.support:appcompat-v7:24.2.1’&#125; 第二种：我们已经从网上下好了（或者别人给你的）jar，需要将他导入到AS工程里，首先将jar包放到libs里面，然后还是在build.gradle的dependencies里面添加compile路径，最后sync一下。例如：导入volley。1234dependencies&#123;.....compile files(‘libs/volley.jar’)&#125; 2.aar包导入aar包是Android特有的一种引用包，Android Archive，它跟jar包的区别在于：jar包：只包含class文件和清单文件，不包含资源文件，比如图片等所有的 res下的资源文件；aar包：class以及res下的所有的资源文件全部包含。aar包的引用也很简单，以上是一个正常的module（工程应用，而非作为第三方library使用的）引用aar文件为例，首先也是将拿到的aar包放进libs下。然后按如下配置，最后sync一下就可以了，列如，导入一个叫abc.aar的包：12345repositories &#123; flatDir &#123; dirs &apos;libs&apos; &#125; &#125; // 此在android标签下添加 1234dependencies &#123;..... compile(name: &apos;abc.aar, ext: &apos;aar&apos;)&#125; 注意，以上是一个正常的module（工程应用，而非作为第三方library使用的）引用aar文件需要配置的步骤。 下面说一下当一个library类型的module需要引用aar文件时：a.在该library中按照上面的代码，在library的module下的bulid.gradle中配置。 b.任何依赖此library的module必须声明在它的build.gradle声明此 aar 的 lib 所在的位置，这个位置根据文件路径所确定 1234567android&#123; //android节点下配置 repositories &#123; flatDir &#123; dirs &apos;libs&apos;, &apos;../../../../library_module/libs&apos; &#125; &#125;&#125; c. 配置完b步骤后，还要在project的build.gradle文件中配置，如下:12345678allprojects &#123; repositories &#123; jcenter() flatDir &#123; dirs &apos;../../../library_module/libs&apos; &#125; &#125;&#125; 梳理一下这里的依赖关系：aar-&gt;library module-&gt;依赖此library的module-&gt;project 3.module的导入module的导入在上一篇博客中Android Studio中module的导入 已经讲过。这里主要说一下module是可以打包成aar包的，通过gradle的assembeRelease或assembleDebug可以将module打包成aar包（分别对应release版本和debug版本）。另外，笔者曾经遇到一个大坑，那就是当aar包引用第三方module的时候，编译不会报错，但是运行时会一直报类找不到的错误，因为在打包aar包时不会将第三方module打包进aar包里面。这里如果将第三方module先打包成aar包，给工程调用就不会出现这样的问题了。","categories":[{"name":"教程","slug":"教程","permalink":"http://qiracle.github.io/categories/教程/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiracle.github.io/tags/Android/"}]},{"title":"Android Studio 导入 module","slug":"20181021","date":"2018-10-20T16:00:00.000Z","updated":"2019-10-26T07:22:14.195Z","comments":true,"path":"2018/10/21/20181021/","link":"","permalink":"http://qiracle.github.io/2018/10/21/20181021/","excerpt":"在当前工程里，点击 File-&gt;New-&gt;import module. 在弹出的对话框里选择需要导入的 module 的路径。这里将 module 名字改成了 :mylib .","text":"在当前工程里，点击 File-&gt;New-&gt;import module. 在弹出的对话框里选择需要导入的 module 的路径。这里将 module 名字改成了 :mylib . 这一步之后会在主工程的build.gradle生成如下代码： 这里原本是 compile project(path: ‘:mylib’)。 但是我这里的gradle是3之后的版本，所以需要将compile替换成implementation。 2.如果导入的 mylib 之前是一个工程应用，则需要更改 mylib 里的 build.gradle。具体修改如下： 需要将图中的 com.android.application 改成 com.android.library 以及删除applicationId这一行。 改完后记得sync一下。 3.修改主工程下的 setting.gradle. 添加如下： 同样改完之后sync一下。 这样，module的导入就完成了，我们可以试试调用module里的方法。","categories":[{"name":"教程","slug":"教程","permalink":"http://qiracle.github.io/categories/教程/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiracle.github.io/tags/Android/"}]},{"title":"Android 混淆机制","slug":"20181014","date":"2018-10-13T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2018/10/14/20181014/","link":"","permalink":"http://qiracle.github.io/2018/10/14/20181014/","excerpt":"什么是混淆 按照我的个人理解，混淆就是将代码里的包名，类名，方法名，变量名等用无意义的a，b，c等字母代替。这样做的目的是为了防止他人获取你的apk后可以轻松的反编译并读取你的源码，而加入混淆之后，反编译出的源码是很难被读懂的。详细解释可参考Android混淆是什么 。","text":"什么是混淆 按照我的个人理解，混淆就是将代码里的包名，类名，方法名，变量名等用无意义的a，b，c等字母代替。这样做的目的是为了防止他人获取你的apk后可以轻松的反编译并读取你的源码，而加入混淆之后，反编译出的源码是很难被读懂的。详细解释可参考Android混淆是什么 。 如何打开混淆在Android Studio工程下，找到app目录下的build.gradle. 然后将minifyEnabled设置为true即可。如下：1234release&#123; minifyEnabled true//是否启动混淆 ture:打开 false:关闭 proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; 这里的proguard-android.txt是混淆规则，里面定义的是哪些东西不能被混淆。proguard-android.txt存在于app目录下。在做混淆时我们只需把我们定义的混淆规则写在里面即可。 混淆模板下面是一个混淆模板，网上类似的模板有很多：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199##-------------------------------------------基本不用动区域----------------------------------------------### -----------------------------基本 -----------------------------## 指定代码的压缩级别 0 - 7(指定代码进行迭代优化的次数，在Android里面默认是5，这条指令也只有在可以优化时起作用。)-optimizationpasses 5# 混淆时不会产生形形色色的类名(混淆时不使用大小写混合类名)-dontusemixedcaseclassnames# 指定不去忽略非公共的库类(不跳过library中的非public的类)-dontskipnonpubliclibraryclasses# 指定不去忽略包可见的库类的成员-dontskipnonpubliclibraryclassmembers#不进行优化，建议使用此选项，-dontoptimize # 不进行预校验,Android不需要,可加快混淆速度。-dontpreverify# 屏蔽警告-ignorewarnings# 指定混淆是采用的算法，后面的参数是一个过滤器# 这个过滤器是谷歌推荐的算法，一般不做更改-optimizations !code/simplification/arithmetic,!field/*,!class/merging/*# 保护代码中的Annotation不被混淆-keepattributes *Annotation*# 避免混淆泛型, 这在JSON实体映射时非常重要-keepattributes Signature# 抛出异常时保留代码行号-keepattributes SourceFile,LineNumberTable #优化时允许访问并修改有修饰符的类和类的成员，这可以提高优化步骤的结果。# 比如，当内联一个公共的getter方法时，这也可能需要外地公共访问。# 虽然java二进制规范不需要这个，要不然有的虚拟机处理这些代码会有问题。当有优化和使用-repackageclasses时才适用。#指示语：不能用这个指令处理库中的代码，因为有的类和类成员没有设计成public ,而在api中可能变成public-allowaccessmodification#当有优化和使用-repackageclasses时才适用。-repackageclasses &apos;&apos; # 混淆时记录日志(打印混淆的详细信息) # 这句话能够使我们的项目混淆后产生映射文件 # 包含有类名-&gt;混淆后类名的映射关系-verbose## ----------------------------- 默认保留 -----------------------------##----------------------------------------------------# 保持哪些类不被混淆#继承activity,application,service,broadcastReceiver,contentprovider....不进行混淆-keep public class * extends android.app.Activity-keep public class * extends android.app.Application-keep public class * extends android.support.multidex.MultiDexApplication-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep public class * extends android.content.ContentProvider-keep public class * extends android.app.backup.BackupAgentHelper-keep public class * extends android.preference.Preference-keep public class * extends android.view.View-keep class android.support.** &#123;*;&#125;## 保留support下的所有类及其内部类-keep public class com.google.vending.licensing.ILicensingService-keep public class com.android.vending.licensing.ILicensingService#表示不混淆上面声明的类，最后这两个类我们基本也用不上，是接入Google原生的一些服务时使用的。#----------------------------------------------------# 保留继承的-keep public class * extends android.support.v4.**-keep public class * extends android.support.v7.**-keep public class * extends android.support.annotation.**#表示不混淆任何包含native方法的类的类名以及native方法名，这个和我们刚才验证的结果是一致-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125;#这个主要是在layout 中写的onclick方法android:onclick=&quot;onClick&quot;，不进行混淆#表示不混淆Activity中参数是View的方法，因为有这样一种用法，在XML中配置android:onClick=”buttonClick”属性，#当用户点击该按钮时就会调用Activity中的buttonClick(View view)方法，如果这个方法被混淆的话就找不到了-keepclassmembers class * extends android.app.Activity&#123; public void *(android.view.View);&#125;#表示不混淆枚举中的values()和valueOf()方法，枚举我用的非常少，这个就不评论了-keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125;#表示不混淆任何一个View中的setXxx()和getXxx()方法，#因为属性动画需要有相应的setter和getter的方法实现，混淆了就无法工作了。-keep public class * extends android.view.View&#123; *** get*(); void set*(***); public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);&#125;-keepclasseswithmembers class * &#123; public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);&#125;#表示不混淆Parcelable实现类中的CREATOR字段，#毫无疑问，CREATOR字段是绝对不能改变的，包括大小写都不能变，不然整个Parcelable工作机制都会失败。-keep class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator *;&#125;# 这指定了继承Serizalizable的类的如下成员不被移除混淆-keepclassmembers class * implements java.io.Serializable &#123; static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve();&#125;# 保留R下面的资源#-keep class **.R$* &#123;# *;#&#125;#不混淆资源类下static的-keepclassmembers class **.R$* &#123; public static &lt;fields&gt;;&#125;# 对于带有回调函数的onXXEvent、**On*Listener的，不能被混淆-keepclassmembers class * &#123; void *(**On*Event); void *(**On*Listener);&#125;# 保留我们自定义控件（继承自View）不被混淆-keep public class * extends android.view.View&#123; *** get*(); void set*(***); public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);&#125;##----------------------------- WebView(项目中没有可以忽略) -----------------------------##webView需要进行特殊处理-keepclassmembers class fqcn.of.javascript.interface.for.Webview &#123; public *;&#125;-keepclassmembers class * extends android.webkit.WebViewClient &#123; public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap); public boolean *(android.webkit.WebView, java.lang.String);&#125;-keepclassmembers class * extends android.webkit.WebViewClient &#123; public void *(android.webkit.WebView, jav.lang.String);&#125;#在app中与HTML5的JavaScript的交互进行特殊处理#我们需要确保这些js要调用的原生方法不能够被混淆，于是我们需要做如下处理：-keepclassmembers class com.ljd.example.JSInterface &#123; &lt;methods&gt;;&#125;##---------------------------------实体类---------------------------------#--------(实体Model不能混淆，否则找不到对应的属性获取不到值)-----#-dontwarn com.suchengkeji.android.confusiondemo.md.**#对含有反射类的处理-keep class com.suchengkeji.android.confusiondemo.md.** &#123; *; &#125;## ----------------------------- 其他的 -----------------------------## 删除代码中Log相关的代码-assumenosideeffects class android.util.Log &#123; public static boolean isLoggable(java.lang.String, int); public static int v(...); public static int i(...); public static int w(...); public static int d(...); public static int e(...);&#125;# 保持测试相关的代码-dontnote junit.framework.**-dontnote junit.runner.**-dontwarn android.test.**-dontwarn android.support.test.**-dontwarn org.junit.**## ----------------------------- 第三方 -----------------------------#-dontwarn com.orhanobut.logger.**-keep class com.orhanobut.logger.**&#123;*;&#125;-keep interface com.orhanobut.logger.**&#123;*;&#125;-dontwarn com.google.gson.**-keep class com.google.gson.**&#123;*;&#125;-keep interface com.google.gson.**&#123;*;&#125; Proguard关键字及作用dontwarn dontwarn是一个和keep可以说是形影不离,尤其是处理引入的library时.keep 保留类和类中的成员，防止被混淆或移除keepnames 保留类和类中的成员，防止被混淆，成员没有被引用会被移除keepclassmembers 只保留类中的成员，防止被混淆或移除keepclassmembernames 只保留类中的成员，防止被混淆，成员没有引用会被移除keepclasseswithmembers 保留类和类中的成员，防止被混淆或移除，保留指明的成员keepclasseswithmembernames 保留类和类中的成员，防止被混淆，保留指明的成员，成员没有引用会被移除 常见用法(1)保留某个包下面的类以及子包下面的类.1-keep public class cn.qiracle.** 注意两个号表示当前包下及该包的所有子包下的类都不被混淆。一个只表示当前包下的类不被混淆。 (2)保留所有类中使用otto的public方法12345# Otto-keepclassmembers class ** &#123; @com.squareup.otto.Subscribe public *; @com.squareup.otto.Produce public *;&#125; (3)保留Contants类的BOOK_NAME属性123-keepclassmembers class com.example.admin.proguardsample.Constants &#123; public static java.lang.String BOOK_NAME;&#125; (4)dontwarn：引入的library可能存在一些无法找到的引用和其他问题,在build时可能会发出警告,如果我们不进行处理,通常会导致build中止.因此为了保证build继续,我们需要使用dontwarn处理这些我们无法解决的library的警告.比如关闭Twitter sdk的警告,我们可以这样做1-dontwarn com.twitter.sdk.** (5)保留一个类及其子类不被混淆1-keep public class * extends android.app.Activity 哪些类不能被混淆使用了自定义控件那么要保证它们不参与混淆使用了枚举要保证枚举不被混淆对第三方库中的类不进行混淆运用了反射的类也不进行混淆使用了 Gson 之类的工具要使 JavaBean 类即实体类不被混淆在引用第三方库的时候，一般会标明库的混淆规则的，建议在使用的时候就把混淆规则添加上去，免得到最后才去找有用到 WebView 的 JS 调用也需要保证写的接口方法不混淆，原因和第一条一样Parcelable 的子类和 Creator 静态成员变量不混淆，否则会产生 Android.os.BadParcelableException 异常使用的四大组件，自定义的Application* 实体类JNI中调用的类Layout布局使用的View构造函数（自定义控件）、android:onClick等。 参考文章： https://www.jianshu.com/p/b5b2a5dfaaf4","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiracle.github.io/tags/Android/"}]},{"title":"加密算法与HTTPS","slug":"20180328","date":"2018-03-27T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2018/03/28/20180328/","link":"","permalink":"http://qiracle.github.io/2018/03/28/20180328/","excerpt":"原文来自: 也许，这样理解HTTPS更容易 能不能用一句话总结HTTPS？答案是不能，因为HTTPS本身实在太复杂。但是我还是尝试使用一段话来总结HTTPS: HTTPS要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。","text":"原文来自: 也许，这样理解HTTPS更容易 能不能用一句话总结HTTPS？答案是不能，因为HTTPS本身实在太复杂。但是我还是尝试使用一段话来总结HTTPS: HTTPS要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。","categories":[{"name":"转载","slug":"转载","permalink":"http://qiracle.github.io/categories/转载/"}],"tags":[{"name":"HTTPS","slug":"HTTPS","permalink":"http://qiracle.github.io/tags/HTTPS/"}]},{"title":"Android 系统 Settings 启动流程详解","slug":"20170810","date":"2017-08-09T16:00:00.000Z","updated":"2019-10-26T07:21:44.434Z","comments":true,"path":"2017/08/10/20170810/","link":"","permalink":"http://qiracle.github.io/2017/08/10/20170810/","excerpt":"Settings简介 Settings 是 Android 系统自带的一个很重要的应用，给用户提供了操作 Android 系统功能的界面。它里面包含了 Wireless &amp; network，device，personal 以及 system 等几大块的功能设置。在 Android 源码中，该应用位于 packages/apps/Settings 下。该应用的源码是相当复杂的，设计思想很是先进，很难完全讲清楚，笔者也是读了好几遍源码再综合了几篇博客才勉强懂了Settings其启动流程的大体思路。通过博客记录下来以加深理解和印象，同时分享给大家。","text":"Settings简介 Settings 是 Android 系统自带的一个很重要的应用，给用户提供了操作 Android 系统功能的界面。它里面包含了 Wireless &amp; network，device，personal 以及 system 等几大块的功能设置。在 Android 源码中，该应用位于 packages/apps/Settings 下。该应用的源码是相当复杂的，设计思想很是先进，很难完全讲清楚，笔者也是读了好几遍源码再综合了几篇博客才勉强懂了Settings其启动流程的大体思路。通过博客记录下来以加深理解和印象，同时分享给大家。 Settings 启动流程详解1.直接跳转子界面 首先找到 Settings 目录，其目录结构如下，文件太多，无法完展开。 这里通过每个文件夹的命名可以大概知道，每个包的大体作用是什么。由于本文主要讲解启动流程，所以先不管这些。我们先找到 Settings 的启动类，通常我们可以从清单文件中得知该应用的启动类，如下图： 从图中可以清楚的看到，Settings 的启动类为 Settings。从 Settings 源码中我们找到了Settings.java文件。但是，打开这个文件后，会感到了一脸懵逼。如下图： 该类中都是些空实现的静态内部类，没有任何与界面加载相关的内容。这是为什么呢？看上面有句英文注释就明白了，意思是这些子类是为了启动特定独立的 Settings 选项而创建的，例如在某个应用里需要设置无线那么只需要启动无线对应的类就可以了，而没必要打开settings应用再点击wifi设置项进行设置。再看此类继承于 SettinggsActivity，这时我们就应该可以想到，初始化界面应该在它父类 SettinggsActivity 里完成的。为了方便讲解，我们先以wifi设置页面WifiSettingsActivity 的直接跳转为例，详细讲解这个启动流程。懂了这个之后，其他子页面的启动自然就明白了。 接下来我们在清单文件中找到 WifiSettingsActivity 的定义如下： 其中有 meta-data 的标签使用，从这个标签的 key-value 来看，很明显可以认为WifiSettings的具体实现应该是由 WifiSettings 这个 Fragment 来布局渲染的。然后我们回到 SettingsActivity 中，找到 onCreate() 方法如下： 可以看到，一进入 oncreate 里有个 getMetaData(), 这和我们之前看到的清单文件里的meta似乎有某种联系，点进去看，代码如下： 可以看到，这个函数的主要作用就是从 Activity 标签中获取 meta-data 标签中key为 com.android.settings.FRAGMENT_CLASS 的值，并将其赋值给 mFragmentClass 这个私有变量。以 WifiSettingsActivity为 例，从这个 Activity 中 meta-data 标签中获取的信息为 com.android.settings.wifi.WifiSettings，即mFragmentClass=”com.android.settings.wifi.WifiSettings”。getMetaData() 执行完后紧接着执行了 getIntent()，getMetaData() 上面有句注释 should happen before any call to getIntent。意思是 getIntent() 必须在 getMetaData() 之后执行，其实这也有原因的，点进 getIntent() 方法看看就知道了。代码具体如下： 继续看 getStartingFragmentClass()： 从源码看以看出，getIntent 的作用就是构造了一个 Intent，并且给它增加了一个特殊的键值对，key为”:settings:show_fragment”，value为 mFragmentClass 指定的 Fragment 类名。之所以要先执行getMetaData，是因为 mFragmentClass 赋值是在 getMeatData 中进行的。 明白之后我们继续分析onCreate()方法： 1234567891011121314151617181920212223242526final ComponentName cn = intent.getComponent(); final String className = cn.getClassName();// 本例中，className为WifiSettingsActivitymIsShowingDashboard = className.equals(Settings.class.getName()); //因此这里为false ... ... setContentView(mIsShowingDashboard ? R.layout.settings_main_dashboard : R.layout.settings_main_prefs);//本例中这里选择了后者 ... ... &#125; else &#123; if (!mIsShowingDashboard) &#123;//因为mIsShowingDashboard为false，所以会到这里 ....//initialArguments通过赋值保存了meta-data中指定的com.android.settings.wifi.WifiSettings Bundle initialArguments = intent.getBundleExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS); switchToFragment(initialFragmentName, initialArguments, true, false, mInitialTitleResId, mInitialTitle, false);//走到这里进行fragment替换 &#125; else &#123; // No UP affordance if we are displaying the main Dashboard mDisplayHomeAsUpEnabled = false; // Show Search affordance mDisplaySearch = true; mInitialTitleResId = R.string.dashboard_title; switchToFragment(DashboardSummary.class.getName(), null, false, false, mInitialTitleResId, mInitialTitle, false); &#125; &#125; 我们来具体看一下 switchToFragment() 方法： 通过 FragmentTransaction 的 replace 方法，将Fragment的布局在 R.id.main_content 指定的位置进行渲染。 2.主界面启动流程上面讲的是没有通过点击 Settings 主界面的选项而直接打开子界面的启动过程，下面我们介绍通过点击setting主界面的选项进入子界面的过程。 通过前面的讲解我们知道，mIsShowingDashboard 的值( true/false )是确实加载主界面还是子界面的唯一条件。我们回到相关代码： 12345678910111213141516171819202122232425final ComponentName cn = intent.getComponent(); final String className = cn.getClassName();// 因为从主界面启动，所以这里className为SettingsmIsShowingDashboard = className.equals(Settings.class.getName()); //因此这里变成了true ... ... setContentView(mIsShowingDashboard ? R.layout.settings_main_dashboard : R.layout.settings_main_prefs);//选择了前者 ... ... &#125; else &#123; if (!mIsShowingDashboard) &#123;//因为mIsShowingDashboard为true，不走这里了 .... Bundle initialArguments = intent.getBundleExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS); switchToFragment(initialFragmentName, initialArguments, true, false, mInitialTitleResId, mInitialTitle, false);// &#125; else &#123;//从主界面进入，走这里 // No UP affordance if we are displaying the main Dashboard mDisplayHomeAsUpEnabled = false; // Show Search affordance mDisplaySearch = true; mInitialTitleResId = R.string.dashboard_title; switchToFragment(DashboardSummary.class.getName(), null, false, false, mInitialTitleResId, mInitialTitle, false);//接下来重点分析这里 &#125; &#125; 从上面分析可以知道如果从主界面进入的话 switchToFragment 会将当前页面替换成 DashboardSummary，我们看一下 DashboardSummary.java 的代码： 这是一个 fragment,在 onCreateView 里,填充了 dashboard.xml. 来看一下这个布局： 这是一个垂直可滚动的线性结构，很容易联想到我们手机里的设置主页面，的确如此。再继续看DashboardSummary 代码，在 onResume() 里： 有 SendReBuildUI(),点进去查看： 原来里面是在发消息，找到消息的接收者： 终于发现了里面的 reBuildUI 的方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private void rebuildUI(Context context) &#123; if (!isAdded()) &#123; Log.w(LOG_TAG, &quot;Cannot build the DashboardSummary UI yet as the Fragment is not added&quot;); return; &#125; long start = System.currentTimeMillis(); final Resources res = getResources(); mDashboard.removeAllViews(); //(1)这里调用SettingActivity的getDashboardCategories,也就是加载整个Setting的内容 List&lt;DashboardCategory&gt; categories = ((SettingsActivity) context).getDashboardCategories(true);//注意该方法 final int count = categories.size(); for (int n = 0; n &lt; count; n++) &#123; DashboardCategory category = categories.get(n); View categoryView = mLayoutInflater.inflate(R.layout.dashboard_category, mDashboard, false); TextView categoryLabel = (TextView) categoryView.findViewById(R.id.category_title); categoryLabel.setText(category.getTitle(res)); ViewGroup categoryContent = (ViewGroup) categoryView.findViewById(R.id.category_content); final int tilesCount = category.getTilesCount(); for (int i = 0; i &lt; tilesCount; i++) &#123; DashboardTile tile = category.getTile(i);//（2）创建DashboardTileView，也就是每个Setting的内容 DashboardTileView tileView = new DashboardTileView(context); updateTileView(context, res, tile, tileView.getImageView(), tileView.getTitleTextView(), tileView.getStatusTextView()); tileView.setTile(tile); categoryContent.addView(tileView); &#125; // Add the category mDashboard.addView(categoryView); &#125; long delta = System.currentTimeMillis() - start; Log.d(LOG_TAG, &quot;rebuildUI took: &quot; + delta + &quot; ms&quot;); &#125; 接下来对上面两处注释进行说明：(1)处 rebuildUI 里调用 getDashboardCategories() 方法，该方法如下： 这个方法里又调用了 buildDashboardCategories() 方法： 看到这里终于明白了，里面有个对 dashboard_categories.xml 的处理, loadCategoriesFromResource() 方法就不看了，它的作用是解析 dashboard_categories.xml 这个 xml 文件。我们看一下dashboard_categories.xml 吧： 部分截图，没有截图，因为内容太多了。不过从这局部就可以看出这对应的就是我们设置主页面的各个选项。 （2）处将通过 for 循环遍历而来的数据通过创建 DashboardTileView 最终全部存入到 mDashboard 这个布局中，至此整个 Setting 模块的界面布局已经完成了。 在 DashboardTileView.java 里，有个 onclick 方法，这就是 settings 主页面每个子选项的点击事件了，通过点击进入不同的子设置选项，如 wifi，蓝牙等。 至此，Settings 的启动方式讲解完了，下面附一张自己手画的一张 Settings 启动流程的草图，画的比较丑，凑合的看….: 参考文章：http://www.itdadao.com/articles/c15a227784p0.htmlhttp://blog.csdn.net/wzy_1988/article/details/50556113","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiracle.github.io/tags/Android/"}]},{"title":"记一个实用的git命令---谁动了我的代码","slug":"20170809","date":"2017-08-08T16:00:00.000Z","updated":"2019-10-26T07:21:23.692Z","comments":true,"path":"2017/08/09/20170809/","link":"","permalink":"http://qiracle.github.io/2017/08/09/20170809/","excerpt":"应用场景我们在做公司的项目的时候，代码都是大家共同编写的，通过git仓库进行管理。然而有的时候，我们写的代码会被别人修改了，而别人又没有加注释说明是某某人什么时候修改的什么功能。这时候你又想对曾经自己写的这块代码进行修改，但是你对他的代码不是很明白或者对需求不是很理解。这时最好的解决方法就是找到这个人问明白，最常见的方法是，通过git log查看提交记录，查出这笔提交的owner，但是如果是很久之前的提交，要找出来未免有些太慢了。有没有什么好的方法呢？","text":"应用场景我们在做公司的项目的时候，代码都是大家共同编写的，通过git仓库进行管理。然而有的时候，我们写的代码会被别人修改了，而别人又没有加注释说明是某某人什么时候修改的什么功能。这时候你又想对曾经自己写的这块代码进行修改，但是你对他的代码不是很明白或者对需求不是很理解。这时最好的解决方法就是找到这个人问明白，最常见的方法是，通过git log查看提交记录，查出这笔提交的owner，但是如果是很久之前的提交，要找出来未免有些太慢了。有没有什么好的方法呢？有，可以用git命令 —–git blame。 git blame用法git blame +文件名，就可以显示出这该文件里每行代码的详细提交信息。放张图感受一下： 从图中可以看到，第一列为commit id，第二列为提交者username，第三列为时间日期，第四列为所在行数，第五列为提交内容。文件中的每一行提交信息一目了然，通过这个命令我们可以很快的找到每行代码的修改提交者。如果文件里行数过多，不想一直往下翻了可以结合grep命令一起用：git blame fileName | grep “line number”。可直接显示你想要看的那一行的提交者信息。–","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"git","slug":"git","permalink":"http://qiracle.github.io/tags/git/"}]},{"title":"史上最详细的Android系统SystemUI 启动过程详细解析","slug":"20170728","date":"2017-07-27T16:00:00.000Z","updated":"2019-10-26T07:21:11.667Z","comments":true,"path":"2017/07/28/20170728/","link":"","permalink":"http://qiracle.github.io/2017/07/28/20170728/","excerpt":"Android 系统 SystemUI 介绍 Android 的 SystemUI 其实就是 Android 的系统界面，它包括了界面上方的状态栏 status bar，下方的导航栏Navigation Bar，锁屏界面 Keyguard ，电源界面 PowerUI，近期任务界面 Recent Task 等等。对于用户而言，SystemUI 的改动是最能直观感受到的。因此，每个 Android 版本在 SystemUI 上都有比较大的改动。而对开发者而言，理解 Android SystemUI 对优化Android系统界面，改善用户体验十分重要。","text":"Android 系统 SystemUI 介绍 Android 的 SystemUI 其实就是 Android 的系统界面，它包括了界面上方的状态栏 status bar，下方的导航栏Navigation Bar，锁屏界面 Keyguard ，电源界面 PowerUI，近期任务界面 Recent Task 等等。对于用户而言，SystemUI 的改动是最能直观感受到的。因此，每个 Android 版本在 SystemUI 上都有比较大的改动。而对开发者而言，理解 Android SystemUI 对优化Android系统界面，改善用户体验十分重要。 SystemUI 在哪 在 Andorid 系统源码中，package/apps下放的是系统内置的一些 app，例如 settings，camera，Phone，Message 等等。而在 Framework/base/package 下，它们也是系统的 app，SystemUI 就在此目录下。它控制着整个Android系统的界面，但其实他也是一个 app，不同于一般的 app，它不可卸载也不可以被第三方应用替换。 SystemUI 整体结构 这是 SystemUI 相关类的继承关系图，可以看到 SystemUI 为基类，每个子类实现了不同的系统界面。 Status Bar 系统上方的状态栏 Navigator Bar 系统下方的导航栏 Keyguard 锁屏界面 PowerUI 电源界面 Recents Screen 近期任务界面 VolumeUI 音量调节对话框 Stack Divider 分屏功能调节器 PipUI 画中画界面 Screenshot 截屏界面 RingtonePlayer 铃声播放器界面 Settings Activity 系统设置中用到的一些界面，例如：NetworkOverLimitActivity，UsbDebuggingActivity等。 SystemUI的启动流程先找到 framework/base/service/java/com/android/server/SystemServer.java 文件，里面有个main()方法，main 方法如下： public static void main（String[] args）{ new SystemServer().run() } main 方法里启动了 run() 方法，而在 run 方法中调用了 startBootstrapServices() 方法和 startOtherServices() 方法，在 startOtherServices() 里 mActivityManagerService.systemReady 创建线程去执行startSystemUi(context），这里将启动 SystemUI。具体方法如下： 然后我们进入设置启动 systemui 程序的 SystemUIService 文件里，该文件在framework/base/packages/SystemUI/src/com/android/systemui/SystemUIService.java.我们看该文件的onCreate() 方法。方法如下： 可以看到有一句 ((SystemUIApplication) getApplication()).startServicesIfNeeded()，这句很关键，我们再进入 startServicesIfNeeded()，看看具体是如何启动系统服务的。该方法如下： 其中有一个 for 循环，循环里第一句就是将 service[i] 赋值给 cl， 那么service里存的是什么呢？找到 service[i] 的赋值如下： 看到这里我们就明白了，这里是拿到每个和 SystemUI 相关的类的反射，存到了 service[] 里，然后赋值给cl，紧接着将通过反射将其转化为具体类的对象，存到了mService[i]数组里，最后对象调 start() 方法启动相关类的服务，启动完成后，回调 onBootCompleted( ) 方法。 mService[i] 里的值不同时，调用的 start() 方法也不相同，这里我们以S ystemBars 的 start() 为例，所以mService[i].start() 先认为是 SystemBars.start(). SystemBars.java 位于framework/base/packages/SystemUI/res/com/android/systemui/statusbar/SystemBars.java ，找到 start() 方法： 这里调用了 mServiceMonitor.start()，旁边注释说的很清楚如果服务没有启动的话就调用onNoService()方法，进入 onNoService() 方法，该方法就位于 start() 方法下方，可以看到方法中调用了CreateStatusBarFromConfig() 该方法如下： 从中可以知道，该方法中先读取 value/config.xml 文件中 config_statusBarComponent 的值,这里为：com.android.systemui.statusbar.phone.PhoneStatusBar，然后通过反射得到了 PhoneStatusBar 对象，最后的 mStartus.start() 也就等于 PhoneStatusBar.start()，进入该方法，会发现，里面调用了super.start()，也就是先执行了父类的 start() ,其父类为 BaseStatusBar，该类的star()方法较多，就不放出来了，我们看重点，找到里面有调用一个 createAndAddWindows()，该方法为抽象方法，则会调用它的子类的方法，这里也就是 PhoneStatusBar 的 createAndAddWindows()方法，如下： createAndAddWindows() 里只调用了 addStaBarWindow() 方法，而在该方法里，调用了makeStartusBarView，看名字就知道该方法关键，意为构建statusBar视图。该方法很长，里面有inflateStatusBarWindow()，进入该方法，可以看到，这么一句： 然后，我们通过 super_status_bar.xml 的分析 SystemBars 的大致视图构成了，super_status_bar.xml 代码如下： super_status_bar.xmlsuper_status_bar.xml 中 include 了一个名称为 status_bar 的布局文件super_status_bar.xml*中 include 了一个名称为 status_bar_expanded 的布局文件这里的 status_bar 便是系统状态栏的布局文件，status_bar_expanded 便是下拉的通知窗口的布局文件上述 super_status_bar.xml 与如下视图对应： PhoneStatusBarView 即为手机最上方的状态栏，主要用于显示系统状态，通知等，主要包括 notification icons 和 status bar icons。status_bar.xml 即对应状态栏的视图如下： PanelHolderPanelHolder是用户下拉 status bar 后得到的 view。它主要包含 QuickSettings 和 Notification panel 两个部分。PanelHolder是一个继承自 FrameLayout的自定义 view,它的内容是通过 include status_bar_expanded.xml进行填充的。PanelHolder的布局比较复杂，为了提高 view 的重用性大量的使用了 include 标签。status_bar_expanded.xml 对应的视图： KeyguardBouncerKeyguardBouncer是锁屏解锁界面，根据用户设置的解锁方式不同，展示不同的解锁模式。keyguard_bouncer.xml 对应的 KerguardBouncer 视图： 附：SystemUI启动流程图： 参考文章：http://www.jianshu.com/p/0ab1279465fahttp://qiangbo.space/2017-05-09/AndroidAnatomy_SystemUI_Intro/http://qiangbo.space/2017-06-04/AndroidAnatomy_SystemUI_Bar/http://www.open-open.com/lib/view/open1494316049681.html","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiracle.github.io/tags/Android/"}]},{"title":"Python中的高阶函数","slug":"20170710","date":"2017-07-09T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2017/07/10/20170710/","link":"","permalink":"http://qiracle.github.io/2017/07/10/20170710/","excerpt":"1.python把函数作为参数import math def f(x,y) return (x+y)+x*y def add(x, y, f): return f(x,y) print add(4, 9, f) 参数f接收一个函数名，根据f的定义不同，可得到不同的值。","text":"1.python把函数作为参数import math def f(x,y) return (x+y)+x*y def add(x, y, f): return f(x,y) print add(4, 9, f) 参数f接收一个函数名，根据f的定义不同，可得到不同的值。 2.python中map()函数def format_name(s): return s[0].upper() + s[1:].lower() print map(format_name, [&apos;HELLO&apos;, &apos;anddroid&apos;, &apos;iOS&apos;]) map()是 Python 内置的高阶函数，它接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。这里将列表里的每个元素首字母大写，其余字母小写输出。 3.python中reduce()函数def prod(x, y): return x+y print reduce(prod, [1,2,3,4,5.6]) reduce()函数也是Python内置的一个高阶函数。reduce()函数接收的参数和 map()类似，一个函数 f，一个list，但行为和 map()不同，reduce()传入的函数 f 必须接收两个参数，reduce()对list的每个元素反复调用函数f，并返回最终结果值。这里表示计算1+2+3+4+5+6的值。reduce()还可以接收第3个可选参数，作为计算的初始值。如果把初始值设为10，计算： print reduce(prod, [1,2,3,4,5.6]，10) 表示计算10+1+2+3+4+5+6的值 4.python中filter()函数import math def is_sqr(x): r = int(math.sqrt(x)) return r*r==x print filter(is_sqr, range(1, 101)) filter()函数是 Python 内置的另一个有用的高阶函数，filter()函数接收一个函数 f 和一个list，这个函数 f 的作用是对每个元素进行判断，返回 True或 False，filter()根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list。这里筛选出了1~100中平方根是整数的数。 5.python中自定义排序函数def cmp_ignore_case(s1, s2): u1 = s1.upper() u2 = s2.upper() if u1 &lt; u2: return -1 if u1 &gt; u2: return 1 return 0 print sorted([&apos;Java&apos;, &apos;Android&apos;, &apos;iOS&apos;, &apos;Python&apos;], cmp_ignore_case ) sorted()也是一个高阶函数，它可以接收一个比较函数来实现自定义排序，比较函数的定义是，传入两个待比较的元素 x, y，如果 x 应该排在 y 的前面，返回 -1，如果 x 应该排在 y 的后面，返回 1。如果 x 和 y 相等，返回 0。这里输出[‘Android’,’iOS’,, ‘Java’, ‘Python’] 6.python中返回函数def f(): print &apos;call f()...&apos; # 定义函数g: def g(): print &apos;call g()...&apos; # 返回函数g: return g 仔细观察上面的函数定义，我们在函数 f 内部又定义了一个函数 g。由于函数 g 也是一个对象，函数名 g 就是指向函数 g 的变量，所以，最外层函数 f 可以返回变量 g，也就是函数 g 本身。调用函数 f，我们会得到 f 返回的一个函数： x = f() # 调用f() 输出：call f()... x # 变量x是f()返回的函数： 输出：&lt;function g at 0x1037bf320&gt; x() # x指向函数，因此可以调用 输出：call g()... # 调用x()就是执行g()函数定义的代码 7.python中闭包def f(): print &apos;f()...&apos; def g(): print &apos;g()...&apos; return g 像这种内层函数引用了外层函数的变量（参数也算变量），然后返回内层函数的情况，称为闭包（Closure）。闭包的特点是返回的函数还引用了外层函数的局部变量，所以，要正确使用闭包，就要确保引用的局部变量在函数返回后不能变 8.python中匿名函数def f(x): return x*x print map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]) 采用匿名函数如下： print map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]) 结果均为：[1, 4, 9, 16, 25, 36, 49, 64, 81]","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://qiracle.github.io/tags/Python/"}]},{"title":"Android系统DeskClock时钟应用时区添加代码分析","slug":"20170707","date":"2017-07-06T16:00:00.000Z","updated":"2019-10-26T07:20:52.322Z","comments":true,"path":"2017/07/07/20170707/","link":"","permalink":"http://qiracle.github.io/2017/07/07/20170707/","excerpt":"DeskClock时钟应用时区的添加，首先我们找到DeskClock该app所在的位置，它位于package/apps/DeskCock下，时区的读取文件位于src/com/android/deskclock/settings/settingsActivity.java中，接下来我们主要分析该文件中的代码。首先找到getAllTimeZones函数，","text":"DeskClock时钟应用时区的添加，首先我们找到DeskClock该app所在的位置，它位于package/apps/DeskCock下，时区的读取文件位于src/com/android/deskclock/settings/settingsActivity.java中，接下来我们主要分析该文件中的代码。首先找到getAllTimeZones函数，如下图： 该方法首先读取了string.xml里的string-array中name=timezone_values和timezone_labels，其中timezone_labels为城市名，timezone_values为城市所在大洲名/城市名。部分截图如下： 需要添加城市时候去的话，可在这两个String-array后面按着它的格式接着添加，但是不是所有的城市都能添加时区，下面会解释。 继续分析，接下来获取两个数组的长度，以最短的为准，防止少添加了匹配不到。然后定义了一个timezones的list，通过for循环给list添加数据，for循环里的对象为TimeZoneRow。我们继续看TimeZoneRow里的东西： 看TimeZoneRow方法有三个参数：id就是原来的timezone_values，name就是原来的timezone_label,currentTimeMillis为当前时间的毫秒值，用来计算城市所处时区的。 这里的Time.getTimeZone(id)需要注意,不是所有的城市都能得到对应的TimeZone，关键还要看系统资源中到底有没有该城市的时区资源，不然的话默认显示0时区，如果没有，需要从最新的tzdata（ftp://ftp.iana.org/tz/releases/）中添加（怎么添加，这里可google），如果最新的tzdata中也没有，那就无法添加该时区了。useDaylightTime表示是否使用夏令时，tz.getOffset可得到一个时区偏移量，下面就是根据这个来计算添加的城市所处时区的。下面我们进入buildGmtDisplayName方法看看他是如何计算时区的： 上述过程主要是字符串的拼接以及offset的转换，最终得到了添加城市对应的时区值并返回。存到了图一的List里，然后通过遍历该List将每个城市对应的时区值存到了数组里并返回数组。 最后在loadTimeZoneList()方法里获得timezones数组，ListPreference获取数组里的值将其显示在界面上，可供用户选择点击。 整个流程大致就是如此了。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiracle.github.io/tags/Android/"}]},{"title":"Android 系统 overlay 机制重点小结","slug":"20170701","date":"2017-06-30T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2017/07/01/20170701/","link":"","permalink":"http://qiracle.github.io/2017/07/01/20170701/","excerpt":"静态 overlay 和动态 overlay静态 overlay：又称为编译时 overlay，编译时资源就已经覆盖了，一般用在有源码的apk中。动态 overlay：又称为运行时 overlay，当 apk 在手机中运行时才发生资源覆盖，一般用在无源码的apk中。","text":"静态 overlay 和动态 overlay静态 overlay：又称为编译时 overlay，编译时资源就已经覆盖了，一般用在有源码的apk中。动态 overlay：又称为运行时 overlay，当 apk 在手机中运行时才发生资源覆盖，一般用在无源码的apk中。 overlay资源替换的前提和原则前提：资源所在路径必须与overlay下资源路径完全相同。如要替换 Settings 这个应用的String.xml里的资源，该资源文件所在路径为packages/apps/res/values/,则对应overlay的路径必须为overlay/packages/apps/res/values/。 原则：overlay替换的是资源，不是文件。举个例子，应用中String.xml里的内容如下： 123&lt;String name=&quot;a&quot;&gt;aaa&lt;/String&gt;&lt;String name=&quot;b&quot;&gt;bbb&lt;/String&gt;&lt;String name=&quot;c&quot;&gt;ccc&lt;/String&gt; overlay中的String.xml里的内容如下： 1&lt;String name=&quot;a&quot;&gt;abc&lt;/String&gt; 则最终，apk调用的资源如下： 123&lt;String name=&quot;a&quot;&gt;abc&lt;/String&gt;&lt;String name=&quot;b&quot;&gt;bbb&lt;/String&gt;&lt;String name=&quot;c&quot;&gt;ccc&lt;/String&gt; 而不是想象的如下： 1&lt;String name=&quot;a&quot;&gt;abc&lt;/String&gt; 注意，关于替换，查询相关英文文档发现有如下描述 For color, bool, string, array, style/theme types, the resource values are identifed by their keys, so for these types, there is no need to put the resources in a file with the same name as in the original base package. For layout, animation, picture drawables and raw types, the resources are indentifed by their file name, and overlay for these resources should keep the file name same as in the base packages. 翻译成中文的大概意思就是：1.对于color，bool，String，array，style等资源的值是有他们的键确定的，比如 &lt;String name=&quot;a&quot;&gt;abc&lt;/String&gt; 该字符串资源通过键 name = “a” 来唯一确定值 abc 。也就是说，overlay里的这类资源文件的文件名不需要与应用包里的资源文件的文件名保持一致。只需要，资源文件里的键保持一致就行了。 2.对于布局文件，动画文件，图片资源文件等，这些资源文件是通过文件名来唯一确定，所以overlay里的这类资源文件需要与应用包里的资源文件的文件名保持一致。 多个overlay的优先级判定在mk文件中通过定义PRODUCT_PACKAGE_OVERLAYS或DEVICE_PACKAGE_OVERLAYS变量，后面可以加上多个overlay目录路径，以此来实现多个overlay目录。但是这些目录是有优先级顺序的，PRODUCT_PACKAGE_OVERLAYS下的目录优先级高于DEVICE_PACKAGE_OVERLAYS下目录的优先级，写在前面的目录优先级高于写在后面目录的优先级，举个例子: 12PRODUCT_PACKAGE_OVERLAYS = overlay_A overlay_BDEVICE_PACKAGE_OVERLAYS = overlay_C overlay_D 上述overlay目录优先级顺序:overlay_A &gt;overlay_B&gt; overlay_C &gt;overlay_D overlay用于新增资源默认情况下，overlay目录的资源文件内容只能覆盖原有软件包中的资源，而不能新增资源。不让会造成编译错误。如要允许增加资源，可以将资源放入标签中，或者一种更加简便的方法是给aapt命令增加–auto-add-overlay选项。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiracle.github.io/tags/Android/"}]},{"title":"数据结构-顺序表的基本操作","slug":"20170625","date":"2017-06-24T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2017/06/25/20170625/","link":"","permalink":"http://qiracle.github.io/2017/06/25/20170625/","excerpt":"1.顺序表的定义2.顺序表的初始化3.顺序表元素增删改查","text":"1.顺序表的定义2.顺序表的初始化3.顺序表元素增删改查 #include&lt;stdio.h&gt; #define MAXSIZE 20 typedef int ElemType; typedef struct { ElemType data[MAXSIZE]; int length; }SeqList; SeqList init_list(){//初始化 SeqList L; L.length =0; return L; } int list_length(SeqList *L){//获取长度 return L-&gt;length; } int get_element(SeqList L,int i){//根据序号查找元素 if(i&lt;1 || i&gt;L.length){ printf(&quot;序号超出范围&quot;); return -1; } return L.data[i-1]; } int list_locate(SeqList L,ElemType x){//根据元素查找位置 int i; for(i=0; i&lt;L.length;i++) if(L.data[i]==x) return (i+1); return -1;//未找到 } void list_insert(SeqList *L, ElemType x,int i){ //插入元素 int j; if (L-&gt;length == MAXSIZE) printf(&quot;溢出，不能插入 \\n&quot;); else if(i&lt;1 || i &gt; L-&gt;length+1) printf(&quot;插入范围出错 \\n&quot;); else { for(j=L-&gt;length-1; j&gt;=i-1; j--) L-&gt;data[j+1] =L-&gt;data[j]; L-&gt;data[i-1] =x; L-&gt;length++; } } void list_delete(SeqList *L,int i){//删除元素 int j; if(L-&gt;length&lt;=0) printf(&quot;空表，无法删除元素&quot;); if(i&gt;L-&gt;length || i&lt;=0) printf(&quot;删除位置出错&quot;); else { for(j=i;j&lt;=L-&gt;length-1;j++) L-&gt;data[j-1] =L-&gt;data[j]; L-&gt;length--; } } SeqList list_scanf(SeqList L){ //创建链表 int x; int i; printf(&quot;请输入顺序表的元素(-1结束)&quot;); for(i=0;;i++){ scanf(&quot;%d&quot;,&amp;x); if(x==-1){ break; } L.data[L.length] = x; L.length++; } return L; } void list_print(SeqList L){//打印链表 int k; printf(&quot;顺序表的元素有:&quot;); for(k = 0; k&lt;L.length;k++){ printf(&quot;%3d &quot;,L.data[k]); } printf(&quot;\\n&quot;); } int main(){ int pos; int key; SeqList L = init_list(); L = list_scanf(L); list_insert(&amp;L, 3, 2); // list_delete(&amp;L,1); //pos= list_locate(L,2); // printf(&quot;查找到该元素位于：%d \\n&quot;,pos); //key = get_element(L,3); //printf(&quot;该元素为：%d \\n&quot;,key); list_print(L); printf(&quot;length:%d \\n&quot;,list_length(&amp;L)); return 0; }","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://qiracle.github.io/tags/数据结构/"}]},{"title":"数据结构-链表的基本操作","slug":"2017062502","date":"2017-06-24T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2017/06/25/2017062502/","link":"","permalink":"http://qiracle.github.io/2017/06/25/2017062502/","excerpt":"1.链表的定义2.链表的初始化3.链表元素增删改查","text":"1.链表的定义2.链表的初始化3.链表元素增删改查 #include&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; typedef int ElemType; typedef struct Node { ElemType data; struct Node* next; }Node; typedef struct Node* LinkList; int getElem(LinkList L,int i){//根据序号查找元素 int j; LinkList p; p = L-&gt;next; j = 1; while(p &amp;&amp; j&lt;i) { p = p-&gt;next; ++j; } if(!p || j&gt;i) return -1; else return p-&gt;data; } int list_insert(LinkList *L,int i,ElemType e){//插入 int j; LinkList p,s; p=*L; j=1; while(p&amp;&amp;j&lt;i) { p=p-&gt;next; ++j; } if(!p||j&gt;i) return -1; else{ s = (LinkList)malloc(sizeof(Node)); s-&gt;data =e; s-&gt;next = p-&gt;next; p-&gt;next =s; return 1;} } int list_delete(LinkList *L,int i){//删除 int j; int key; LinkList p,q; p =*L; j =1; while(p-&gt;next&amp;&amp;j&lt;i) { p = p-&gt;next; ++j; } if(!(p-&gt;next)||j&gt;i) return -1; q = p-&gt;next; p-&gt;next =q-&gt;next; key = q-&gt;data; free(q); return key; } void list_createHead(LinkList *L,int n){//头插法 LinkList p; int i; srand(time(0)); *L=(LinkList)malloc(sizeof(Node)); (*L)-&gt;next =NULL; for(i=0;i&lt;n;i++){ p=(LinkList)malloc(sizeof(Node)); p-&gt;data =rand()%100+1; p-&gt;next = (*L)-&gt;next; (*L)-&gt;next =p; } } void list_createTail(LinkList *L,int n){//尾插法 LinkList p,r; int i; srand(time(0)); *L=(LinkList)malloc(sizeof(Node)); r=*L; for(i=0;i&lt;n;i++){ p =(Node *)malloc(sizeof(Node)); p-&gt;data =rand()%100+1; r-&gt;next=p; r=p; } r-&gt;next =NULL; } void list_print(LinkList L){//打印链表 LinkList p = L-&gt;next; //将头节点的指针给予临时节点p while(NULL != p) //节点p不为空，循环 { printf(&quot;%d &quot;,p-&gt;data); p = p-&gt;next; } printf(&quot;\\n&quot;); } int main(){ int x = 0; int y = 0; LinkList L; list_createTail(&amp;L,10); printf(&quot;尾插法：&quot;); list_print(L); y = list_delete(&amp;L,5); printf(&quot;删除的元素为:%d \\n&quot;,y); printf(&quot;删除后：&quot;); list_print(L); list_createHead(&amp;L,10); printf(&quot;头插法：&quot;); list_print(L); x = getElem(L, 3); printf(&quot;第三个数是：%d \\n&quot;,x); list_insert(&amp;L,6,100); printf(&quot;第六位插入数字100：\\n&quot;); list_print(L); return 0; }","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://qiracle.github.io/tags/数据结构/"}]},{"title":"Android系统工程模式启动过程详解","slug":"20170503","date":"2017-05-02T16:00:00.000Z","updated":"2019-10-26T07:20:33.662Z","comments":true,"path":"2017/05/03/20170503/","link":"","permalink":"http://qiracle.github.io/2017/05/03/20170503/","excerpt":"​ 这几天在公司看 Android 系统里的工程模式方面的代码。工程模式就是拿来测试手机的，普通用户会打开工程模式的很少，但作为一名 Android 手机的开发者来说，就必须知道了。其实就是在手机拨号盘输入特定混合数字和 *# 的字符串，进入特殊的界面。如输入*#06# 可以查看手机IMEI号，*#*#4636#*#* 可以查看手机的一些信息等。下面我来通过我所查看的系统源码来说明这是怎样的一个过程。","text":"​ 这几天在公司看 Android 系统里的工程模式方面的代码。工程模式就是拿来测试手机的，普通用户会打开工程模式的很少，但作为一名 Android 手机的开发者来说，就必须知道了。其实就是在手机拨号盘输入特定混合数字和 *# 的字符串，进入特殊的界面。如输入*#06# 可以查看手机IMEI号，*#*#4636#*#* 可以查看手机的一些信息等。下面我来通过我所查看的系统源码来说明这是怎样的一个过程。 首先找到源码目录下 packages/apps/Dialer 这个应用，这是一个拨号应用，我们平常拨打电话用的就是这个 app。找到该 app 里 DialpadFragment.java 这个文件，如下图 里面有个监听 EditText 获取数字变化后的回调方法 afterTextChange 在这个方法里又调用了 handleChars，进入到 handleChars 方法里如下： 该方法定义位于，如果相关宏控打开的话，则会执行 handleCustomCode（）方法。进入该方法： 在该方法里传入了一个 intent，发送了一条广播。我们继续查找这条广播的接收者，我们在 EmodeReceiver.java 找到了该广播接受者，路径如下： 在这个文件中，，可以看到这么一段代码： 在收到这条广播后，调用了 startActivityByCode 方法，从该方法名字就可以看出，是通过不同的 Code 来跳转到不同的 Activity，而该 code 就是用户从拨号盘输入的字符。 我们进入到 startActivityByCode 方法中，，看看该方法是怎么实现的，该方法同样位于 EmodeReceiver.java 文件中，在该方法中，我们很容易看到这么一段代码： switch-case语句，很明显，底层就是通过这种方式来根据用户输入在拨号盘输入不同的字符来进入特定的工程模式界面的。但是仔细一看，，问题来了，我们在键盘输入的都是数字+*#号，这A，B是咋回事？往上一看： 这样我们就明白了，这里把 * 和 # 号全部替换成了 A 和 B。 至此，工程模式的启动过程就完成了。我们再来总结一下这个过程，首先用户在拨号盘输入特定的字符串，DialpadFragment 里的回调方法 afterTextChange 监听到拨号盘的EditText里内容变化后，如果变化后后的字符串跟特定某些的字符串一致，则会进行相应的处理并发送一条广播，并将这个字符串一同放进广播中，该广播的接收者受到这条广播后，获取到里面的字符串，然后打开与该字符串对应的 Activity。由拨号盘界面到工程模式界面的启动就此完成！","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiracle.github.io/tags/Android/"}]},{"title":"浅谈git撤销回退相关用法","slug":"20170426","date":"2017-04-25T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2017/04/26/20170426/","link":"","permalink":"http://qiracle.github.io/2017/04/26/20170426/","excerpt":"初来公司实习，每次改完代码后都需要用代码管理工具git提交到代码库。由于刚开始对 git 并不熟悉，只会简单的 commit，push 指令，一旦提交出了问题需要撤销回退的话就不知道该怎么办了。经过一段时间的研究，总算是把里面相关原理搞懂了，遇到git提交出现问题，现在自己也能想办法解决而不至于手足无措了。下面就说说我对git撤销回退这块相关的理解。 git reset 首先，我们要弄清以下三条命令的区别： git reset –hard git reset –soft git reset","text":"初来公司实习，每次改完代码后都需要用代码管理工具git提交到代码库。由于刚开始对 git 并不熟悉，只会简单的 commit，push 指令，一旦提交出了问题需要撤销回退的话就不知道该怎么办了。经过一段时间的研究，总算是把里面相关原理搞懂了，遇到git提交出现问题，现在自己也能想办法解决而不至于手足无措了。下面就说说我对git撤销回退这块相关的理解。 git reset 首先，我们要弄清以下三条命令的区别： git reset –hard git reset –soft git reset 工作区，暂存区，本地仓库，远程仓库的概念我在这里就不介绍了。这是git最为基础的概念，可自行百度。下面说说这三条 git reset 指令的区别： git reset –hard： 重置工作区，暂存区，本地仓库的所有文件到某一节点。例如 git reset –hard HEAD^ 表示工作区，暂存区，本地仓库的所有文件全部回退到上一个节点，也就是说你从上一个节点到这个节点之间所做的修改全部被撤销了。当然如果要回到特定的一个节点可以用 git reset –hard commitId 。通过指定要回到的节点值来回到对应的节点。 git reset –soft：只重置本地仓库的文件，工作区和暂存区的文件不变。 git reset 等同于 git reset –mixed，只重置本地仓库和暂存区文件，工作区文件不变。 当我们提交完并push代码到远程仓库后，发现代码有问题，想重新提交，首先在gerrit上abandon掉自己刚才上传的代码，接着，用git reset HEAD^或者git reset –soft HEAD^回到上一个节点（git reset HEAD^后，使用git add .就相当于git reset –soft），不要用git reset –hard。因为这会把你本地工作区修改的全部撤销，这样你之前的修改就全没了。虽然也有办法再找回来，只要找到那次提交的commitId就可以了，下面会介绍。 另外，我们还可以用git reset file 来使一个已经添加到暂存区的file文件重新返回到工作区。 git log 我们通过git log就可以查看到每次提交的 commitId 了，如果嫌 git log 显示的信息过多，可以使用 git log –pretty=oneline 让每次提交的关键信息在一行显示。但是如果使用了 git reset –hard，那么使用 git log 只能看到你重置点之前的提交 commitId，无法看到重置点之后的提交 commitId，要想找到重置点之后的 commitId 可以用git reflog。 git checkout git checkout有两个作用，如果后面接的是文件名的话，如 git checkout file 可以将一个工作区的文件撤销其修改。如果后面接的是分支名的话，如 git checkout b表示的是切换到b分支。对于工作区新建立的文件，用 git clean -df 可将其移除工作区。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"git","slug":"git","permalink":"http://qiracle.github.io/tags/git/"}]},{"title":"在Android系统源码下编译apk","slug":"20170425","date":"2017-04-24T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2017/04/25/20170425/","link":"","permalink":"http://qiracle.github.io/2017/04/25/20170425/","excerpt":"步骤： 一.找到Android源码目录下packages/apps目录，在此目录下新建一个文件夹，以你的apk名字命名，这里以Test为例。 二.将自己写的应用目录下的src和res以及清单文件复制到Test目录下。另外，如果你的项目有用到assert文件或是第三方jar包，还需要将assert文件夹和jar包复制到Test根目录下。 三.编写Android.mk文件。下面为我写的例子：","text":"步骤： 一.找到Android源码目录下packages/apps目录，在此目录下新建一个文件夹，以你的apk名字命名，这里以Test为例。 二.将自己写的应用目录下的src和res以及清单文件复制到Test目录下。另外，如果你的项目有用到assert文件或是第三方jar包，还需要将assert文件夹和jar包复制到Test根目录下。 三.编写Android.mk文件。下面为我写的例子： LOCAL_PATH:= $(call my-dir) //设置当前模块的编译路径为当前文件夹路径。即当前Android.mk 所在的目录include $(CLEAR_VARS) //清除变量LOCAL_MODULE_TAGS := optional //指该模块在所有版本下都编译(user,eng,debug等)LOCAL_CERTIFICATE := platform //使用平台签名，PRESIGNED 表示这个apk已经签过名了，不需要再签名LOCAL_ASSERT_DIR := packages/apps/Test/asserts //导入assets目录下的文件LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES :=android-support-v4 \\ //导入jar包LOCAL_DEX_PREOPT :=false //是生成apk程序时只生成apk的包，不再生成odexLOCAL_SRC_FILES := \\$(call all-java-files-under,src) \\ //把src下的所有java文件包含进来 src/com/android/internal/telephony/ITelephony.aidl //如果有aidl，还需单独将aidl文件加进来LOCAL_PACKAGE_NAME :=Test //应用名称LOCAL_MODULE_PATH := $(TARGET_OUT)/vendor/operator/app //应用生成路径include $(BUILD_PACKAGE)","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiracle.github.io/tags/Android/"}]},{"title":"git分支的简单操作","slug":"20170316","date":"2017-03-15T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2017/03/16/20170316/","link":"","permalink":"http://qiracle.github.io/2017/03/16/20170316/","excerpt":"Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d","text":"Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d 详细过程：http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000 注意：git checkout –file是把file文件在工作区的修改全部撤销掉，分为两种情况： 1.一种是file自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 2.一种是file已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次git commit或git add时的状态。若工作区的file文件被删除，则可以用git checkout –file还原file文件。 git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"git","slug":"git","permalink":"http://qiracle.github.io/tags/git/"}]},{"title":"java中的回调机制","slug":"20170117","date":"2017-01-16T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2017/01/17/20170117/","link":"","permalink":"http://qiracle.github.io/2017/01/17/20170117/","excerpt":"java中的回调简单来说就是A类调了B类里面的C方法，结果是B类调了A类里面的D方法。其中D就是回调方法，它存在于接口中，由A实现。回调分为同步回调和异步回调。他们之间的区别在于返回结果是否需要等待，若有延迟则为异步回调，否则为同步回调。下面为代码示例：","text":"java中的回调简单来说就是A类调了B类里面的C方法，结果是B类调了A类里面的D方法。其中D就是回调方法，它存在于接口中，由A实现。回调分为同步回调和异步回调。他们之间的区别在于返回结果是否需要等待，若有延迟则为异步回调，否则为同步回调。下面为代码示例： public interface CSCallBack {//回调接口 public void process(String status);//回调方法 } public class Client implements CSCallBack {//A类 private Server server; public Client(Server server) { this.server = server; } public void sendMsg(final String msg){ System.out.println(&quot;客户端：发送的消息为：&quot; + msg); //此处为异步回调，同步回调不需要新开线程进行 new Thread(new Runnable() { @Override public void run() { Thread.sleep(2000); //相当于A类调了B类里面的C方法 server.getClientMsg(Client.this,msg); } }).start(); System.out.println(&quot;客户端：异步发送成功&quot;); } @Override public void process(String status) {//D方法，回调方法 System.out.println(&quot;客户端：服务端回调状态为：&quot; + status); } } public class Server {//B类 public void getClientMsg(CSCallBack csCallBack , String msg) { System.out.println(&quot;服务端：服务端接收到客户端发送的消息为:&quot; + msg); // 模拟服务端需要对数据处理 try { Thread.sleep(5 * 1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;服务端:数据处理成功，返回成功状态 200&quot;); String status = &quot;200&quot;; csCallBack.process(status);//相当于B类调了A类里面的D方法 } }","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"java","slug":"java","permalink":"http://qiracle.github.io/tags/java/"}]},{"title":"简单的python网络爬虫实现","slug":"20170110","date":"2017-01-09T16:00:00.000Z","updated":"2019-10-26T07:20:16.960Z","comments":true,"path":"2017/01/10/20170110/","link":"","permalink":"http://qiracle.github.io/2017/01/10/20170110/","excerpt":"学了差不多一星期python，目的有两个，第一，作为一名CS的学生需要懂得一门脚本语言。第二，那就是网络爬虫啦。 此次爬虫很简单，就是爬斗鱼直播平台上的美女主播的图片 网址是https://www.douyu.com/directory/game/yz 。直接贴代码： import urllib2 import urllib import re import time def getHtml(url): request = urllib2.Request(url) request.add_header(&apos;User-Agent&apos;,&apos;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.76 Mobile Safari/537.36&apos;) response = urllib2.urlopen(request) html=response.read() return html","text":"学了差不多一星期python，目的有两个，第一，作为一名CS的学生需要懂得一门脚本语言。第二，那就是网络爬虫啦。 此次爬虫很简单，就是爬斗鱼直播平台上的美女主播的图片 网址是https://www.douyu.com/directory/game/yz 。直接贴代码： import urllib2 import urllib import re import time def getHtml(url): request = urllib2.Request(url) request.add_header(&apos;User-Agent&apos;,&apos;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.76 Mobile Safari/537.36&apos;) response = urllib2.urlopen(request) html=response.read() return html def getImage(html): imglist=re.findall(r&apos;data-original=&quot;(.*?\\.(jpg|jpeg))&quot;&apos;,html) print(len(imglist)) path =&quot;&quot; x=0 for img in imglist: urllib.urlretrieve(img[0],&quot;/home/qiracle/douyu/&quot;+str(x)+&quot;.&quot;+img[1]) x+=1 time.sleep(1) html =getHtml(&quot;https://www.douyu.com/directory/game/yz&quot;) getImage(html) 最终爬到的结果如下：","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"python","slug":"python","permalink":"http://qiracle.github.io/tags/python/"}]},{"title":"将自己制作的python包安装到ubuntu系统中","slug":"20170109","date":"2017-01-08T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2017/01/09/20170109/","link":"","permalink":"http://qiracle.github.io/2017/01/09/20170109/","excerpt":"1.新建setup.py文件，并将下面代码修改后复制到文件中 from distutils.core import setup setup(name=&quot;qiracle&quot;,version=&quot;1.0&quot;,description=&quot;qiracle&apos;s module&quot;,author=&quot;qiracle&quot;,py_modules=[&quot;test1&quot;,&quot;test2&quot;]) 这里py_modules列表里填的是模块的名字","text":"1.新建setup.py文件，并将下面代码修改后复制到文件中 from distutils.core import setup setup(name=&quot;qiracle&quot;,version=&quot;1.0&quot;,description=&quot;qiracle&apos;s module&quot;,author=&quot;qiracle&quot;,py_modules=[&quot;test1&quot;,&quot;test2&quot;]) 这里py_modules列表里填的是模块的名字 2.python3 setup.py build 执行完后出现： running buildrunning build_pycreating buildcreating build/lib.linux-x86_64-2.7copying test1.py -&gt; build/lib.linux-x86_64-2.7copying test2.py -&gt; build/lib.linux-x86_64-2.7 3.python3 setup.py sdist 执行完后出现： running sdistrunning checkwarning: check: missing required meta-data: urlwarning: check: missing meta-data: if ‘author’ supplied, ‘author_email’ must be supplied toowarning: sdist: manifest template ‘MANIFEST.in’ does not exist (using default file list)warning: sdist: standard file not found: should have one of README, README.txtwriting manifest file ‘MANIFEST’creating qiracle-1.0making hard links in qiracle-1.0…hard linking setup.py -&gt; qiracle-1.0hard linking test1.py -&gt; qiracle-1.0hard linking test2.py -&gt; qiracle-1.0creating distCreating tar archiveremoving ‘qiracle-1.0’ (and everything under it) 4.找到模块的压缩包，解压，进入setup.py所在文件夹后执行命令: python3 setup.py install（需要管理员权限） 执行完后出现： running installrunning buildrunning build_pyrunning install_libcopying build/lib/test2.py -&gt; /usr/local/lib/python3.4/dist-packagescopying build/lib/test1.py -&gt; /usr/local/lib/python3.4/dist-packagesbyte-compiling /usr/local/lib/python3.4/dist-packages/test2.py to test2.cpython-34.pycbyte-compiling /usr/local/lib/python3.4/dist-packages/test1.py to test1.cpython-34.pycrunning install_egg_infoWriting /usr/local/lib/python3.4/dist-packages/qiracle-1.0.egg-info 此时表明安装成功,在之后的python程序中任意路径下都可直接import包名使用","categories":[{"name":"教程","slug":"教程","permalink":"http://qiracle.github.io/categories/教程/"}],"tags":[{"name":"python","slug":"python","permalink":"http://qiracle.github.io/tags/python/"}]},{"title":"python中的__name__","slug":"20170108","date":"2017-01-07T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2017/01/08/20170108/","link":"","permalink":"http://qiracle.github.io/2017/01/08/20170108/","excerpt":"python中我们常将一些方法封装在一个模块里，然后在另一个文件里通过import导入模块进行调用。 新建test.py文件，代码如下 def A(): print(&quot;hello&quot;) 再简历main.py文件，代码如下 import test test.A() 此时用python main.py执行，打印 hello。 但如果A()实现的代码很长，我们想要在test.py文件里调用A()进行测试，则需要：","text":"python中我们常将一些方法封装在一个模块里，然后在另一个文件里通过import导入模块进行调用。 新建test.py文件，代码如下 def A(): print(&quot;hello&quot;) 再简历main.py文件，代码如下 import test test.A() 此时用python main.py执行，打印 hello。 但如果A()实现的代码很长，我们想要在test.py文件里调用A()进行测试，则需要： def A(): print(&quot;hello&quot;) A()//测试 用python test.py执行，打印 hello。 但此时如果测试代码没有删除，调用者用python main.py执行，则会打印 hello hello。因为A()被执行了两次。 为解决这一问题，我们需要这样做，在test.py文件里： def A(): print(&quot;hello&quot;) if __name__ == &apos;__main__&apos;://加上这句在执行 A() 用python main.py执行，则会打印 hello，结果正常 分析 在test.py中，加入print(__name__),看看__name__的值 def A(): print(&quot;hello&quot;) print(__name__) if __name__ == &apos;__main__&apos;://加上这句在执行 A() 此时如果用python test.py，则会打印__main__ hello,此时__name的值为\\main__ 如果用python main.py执行，则打印test hello，此时__name__的值为test 结论 因此可以看出，在函数所在的文件内调用函数，__name__的值为__main__ 但是如果通过导入模块调用函数，则函数所在文件的__name__值为函数所在文件的文件名","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"python","slug":"python","permalink":"http://qiracle.github.io/tags/python/"}]},{"title":"程序的内存四区模型","slug":"20170107","date":"2017-01-06T16:00:00.000Z","updated":"2019-10-26T07:20:00.653Z","comments":true,"path":"2017/01/07/20170107/","link":"","permalink":"http://qiracle.github.io/2017/01/07/20170107/","excerpt":"内存四区的建立流程","text":"内存四区的建立流程 流程说明 1、操作系统把物理硬盘代码load到内存 2、操作系统把c代码分成四个区 3、操作系统找到main函数入口执行 各区元素分析","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://qiracle.github.io/tags/C-C/"}]},{"title":"python学习（四）——类中内置的方法","slug":"20170106","date":"2017-01-05T16:00:00.000Z","updated":"2019-10-26T07:19:45.591Z","comments":true,"path":"2017/01/06/20170106/","link":"","permalink":"http://qiracle.github.io/2017/01/06/20170106/","excerpt":"在Python中有一些内置的方法，这些方法命名都有比较特殊的地方（其方法名以2个下划线开始然后以2个下划线结束）。类中最常用的就是构造方法和析构方法。 构造方法__init__(self,….)：在生成对象时调用，可以用来进行一些初始化操作，不需要显示去调用，系统会默认去执行。构造方法支持重载，如果用户自己没有重新定义构造方法，系统就自动执行默认的构造方法。 析构方法__del__(self)：在释放对象时调用，支持重载，可以在里面进行一些释放资源的操作，不需要显示调用。","text":"在Python中有一些内置的方法，这些方法命名都有比较特殊的地方（其方法名以2个下划线开始然后以2个下划线结束）。类中最常用的就是构造方法和析构方法。 构造方法__init__(self,….)：在生成对象时调用，可以用来进行一些初始化操作，不需要显示去调用，系统会默认去执行。构造方法支持重载，如果用户自己没有重新定义构造方法，系统就自动执行默认的构造方法。 析构方法__del__(self)：在释放对象时调用，支持重载，可以在里面进行一些释放资源的操作，不需要显示调用。 __new__():__new__()在__init__()之前被调用，用于生成实例对象。利用这个方法和类属性的特性可以实现设计模式中的单例模式。单例模式是指创建唯一对象吗，单例模式设计的类只能实例化一个对象。 __getattr__()、__setattr__()和__getattribute__():当读取对象的某个属性时，python会自动调用__getattr__()方法。 __getitem__():如果类把某个属性定义为序列，可以使用__getitem__()输出序列属性中的某个元素 _str__():__str__()用于表示对象代表的含义，返回一个字符串.实现了__str__()方法后，可以直接使用print语句输出对象，也可以通过函数str()触发__str__()的执行。这样就把对象和字符串关联起来，便于某些程序的实现，可以用这个字符串来表示某个类 __call__():在类中实现__call__()方法，可以在对象创建时直接返回__call__()的内容。使用该方法可以模拟静态方法 下面是常用的内置方法：","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"python","slug":"python","permalink":"http://qiracle.github.io/tags/python/"}]},{"title":"java中类的方法初始化顺序","slug":"20170105","date":"2017-01-04T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2017/01/05/20170105/","link":"","permalink":"http://qiracle.github.io/2017/01/05/20170105/","excerpt":"类初始化时构造函数调用顺序： （1）初始化对象的存储空间为零或null值； （2）调用父类构造函数； （3）按顺序分别调用类成员变量和实例成员变量的初始化表达式； （4）调用本身构造函数。","text":"类初始化时构造函数调用顺序： （1）初始化对象的存储空间为零或null值； （2）调用父类构造函数； （3）按顺序分别调用类成员变量和实例成员变量的初始化表达式； （4）调用本身构造函数。 例子: public class Dog extends Animal{ Cat c=new Cat(); public Dog(){ System.out.println(&quot;Dog 构造方法!&quot;); } public static void main(String[] args){ new Dog(); } } class Animal{ public Animal(){ System.out.println(&quot;Animal构造方法&quot;); } } class Cat{ public Cat(){ System.out.println(&quot;Cat 构造方法&quot;); } } 输出结果: Animal构造方法 Cat 构造方法 Dog 构造方法 在我们的程序中，实例化一个类对象的时候，运行顺序为： 静态块 父类构造器 本类中的块 本类的构造器 public class Dog { public Dog() { System.out.println(&quot;Dog&quot;); } static{ //静态块 System.out.println(&quot;super static block&quot;); } { System.out.println(&quot;super block&quot;); } } public class Mastiff extends Dog { public Mastiff() { System.out.println(&quot;Mastiff&quot;); } { System.out.println(&quot;block&quot;); } static { System.out.println(&quot;static block&quot;); } public static void main(String[] args){ Mastiff mastiff=new Mastiff(); //实例化一个对象 } } 输出结果： super static block static block super block Dog block Mastiff 也就是说此时的运行顺序为： 父类静态块 自身静态块 父类块 父类构造器 自身块 自身构造器","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"java","slug":"java","permalink":"http://qiracle.github.io/tags/java/"}]},{"title":"Android开源项目推荐之「图片加载到底哪家强」(转)","slug":"20170104","date":"2017-01-03T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2017/01/04/20170104/","link":"","permalink":"http://qiracle.github.io/2017/01/04/20170104/","excerpt":"图片加载几乎是任何 Android 项目中必备的需求，而图片加载的开源库也越来越多，我们姑且在 GitHub 上搜索下 android image 关键字，出来的前五个按照 Star 数排序的项目如下： 可以看到前四个是大家比较熟知的图片加载库，有 UniversalImageLoader、Picasso、Fresco、Glide，至于第五个 ion 其实是一个网络库，只不过也提供了图片加载的功能，跟 Volley 类似，也提供图片加载的功能，但是如果图片加载是一个强需求的话，我更喜欢专注的库，所以本文只讨论单纯的图片加载库。","text":"图片加载几乎是任何 Android 项目中必备的需求，而图片加载的开源库也越来越多，我们姑且在 GitHub 上搜索下 android image 关键字，出来的前五个按照 Star 数排序的项目如下： 可以看到前四个是大家比较熟知的图片加载库，有 UniversalImageLoader、Picasso、Fresco、Glide，至于第五个 ion 其实是一个网络库，只不过也提供了图片加载的功能，跟 Volley 类似，也提供图片加载的功能，但是如果图片加载是一个强需求的话，我更喜欢专注的库，所以本文只讨论单纯的图片加载库。 我相信大家很纠结到底该选择哪一个呢？貌似它们在GitHub上都有自己的一席之地，Star 数都蛮高的，确实很难抉择，那么今天我就来给大家分析下，图片加载到底该怎么选择！ UniversalImageLoaderhttps://github.com/nostra13/Android-Universal-Image-Loader UIL可以算是老牌最火的图片加载库了，使用过这个开源库的项目可以说是多的令人发指，即使到现在 GitHub 上他的 Star 数仍然是众多图片加载库最多的。 可惜的是该作者在项目中说明，从去年的9月份，他就已经停止了对该项目的维护。这就意味着以后任何的 bug 都不会修复，任何的新特性都不会再继续开发，所以毫无疑问 UIL 不推荐在项目中使用了。 Picassohttps://github.com/square/picasso Picasso 是 Square 公司的大作，名字起的也这么文艺，叫「毕加索」，意为加载图片就像画画一样，是一门艺术。这个库是我之前一直很喜欢的，因为他不仅具备图片加载应有尽有的强大功能，他的调用也是如此简洁文艺： Picasso.with(context).load(“http://i.imgur.com/DvpvklR.png&quot;).into(imageView); 以上代码就是给一个 ImageView 加载远程图片的一个示例，是不是很简洁？ 当然不止如此，他还提供更多的用法，足以满足你实际项目中的各种需求，具体这些用法本文就不提了，可以去官网自行研究。 Glidehttps://github.com/bumptech/glide Glide 是 Google 一位员工的大作，他完全是基于 Picasso 的，沿袭了 Picasso 的简洁风格，但是在此做了大量优化与改进。 Glide 默认的 Bitmap 格式是 RGB_565 格式，而 Picasso 默认的是 ARGB_8888 格式，这个内存开销要小一半。 在磁盘缓存方面，Picasso 只会缓存原始尺寸的图片，而 Glide 缓存的是多种规格，也就意味着 Glide 会根据你 ImageView 的大小来缓存相应大小的图片尺寸，比如你 ImageView 大小是200200，原图是 400400 ，而使用 Glide 就会缓存 200200 规格的图，而 Picasso 只会缓存 400400 规格的。这个改进就会导致 Glide 比 Picasso 加载的速度要快，毕竟少了每次裁剪重新渲染的过程。 最重要的一个特性是 Glide 支持加载 Gif 动态图，而 Picasso 不支持该特性。 除此之外，还有很多其他配置选项的增加。 总体来说，Glide 是在 Picasso 基础之上进行的二次开发，各个方面做了不少改进，不过这也导致他的包比 Picasso 大不少，不过也就不到 500k，Picasso 是100多k，方法数也比 Picasso 多不少，不过毕竟级别还是蛮小的，影响不是很大。 Frescohttps://github.com/facebook/fresco Fresco 是 Facebook 出品，他是新一代的图片加载库，我们知道 Android 应用程序可用的内存有限，经常会因为图片加载导致 OOM，虽然我们有各种手段去优化，尽量减少出现 OOM 的可能性，但是永远没法避免，尤其某些低端手机 OOM 更是严重。而 Facebook 就另辟蹊径，既然没法在 Java 层处理，我们就在更底层的 Native 堆做手脚。于是 Fresco 将图片放到一个特别的内存区域叫 Ashmem 区，就是属于 Native 堆，图片将不再占用 App 的内存，Java 层对此无能为力，这里是属于 C++ 的地盘，所以能大大的减少 OOM。 所以此库很强大，不过用起来也比较复杂，包也比较大，貌似有2、3M，底层涉及到的 C++ 领域，想读源码也比较困难。 总结综合来看，毫无疑问 Glide 与 Picasso 之间优先推荐选择 Glide，尤其是如果你的项目想要支持 Gif 动态图，那更该选择 Glide 。 但是如果你的项目使用了 Square 公司的全家桶，如 Retrofit 或者 OkHttp ，那么搭配 Picasso 一起使用也不是不可，兼容性可能会更好些，占用体积也会少些。 对于一般的 App 使用 Fresco 未免有些大材小用了，大部分情况 Glide 都能满足你的需求了，但是如果你的 App 中大量使用图片，比如是类似 Instagram 一类的图片社交 App ，那么推荐使用 Fresco ，虽然稍复杂，但是还是推荐使用 Fresco ，对提升你 App 的性能与体验有不少帮助，值得花时间去研究并应用到自己的 App 上来。 注：本文转自stormzhang，原文链接：https://zhuanlan.zhihu.com/p/21397115","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"转载","slug":"转载","permalink":"http://qiracle.github.io/tags/转载/"}]},{"title":"Android开源项目推荐之「网络请求哪家强」(转)","slug":"20170103","date":"2017-01-02T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2017/01/03/20170103/","link":"","permalink":"http://qiracle.github.io/2017/01/03/20170103/","excerpt":"1. 原则本篇说的网络请求专指 http 请求，在选择一个框架之前，我个人有个习惯，就是我喜欢选择专注的库，其实在软件设计领域有一个原则叫做 「单一职责原则」，跟我所说的「专注」不谋而合，一个库能把一件事做好就很不错了。现如今有很多大而全的库，比如这个库可以网络请求，同时又可以图片加载，又可以数据存储，又可以 View 注解等等，我们使用这种库当然方便了，但是你有没有想过？这样会使得你整个项目对它依赖性太强，万一以后这个库不维护了，或者中间某个模块出问题了，这个影响非常大，而且我一直认为大而全的框架可能某一块都做的不够好，所以我在选择的时候更喜欢专注某一领域的框架。","text":"1. 原则本篇说的网络请求专指 http 请求，在选择一个框架之前，我个人有个习惯，就是我喜欢选择专注的库，其实在软件设计领域有一个原则叫做 「单一职责原则」，跟我所说的「专注」不谋而合，一个库能把一件事做好就很不错了。现如今有很多大而全的库，比如这个库可以网络请求，同时又可以图片加载，又可以数据存储，又可以 View 注解等等，我们使用这种库当然方便了，但是你有没有想过？这样会使得你整个项目对它依赖性太强，万一以后这个库不维护了，或者中间某个模块出问题了，这个影响非常大，而且我一直认为大而全的框架可能某一块都做的不够好，所以我在选择的时候更喜欢专注某一领域的框架。 在上面原则的基础上，所以目前来说单纯的网络请求库就锁定在了 Volley、OkHttp、Retrofit 三个，android-async-http 的作者已经不维护，所以这里就不多说了，下面我们分别来说说这三个库的区别。 2. OkHttp我们知道在 Android 开发中是可以直接使用现成的 api 进行网络请求的，就是使用 HttpClient、HttpUrlConnection 进行操作，目前 HttpClient 已经被废弃，而 android-async-http 是基于 HttpClient 的，我想可能也是因为这个原因作者放弃维护。 而 OkHttp 是 Square 公司开源的针对 Java 和 Android 程序，封装的一个高性能 http 请求库，所以它的职责跟 HttpUrlConnection 是一样的，支持 spdy、http 2.0、websocket ，支持同步、异步，而且 OkHttp 又封装了线程池，封装了数据转换，封装了参数使用、错误处理等，api 使用起来更加方便。可以把它理解成是一个封装之后的类似 HttpUrlConnection 的一个东西，但是你在使用的时候仍然需要自己再做一层封装，这样才能像使用一个框架一样更加顺手。 OkHttp 的具体使用方法这里就不赘述，地址在这里： http://square.github.io/okhttp/ 3. VolleyVolley 是 Google 官方出的一套小而巧的异步请求库，该框架封装的扩展性很强，支持 HttpClient、HttpUrlConnection，甚至支持 OkHttp，具体方法可以看 Jake 大神的这个 Gist 文件： https://gist.github.com/JakeWharton/5616899 而且 Volley 里面也封装了 ImageLoader ，所以如果你愿意你甚至不需要使用图片加载框架，不过这块功能没有一些专门的图片加载框架强大，对于简单的需求可以使用，对于稍复杂点的需求还是需要用到专门的图片加载框架。 Volley 也有缺陷，比如不支持 post 大数据，所以不适合上传文件。不过 Volley 设计的初衷本身也就是为频繁的、数据量小的网络请求而生！ 关于 Volley 的具体用法可以见我很早在 GitHub 的一个 demo ： https://github.com/stormzhang/AndroidVolley 4. RetrofitRetrofit 是 Square 公司出品的默认基于 OkHttp 封装的一套 RESTful 网络请求框架，不了解 RESTful 概念的不妨去搜索学习下，RESTful 可以说是目前流行的一套 api 设计的风格，并不是标准。Retrofit 的封装可以说是很强大，里面涉及到一堆的设计模式，你可以通过注解直接配置请求，你可以使用不同的 http 客户端，虽然默认是用 http ，可以使用不同 Json Converter 来序列化数据，同时提供对 RxJava 的支持，使用 Retrofit + OkHttp + RxJava + Dagger2 可以说是目前比较潮的一套框架，但是需要有比较高的门槛。 Retrofit 的具体使用方法与地址在这里： http://square.github.io/retrofit/ 5. Volley VS OkHttp毫无疑问 Volley 的优势在于封装的更好，而使用 OkHttp 你需要有足够的能力再进行一次封装。而 OkHttp 的优势在于性能更高，因为 OkHttp 基于 NIO 和 Okio ，所以性能上要比 Volley更快。 估计有些读者不理解 IO 和 NIO 的概念，这里姑且简单提下，这两个都是 Java 中的概念，如果我从硬盘读取数据，第一种方式就是程序一直等，数据读完后才能继续操作，这种是最简单的也叫阻塞式 IO，还有一种就是你读你的，我程序接着往下执行，等数据处理完你再来通知我，然后再处理回调。而第二种就是 NIO 的方式，非阻塞式。 所以 NIO 当然要比 IO 的性能要好了， 而 Okio 是 Square 公司基于 IO 和 NIO 基础上做的一个更简单、高效处理数据流的一个库。 理论上如果 Volley 和 OkHttp 对比的话，我更倾向于使用 Volley，因为 Volley 内部同样支持使用 OkHttp ，这点 OkHttp 的性能优势就没了，而且 Volley 本身封装的也更易用，扩展性更好些。 6. OkHttp VS Retrofit毫无疑问，Retrofit 默认是基于 OkHttp 而做的封装，这点来说没有可比性，肯定首选 Retrofit。 7. Volley VS Retrofit这两个库都做了非常不错的封装，但是 Retrofit 解耦的更彻底，尤其 Retrofit 2.0 出来，Jake 对之前 1.0 设计不合理的地方做了大量重构，职责更细分，而且 Retrofit 默认使用 OkHttp ，性能上也要比 Volley 占优势，再有如果你的项目如果采用了 RxJava ，那更该使用 Retrofit 。 所以说这两个库相比，Retrofit 毫无疑问更有优势，你在能掌握两个框架的前提下该优先使用 Retrofit。但是个人认为 Retrofit 门槛要比 Volley 稍高些，你要理解他的原理，各种用法，想彻底搞明白还是需要花些功夫的，如果你对它一知半解，那还是建议在商业项目使用 Volley 吧。 8. 总结所以综上，如果以上三种网络库你都能熟练掌握，那么优先推荐使用 Retrofit ，前提是最好你们的后台 api 也能遵循 RESTful 的风格，其次如果你不想使用或者没能力掌握 Retrofit ，那么推荐使用 Volley ，毕竟 Volley 你不需要做过多的封装，当然如果你们需要上传大数据，那么不建议使用 Volley，否则你该采用 OkHttp 。 最后，我知道可能有些人会纠结 Volley 与 OkHttp 的选择，那是因为我认为 OkHttp 还是需要一定的能力做一层封装的，如果你有能力封装的话那不如直接用 Retrofit 了，如果没能力封装还是乖乖的用 Volley 吧，如果你能有一些不错的基于 OkHttp 封装好的开源库，那么另说了，Volley 与 OkHttp 怎么选择随你便呗。 最最后，以上只是我一家之言，如有误导，概不负责！欢迎讨论与交流 注：本文转自stormzhang，原文链接：https://zhuanlan.zhihu.com/p/21879931","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"转载","slug":"转载","permalink":"http://qiracle.github.io/tags/转载/"}]},{"title":"指针的九条铁律","slug":"20170102","date":"2017-01-01T16:00:00.000Z","updated":"2019-10-26T07:19:25.879Z","comments":true,"path":"2017/01/02/20170102/","link":"","permalink":"http://qiracle.github.io/2017/01/02/20170102/","excerpt":"铁律1：指针是一种数据类型1）指针也是一种变量，占有内存空间，用来保存内存地址 测试指针变量占有内存空间大小 2）*p操作内存 在指针声明时，*号表示所声明的变量为指针 在指针使用时，*号表示 操作 指针所指向的内存空间中的值 *p相当于通过地址(p变量的值)找到一块内存；然后操作内存 *p放在等号的左边赋值（给内存赋值） *p放在等号的右边取值（从内存获取值）","text":"铁律1：指针是一种数据类型1）指针也是一种变量，占有内存空间，用来保存内存地址 测试指针变量占有内存空间大小 2）*p操作内存 在指针声明时，*号表示所声明的变量为指针 在指针使用时，*号表示 操作 指针所指向的内存空间中的值 *p相当于通过地址(p变量的值)找到一块内存；然后操作内存 *p放在等号的左边赋值（给内存赋值） *p放在等号的右边取值（从内存获取值）3）指针变量和它指向的内存块是两个不同的概念 //含义1 给p赋值p=0x1111; 只会改变指针变量值，不会改变所指的内容；p = p +1; //p++ //含义2 给p赋值p=’a’; 不会改变指针变量的值，只会改变所指的内存块的值 //含义3 =左边p 表示 给内存赋值， =右边p 表示取值 含义不同切结！ //含义4 =左边char *p //含义5 保证所指的内存块能修改 4）指针是一种数据类型，是指它指向的内存空间的数据类型 含义1：指针步长（p++），根据所致内存空间的数据类型来确定 p++=(unsigned char )p+sizeof(a); 结论：指针的步长，根据所指内存空间类型来定。 注意： 建立指针指向谁，就把把谁的地址赋值给指针。图和代码和二为一。 不断的给指针变量赋值，就是不断的改变指针变量（和所指向内存空间没有任何关系）。 铁律2：间接赋值（*p）是指针存在的最大意义1）两码事：指针变量和它指向的内存块变量 2）条件反射：指针指向某个变量，就是把某个变量地址否给指针 3）*p间接赋值成立条件：3个条件 a)2个变量（通常一个实参，一个形参） b) 建立关系，实参取地址赋给形参指针 c) *p形参去间接修改实参的值 Int iNum = 0; //实参 int *p = NULL; p = &iNum; iNum = 1; p =2 ; //通过形参 == 间接地改变实参的值 *p成立的三个条件： 4）引申： 函数调用时,用n指针（形参）改变n-1指针（实参）的值。 //改变0级指针（int iNum = 1）的值有2种方式 //改变1级指针（eg char *p = 0x1111 ）的值，有2种方式 //改变2级指针的（eg char **pp1 = 0x1111 ）的值，有2种方式 //函数调用时，形参传给实参，用实参取地址，传给形参，在被调用函数里面用*p，来改变实参，把运算结果传出来。 //指针作为函数参数的精髓。 铁律3：理解指针必须和内存四区概念相结合1） 主调函数 被调函数 a) 主调函数可把堆区、栈区、全局数据内存地址传给被调用函数 b) 被调用函数只能返回堆区、全局数据 2） 内存分配方式 a) 指针做函数参数，是有输入和输出特性的。 铁律4：应用指针必须和函数调用相结合（指针做函数参数） 指针做函数参数，问题的实质不是指针，而是看内存块，内存块是1维、2维。 1） 如果基础类int变量，不需要用指针； 2） 若内存块是1维、2维。 铁律5：一级指针典型用法（指针做函数参数）一级指针做输入 int showbuf(char *p) int showArray(int *array, int iNum) 一级指针做输出 int geLen(char pFileName, int pfileLen); 理解 主调函数还是被调用函数分配内存 被调用函数是在heap/stack上分配内存 铁律6：二级指针典型用法（指针做函数参数）二级指针做输入 int main(int arc ,char *arg[]); 字符串数组 int shouMatrix(int [3][4], int iLine); 二级指针做输出 int Demo64_GetTeacher(Teacher **ppTeacher); int Demo65_GetTeacher_Free(Teacher **ppTeacher); int getData(char *data, int dataLen); Int getData_Free(void *data); Int getData_Free2(void **data); //避免野指针 理解 主调函数还是被调用函数分配内存 被调用函数是在heap/stack上分配内存 铁律7： 三级指针输出典型用法三级指针做输出 int getFileAllLine(char **content, int pLine); int getFileAllLine_Free(char **content, int pLine); 理解 主调函数还是被调用函数分配内存 被调用函数是在heap/stack上分配内存 铁律8：杂项，指针用法几点扩充1）野指针 2种free形式 int getData(char *data, int dataLen); int getData_Free(void *data); int getData_Free2(void **data); 2）2次调用 主调函数第一次调用被调用函数求长度；根据长度，分配内存，调用被调用函数。 3）返回值char /int/char * 4）C程序书写结构 商业软件，每一个出错的地方都要有日志，日志级别 铁律9：一般应用禁用malloc/new","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://qiracle.github.io/tags/C-C/"}]},{"title":"C语言中三种拷贝函数的区别","slug":"20170101","date":"2016-12-31T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2017/01/01/20170101/","link":"","permalink":"http://qiracle.github.io/2017/01/01/20170101/","excerpt":"strcpy： 最常用的字符串拷贝函数，但是要注意这个函数不会自己判断源字符串是否比目标空间大，必须要程序员自己检查，否则很容易造成拷贝越界，下面是几个例子： char *a = &quot;0123456789&quot;, *b = &quot;abcdefghijk&quot;; char c[5]; 输出： strcpy(c,a)=0123456789 //数组c只有5个字节的空间，但是经过strcpy后a的剩余字符也拷贝过去了，如果c后面是系统程序空间，那就要出问题了。","text":"strcpy： 最常用的字符串拷贝函数，但是要注意这个函数不会自己判断源字符串是否比目标空间大，必须要程序员自己检查，否则很容易造成拷贝越界，下面是几个例子： char *a = &quot;0123456789&quot;, *b = &quot;abcdefghijk&quot;; char c[5]; 输出： strcpy(c,a)=0123456789 //数组c只有5个字节的空间，但是经过strcpy后a的剩余字符也拷贝过去了，如果c后面是系统程序空间，那就要出问题了。 strncpy：strcpy的改进版本，多了一个拷贝长度的参数。需要注意的是长度参数应该为目的空间的大小，并且这个函数不会自己附加字符串结束符’\\0’，要自己加。看下面的例子： strncpy(c,b,strlen(b))=abcdefghijkw //拷贝长度不对，还是越界 strncpy(c,a,sizeof(c))=01234fghijkw //拷贝长度正确，但是因为拷贝长度内不包括&apos;\\0&apos;，所以输出的时候还是会把原本的空间内容输出，知道遇到一个结束符&apos;\\0&apos;。 所以正确的做法应该是： strncpy(c, a, sizeof(c)-1); c[5] = ‘\\0’; memcpy： 最后说一下这个函数，这个函数是个很强大的工具，因为它可以简单的根据字节数拷贝内存空间内容，所以经常被用于结构体的拷贝。需要注意两点：1、memcpy拷贝的时候源空间的长度和目标空间的长度都需要程序员自己考虑，如果按照源空间的长度拷贝，要注意是否会写溢出，如果按照目标空间的长度拷贝，则要考虑是否造成读溢出（把不该拷贝的内容也拷贝过去了），而读溢出在某些系统环境下（比如AIX），可能会造成coredump（当读到不该读的地址）；2、源空间和目标空间不能重叠。如下例： char src1[] = &quot;src1&quot;, src2[]=&quot;source2, this is a long src&quot;; char dest[] = &quot;destination&quot;; 输出： memcpy(dest, src1, strlen(dest)） = src1 //读越界 memcpy(dest, src2, strlen(src2)） = source2, this is a long srcis is a long src //写越界 memcpy(dest, dest+2, strlen(dest2) = stination // 重叠，结果是混乱 char p1[]=&quot;123456789&quot;； char p2[]=&quot;******&quot;; memcpy(p1,p2,6); printf(&quot;%s\\n&quot;,p1);// 结果：******789 部分覆盖","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://qiracle.github.io/tags/C-C/"}]},{"title":"技术不是全部（转）","slug":"20161231","date":"2016-12-30T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2016/12/31/20161231/","link":"","permalink":"http://qiracle.github.io/2016/12/31/20161231/","excerpt":"摆脱技术性思维技术人最大的优势就在于思维缜密，考虑事情比较全面，逻辑性较强。产品经理提出一些天马行空的想法时，总能第一时间评估可行性，给出实现方案，让看似缥缈的想法变成现实。 然而这种技术性思维很容易形成一种思维定式，直接导致的结果就是不管任何事，总是 if…else，总是从技术的角度出发去考虑事情。这反而会成为技术人的一个限制，造成思维局限，要知道这世界上的事情并不一定非是即否的，很多时候从技术的角度去思考问题反而会大打折扣。","text":"摆脱技术性思维技术人最大的优势就在于思维缜密，考虑事情比较全面，逻辑性较强。产品经理提出一些天马行空的想法时，总能第一时间评估可行性，给出实现方案，让看似缥缈的想法变成现实。 然而这种技术性思维很容易形成一种思维定式，直接导致的结果就是不管任何事，总是 if…else，总是从技术的角度出发去考虑事情。这反而会成为技术人的一个限制，造成思维局限，要知道这世界上的事情并不一定非是即否的，很多时候从技术的角度去思考问题反而会大打折扣。 举个例子，产品经理有一个很棒的创意，然后技术部门去评估，觉得实现起来太复杂，于是给出建议，把需求做了大幅简化，这就是典型的技术性思维。而摆脱技术性思维是什么样子的？是先不管它的技术复杂度，应该先仔细评估下这个创意是不是真的很棒，是不是真的对用户很有价值，如果是，那么不管多么复杂，技术都应该想办法去克服，而不应该先觉得实现起来很复杂，而去简化需求。 技术人有转做产品经理的，技术是他的优势，这个优势很明显，然而如果摆脱不了技术性思维，那么将会极大的制约产品的发展。 技术性思维不止影响着工作中，在生活中同样有很大影响，同学聚会，你跟人聊天，大谈特谈你的技术方向，自认为自己写的代码很炫酷、很牛逼，然而在别人眼里，那只不过就是你的职业而已，跟世界上的其他职业没有任何区别，他对你的职业不感任何兴趣。 技术人如果无法摆脱技术性思维，那么可能会极大的影响你职业发展的宽度。 你可能还有别的潜力试想有这么一个场景，你是公司技术部的一名高级工程师，由于工作表现出色，公司觉得你还有其他潜力，想让你转产品、业务或者管理，这个时候你会怎么抉择？ 这个问题不是空穴来风，我身边就有这样的例子，很多工作了 4、5 年甚至更长时间的技术人，遇到过这个情况，很困惑，不知道该怎么选择。 至于困惑的原因主要是以下几点： 技术是所有公司通用的，而业务不是，也就是说技术人跳槽要比其他跟业务相关的岗位容易的多； 业务、管理方面的能力自己比较缺乏，担心做不好； 人的精力是有限的，重心转移也就意味着技术方面会有所牺牲，而自己又不知道公司未来的发展怎么样，万一发展不好，自己跳槽，但是下份工作肯定优先还是找技术岗位，转岗对自己来说其实是一种风险； 我想以上几点是大部分人会考虑的，也是犹豫的主要原因。 这是人的本性，绝大部分人在做职业选择的时候，都会以自己最擅长的技能为第一选择，你擅长设计，不可能去投一个开发岗位，你擅长开发，也不可能去寻求一份产品工作。但是我要告诉你们这是错误的，我一直认为选择职业要以提升自身能力为第一优先，不管是你所擅长的方向还是你从没接触的领域。至于你擅长开发，而不会去投递产品岗，本质上是因为你知道肯定不会被录取。 但是公司内部，技术转业务、转管理，这是一次免费的学习机会，而且薪资、级别很可能还会提升，我想这世上再也没有给你免费学习提升自己能力，又给你发比较高的薪水的机会了吧？ 从这个角度出发，我想你应该不会再犹豫了。而我很早就明白这个道理，所以，在公司需要我转岗管理的时候毫不犹豫的转岗，这大半年的时间投入在技术的精力确实牺牲了不少，但是同样我也学习了很多，比如如何管理团队，参与业务、产品，到后面更深的理解商业，参与公司最高层次的决策等。 这些可能如果单纯的做个技术人是我很难接触到的，而且我也从不知道自己在别的领域同样也有潜力。 所以，请一定多接触下技术之外的世界，技术固然重要，但是你不试着接触下别的领域，你永远不知道你自己还有别的潜力没有发挥。 多向身边各行各业的人学习上面说了，请尽量多接触别的领域，很多时候在你没接触过之前就贸然说自己不感兴趣、来不了之类的话，只是你在为你的懒惰找借口而已。只有接触过，亲自尝试过才有资格说不感兴趣。而怎么接触别的领域呢？ 就是多向身边的人学习，你身边有大量的专业人才，设计师、产品经理、运营总监、销售经理等等，这些最宝贵的资源你却从没有好好利用，他们每一个人在他们的领域都是专业的，而你却只顾低头搞技术，从没有跟他们交流过，殊不知他们的身上可能有各种技能、思想、素养值得你学习，交流的多了，你可能会突然发现，除了技术之外，还有很好玩的东西可以学习尝试，不奢望成为职业，培养一门兴趣，增加一项技能也是极好的。 提高你的沟通表达能力职场中有没有遇到过这种现象，跟部分人讨论事情总觉得不是在一个频道，这其实本质上就是沟通能力与表达能力的问题。工程师中尤其缺乏这种能力，因为长期跟机器打交道，很少跟人接触，自然沟通表达能力较弱，但是这不是借口，为什么有的工程师交流起来很顺畅，而有的就很难交流？ 说白了，沟通表达能力其实是情商的体现，程序员相信智商都挺高，然而情商相对较缺乏。 举个例子，听说产品经理又要改需求了: 情商低的程序员通常内心 OS 是：「傻逼，又他妈改需求，真是废物！」，但是倒不敢直接说出来，顶多说：「卧槽，怎么又改了？改了多少次了？老子没法做下去了…」 情商高的程序员内心 OS 是：「傻逼，又他妈改需求，真是废物！」，嘴里说的是：「这改的有点稍频繁吧？这次为什么要这么改？对用户来说有什么区别？体验更好些么？」，如果改的不合理，还会跟产品说明不合理的地方在哪里。 第一种程序员通常是心里不爽，即使觉得需求不合理，但是也不得不做所谓的傻逼产品经理的需求改动，而第二种程序员如果觉得需求不合理，很可能通过一番交流之后，让产品经理乖乖的不改需求了。 不止工作中，我认为沟通能力与表达能力是各行各业，不管工作、生活都非常重要的一个能力。那么沟通表达能力有没有一些技巧呢？ 当然有，答案就是「换位思考」。试想如果你能从对方的角度去思考问题，那就会避免很多情绪，比如程序员可能会想：产品经理改需求那肯定不是平白无故的故意改需求，一定是从用户角度出发，且听听原因吧。而如果你懂得换位思考，在跟非业内人交流的时候，你肯定会考虑到对方的专业、方向，不再用你自己领域的术语跟他们交流了，而会想方设法从对方的角度重新组织语言，沟通交流起来会更顺畅，也能极大的提高沟通效率。 那么，有没有一些办法能够锻炼自己的沟通与表达能力呢？我自己的实践是，多参与团队讨论，多与人交流，甚至多写都可以有帮助。 等你真的能心平气和，说服产品经理心甘情愿把改的需求撤回的时候，那么，你的沟通表达能力就有了质的进步。 努力赚钱说到底，我们认真搞技术就是为了赚钱，不用为钱困扰，这样我们就可以安心做自己喜欢的事，过自己想要的生活。但是你的技术真的发挥了最大的价值么？可能你空有一身好武艺，但是却没有好好利用。在公司工作，只是你技术发挥价值的一部分，但是你不应该只满足于这点回报。你得相信，公司付给你的薪酬要远少于你实际能创造的价值，工作之外，你还有大把的业余时间可以利用，让你的技术得到更多额外的回报。 可能你是接私活、录制收费课程、写书、做技术顾问、做个 App 或者网站等，赚钱的同时，你还可以培养其他方面的能力，或者提升名气，这都是用技术，在为你的未来投资。这种赚钱方式丢人么？简直可笑，技术是自己的能力，利用自己能力，付出了宝贵的时间，不偷不抢，这种赚钱何来丢人一说？我反而认为这是受人尊敬的行为，因为所有为梦想而努力的人，都应该受到尊敬！ 当然，如果你的技术能力还不过关，那么请先以提升技术能力为第一导向，之后再考虑如何利用你的技术，帮你创造更多的财富。 别觉得赚钱很俗，我们努力赚钱的意义，都只是为了拥有掌控命运的权利而已！ 积累人脉之前有一个话题争论很火，就是「CTO 要不要写代码？」，我个人认为这个问题有什么过多争论的，CTO 不一定需要写代码，只需要他能搞定事情就行，不管是自己出马，还是让别人来搞定，总之能搞定各种事情就是一个优秀的 CTO。 其中让别人来搞定就需要很广的人脉，而人脉是需要积累的，不管在任何地方，人脉的重要性不言而喻，我就不过多解释了。至于如何积累人脉呢？我想有各种方式与渠道，你以为有些人宁愿花几千块甚至上万块门票去参加一些技术交流会真的是去学习技术的么？那就太天真的，很大的可能只是为了去认识一些行业牛人，积累一些人脉而已。不过想积累人脉，请记住最重要的一点，你不能只奢望那些人脉给你提供什么，你得先想清楚你能给他们带来什么，所有人的时间都是宝贵的，任何人都没有责任一直给你提供无偿帮助。 最后，以上是我自己的看法与人生经验，不期望每个人都认同，仅做参考，不喜勿喷。无论如何，这些人生经验在别处可是没人愿意分享出来的，希望对你们有点用。 注：本文转自stormZhang,微信公众号AndroidDeveloper","categories":[{"name":"生活感悟","slug":"生活感悟","permalink":"http://qiracle.github.io/categories/生活感悟/"}],"tags":[{"name":"转载","slug":"转载","permalink":"http://qiracle.github.io/tags/转载/"}]},{"title":"内存泄露与野指针","slug":"20161230","date":"2016-12-29T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2016/12/30/20161230/","link":"","permalink":"http://qiracle.github.io/2016/12/30/20161230/","excerpt":"内存泄露也称作“存储渗漏” ,用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元。直到程序结束。即所谓内存泄漏。 内存泄漏概念 简单的说就是申请了一块内存空间，使用完毕后没有释放掉。它的一般表现方式是程序运行时间越长，占用内存越多，最终用尽全部内存，整个系统崩溃。由程序申请的一块内存，且没有任何一个指针指向它","text":"内存泄露也称作“存储渗漏” ,用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元。直到程序结束。即所谓内存泄漏。 内存泄漏概念 简单的说就是申请了一块内存空间，使用完毕后没有释放掉。它的一般表现方式是程序运行时间越长，占用内存越多，最终用尽全部内存，整个系统崩溃。由程序申请的一块内存，且没有任何一个指针指向它，那么这块内存就泄露了。 泄漏的分类 以发生的方式来分类，内存泄漏可以分为4类： 1.常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。 2.偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。 3.一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。 4.隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。 从用户使用程序的角度来看，内存泄漏本身不会产生什么危害，作为一般的用户，根本感觉不到内存泄漏的存在。真正有危害的是内存泄漏的堆积，这会最终消耗尽系统所有的内存。从这个角度来说，一次性内存泄漏并没有什么危害，因为它不会堆积，而隐式内存泄漏危害性则非常大，因为较之于常发性和偶发性内存泄漏它更难被检测到。 内存泄漏的表现 内存泄漏或者是说，资源耗尽后，系统会表现出什么现象呢？ 1.cpu资源耗尽：估计是机器没有反应了，键盘，鼠标，以及网络等等。这个在windows上经常看见，特别是中了毒。2.进程id耗尽：没法创建新的进程了，串口或者telnet都没法创建了。 3.硬盘耗尽：机器要死了，交换内存没法用，日志也没法用了，死是很正常的。 内存泄漏或者内存耗尽：新的连接无法创建，free的内存比较少。发生内存泄漏的程序很多，但是要想产生一定的后果，就需要这个进程是无限循环的，是个服务进程。当然，内核也是无限循环的，所以，如果内核发生了内存泄漏，情况就更加不妙。内存泄漏是一种很难定位和跟踪的错误，目前还没看到有什么好用的工具（当然，用户空间有一些工具，有静态分析的，也会动态分析的，但是找内核的内存泄漏，没有好的开源工具） 内存泄漏和对象的引用计数有很大的关系，再加上c/c++都没有自动的垃圾回收机制，如果没有手动释放内存，问题就会出现。如果要避免这个问题，还是要从代码上入手，良好的编码习惯和规范，是避免错误的不二法门。 一般我们常说的内存泄漏是指堆内存的泄漏。 堆内存是指程序从堆中分配的，大小任意的（内存块的大小可以在程序运行期决定），使用完后必须显示释放的内存。 应用程序一般使用malloc，new等函数从堆中分配到一块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了。 野指针 “野指针”不是NULL指针，是指向“垃圾”内存的指针。人们一般不会错用NULL指针，因为用if语句很容易判断。但是“野指针”是很危险的，if语句对它不起作用。野指针的成因主要有两种： 1.指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。 2.指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。别看free和delete的名字恶狠狠的（尤其是delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。通常会用语句if (p != NULL)进行防错处理。很遗憾，此时if语句起不到防错作用，因为即便p不是NULL指针，它也不指向合法的内存块。 例： char *p = (char *) malloc(100); strcpy(p, “hello”); printf(“%s ”,p); free(p); // p 所指的内存被释放，但是p所指的地址仍然不变 if(p != NULL) // 没有起到防错作用 strcpy(p, “world”); // 出错 printf(“%s \\n”,p); 以上代码的输出结果是helloworld。 free()释放的是指针指向的内存！注意！释放的是内存，不是指针！这点非常非常重要！指针是一个变量，只有程序结束时才被销毁。释放了内存空间后，原来指向这块空间的指针还是存在！只不过现在指针指向的内容的垃圾，是未定义的，所以说是垃圾。因此，前面我已经说过了，释放内存后把指针指向NULL，防止指针在后面不小心又被解引用了。非常重要啊这一点！通俗点说，free的作用就是把你合法居住的房子，取消你的居住资格，而没有拆房子，你还可以去那个房子住，但是警察(system)可以在任何时候把你赶走。 另外一个要注意的问题：不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://qiracle.github.io/tags/C-C/"}]},{"title":"python学习（三）——字典","slug":"20161229","date":"2016-12-28T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2016/12/29/20161229/","link":"","permalink":"http://qiracle.github.io/2016/12/29/20161229/","excerpt":"创建字典>&gt;&gt; d1 = {} >&gt;&gt; d2 = {‘player’:’QVOD’,’game’:’kw’} >&gt;&gt; d1,d2 ({}, {‘player’: ‘QVOD’, ‘game’: ‘kw’}) >&gt;&gt; d3 = dict(([‘name’,’alex’],[‘sex’,’man’])) >&gt;&gt; d3","text":"创建字典>&gt;&gt; d1 = {} >&gt;&gt; d2 = {‘player’:’QVOD’,’game’:’kw’} >&gt;&gt; d1,d2 ({}, {‘player’: ‘QVOD’, ‘game’: ‘kw’}) >&gt;&gt; d3 = dict(([‘name’,’alex’],[‘sex’,’man’])) >&gt;&gt; d3{‘name’: ‘alex’, ‘sex’: ‘man’} >&gt;&gt; d33 = d3.copy() >&gt;&gt; d33 {‘name’: ‘alex’, ‘sex’: ‘man’} >&gt;&gt; d4 = {}.fromkeys((‘alex’,’zhou’),1) >&gt;&gt; d4 {‘alex’: 1, ‘zhou’: 1} >&gt;&gt; d5 = {}.fromkeys((‘alex’,’zhou’)) >&gt;&gt; d5 {‘alex’: None, ‘zhou’: None} 遍历字典ps：访问一个不存在的key时，会发生KeyError异常，访问前可使用in或not in判断一下。 d={“name”:”python”,”english”:33,”math”:35} print “##for in “ for key in d: print ‘%s,%s’ %(key,d[key]) for i in d: print “d[%s]=” % i,dict[i] print “##items” for (k,v) in d.items(): print “d[%s]=” % k,v print “##iteritems” for k,v in d.iteritems(): print “d[%s]=” % k,v >&gt;&gt; d[‘name’] ‘python’ >&gt;&gt; d2 = {‘name’:’alexzhou’,’age’:100} >&gt;&gt; print ‘name: %s,age: %d’ %(d2[‘name’],d2[‘age’]) name: alexzhou,age: 100 >&gt;&gt; d2[‘sex’] Traceback (most recent call last): File ““, line 1, in KeyError: ‘sex’ >&gt;&gt; ‘sex’ in d2 False >&gt;&gt; ‘name’ in d2 True 更新字典>&gt;&gt; d = {‘name’:’alexzhou’,’age’:100} >&gt;&gt; d[‘age’] = 88 >&gt;&gt; d {‘age’: 88, ‘name’: ‘alexzhou’} >&gt;&gt; d.pop(‘age’) 88 >&gt;&gt; d {‘name’: ‘alexzhou’} >&gt;&gt; d.clear() >&gt;&gt; d {} 常用内建函数cmp()字典的比较：首先是字典的大小，然后是键，最后是值 >&gt;&gt; d1 = {‘abc’:1,’efg’:2} >&gt;&gt; d2 = {‘abc’:1,’efg’:2,’h’:3} >&gt;&gt; cmp(d1,d2) -1 >&gt;&gt; d3 = {‘ab’:1,’efg’:2} >&gt;&gt; cmp(d1,d3) 1 >&gt;&gt; d4 = {‘abc’:1,’efg’:3} >&gt;&gt; cmp(d1,d4)-1 >&gt;&gt; d5 = {‘abc’:1,’efg’:2} >&gt;&gt; cmp(d1,d5) 0 len()返回键值对的数目 >&gt;&gt; d = {‘abc’:1,’efg’:2}>&gt;&gt; len(d)2 keys()、values() 、items()keys()返回一个包含字典所有键的列表 values()返回一个包含字典所有值的列表 items()返回一个包含键值元组的列表 >&gt;&gt; d = {‘name’:’alex’,’sex’:’man’} >&gt;&gt; d.keys() [‘name’, ‘sex’] >&gt;&gt; d.values() [‘alex’, ‘man’] >&gt;&gt; d.items() [(‘name’, ‘alex’), (‘sex’, ‘man’)] dict.get(key,default=None)返回字典中key对应的value，若key不存在则返回default >&gt;&gt; d = {‘name’:’alex’,’sex’:’man’} >&gt;&gt; d.get(‘name’,’not exists’)‘alex’>&gt;&gt; d.get(‘alex’,’not exists’)‘not exists’ dict.setdefault(key,default=None)若key存在，则覆盖之前的值，若key不存在，则给字典添加key-value对 >&gt;&gt; d.setdefault(‘name’,’zhou’) ‘alex’ >&gt;&gt; d {‘name’: ‘alex’, ‘sex’: ‘man’} >&gt;&gt; d.setdefault(‘haha’,’xixi’) ‘xixi’ >&gt;&gt; d {‘haha’: ‘xixi’, ‘name’: ‘alex’, ‘sex’: ‘man’} dict.update(dict2)将字典dict2的键值对添加到dict >&gt;&gt; d = {‘name’:’alex’,’sex’:’man’} >&gt;&gt; d1 = {‘age’:100,’address’:’shenzhen’} >&gt;&gt; d.update(d1) >&gt;&gt; d {‘age’: 100, ‘address’: ‘shenzhen’, ‘name’: ‘alex’, ‘sex’: ‘man’} sorted(dict)返回一个有序的包含字典所有key的列表 >&gt;&gt; sorted(d) [‘address’, ‘age’, ‘name’, ‘sex’]","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"python","slug":"python","permalink":"http://qiracle.github.io/tags/python/"}]},{"title":"python学习（二）——列表","slug":"20161228","date":"2016-12-27T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2016/12/28/20161228/","link":"","permalink":"http://qiracle.github.io/2016/12/28/20161228/","excerpt":"列表的创建使用 [ ] 把数据包含起来，便可以创建一个列表了。 [ ] 可以不包含任何数据，则表示创建一个空列表>&gt;&gt; name = [] [ ] 也可以包含多种数据类型的数据>&gt;&gt; name = [“damao”, 30, “ermao”]","text":"列表的创建使用 [ ] 把数据包含起来，便可以创建一个列表了。 [ ] 可以不包含任何数据，则表示创建一个空列表>&gt;&gt; name = [] [ ] 也可以包含多种数据类型的数据>&gt;&gt; name = [“damao”, 30, “ermao”] 列表的打印 使用内置函数print() 便可打印整个列表里的数据”>&gt;&gt; print(name)[“damao”, 30, “ermao”] 当然也可以打印列表的某个下标的数据：>&gt;&gt; print(name[0])damao 也可以分片打印列表的某段下标的数据>&gt;&gt; print(name[0:2])[‘damao’, 30] #注意，没有打印name[2]的数据:) 如果想要分别打印列表里的每个数据，只需要一个for就可以搞定：>&gt;&gt; for each in name:print(each)damao30ermao 当然也可以直接打印出列表内数据的个数：>&gt;&gt; print(len(name))3 列表的扩展 我们可以在列表末尾追加一个任意数据类型数据：>&gt;&gt; name.append([“daoluan”, 666])>&gt;&gt; print(name)[‘damao’, 30, ‘ermao’, [‘daoluan’, 666]] 也可以在列表末尾追加一个列表里的所有数据：>&gt;&gt; name.extend([“sanmao”, 10, “simao”])>&gt;&gt; print(name)[‘damao’, 30, ‘ermao’, [‘daoluan’, 666], ‘sanmao’, 10, ‘simao’]#注意，append和entend这两个方法看起来有些类似，但实际上是不同的。append只接受一个参数，但是这个参数可以是任意数据类型，比如列表和元组等，而且只是将这个数据追加到原列表后面独立存在。extend也是只接受一个参数，不同的是这个参数必须是一个列表，而且会把这个列表的每个元素拆分出来，依次追加到原列表后面。 当然也可以在指定位置增加一个任意数据类型数据(append的既视感)：/# 第一个参数为指定的列表下标，第二个参数为增加的数据>&gt;&gt; name.insert(3, 20)>&gt;&gt; print(name)[‘damao’, 30, ‘ermao’, 20, [‘daoluan’, 666], ‘sanmao’, 10, ‘simao’] 列表的删除： 删除列表末尾的一个数据：>&gt;&gt; name.pop()>&gt;&gt; print(name)[‘damao’, 30, ‘ermao’, 20, [‘daoluan’, 666], ‘sanmao’, 10] 也可以删除列表指定的某一个数据：>&gt;&gt; name.remove(“sanmao”)>&gt;&gt; print(name)[‘damao’, 30, ‘ermao’, 20, [‘daoluan’, 666], 10] 或者删除列表的某个下标的数据：>&gt;&gt; del(name[4])>&gt;&gt; print(name)[‘damao’, 30, ‘ermao’, 20, 10]#注意，de()函数支持列表分片删除，同样的，也支持删除整个列表。 列表的合并：只需要像I + I + I = III一样，就可以合并多个列表：>&gt;&gt; mao = name + [20, “ermao”] + [30, “damao”]>&gt;&gt; print(mao)[‘damao’, 30, ‘ermao’, 20, 10, 20, ‘ermao’, 30, ‘damao’] 列表的排序：首先，列表里的每个元素类型相同才可以进行排序，对此我们可以选择手写排序算法，也可以选择Pythoy提供的更简便且强大的的方法：sort()和sorted() 原地排序：>&gt;&gt; fruit = [“banana”, “pear”, “orange”, “apple”]>&gt;&gt; fruit.sort()>&gt;&gt; print(fruit)[‘apple’, ‘banana’, ‘orange’, ‘pear’]# sort() 方法可以在原列表的基础上进行排序，同时改变原列表的顺序。 复制排序：>&gt;&gt; nums = [23, 12, -34, 0, 101, 2]>&gt;&gt;newNums = sorted(nums)>&gt;&gt; print(newNums)[-34, 0, 2, 12, 23, 101]>&gt;&gt; print(nums)[23, 12, -34, 0, 101, 2]# sorted() 函数通过复制排序可以对几乎任何数据结构排序，同时返回一个新的排序后的数据结构，而且不会改变原数据结构的序列。#注意，不管使用sort()还是使用sorted()，默认都是升序排序。如果想按照降序排序，只要传入 reverse = True 参数就可以啦，比如 fruit.sort(reverse = True) 或者 newNums = sorted(nums, reverse = True)","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"python","slug":"python","permalink":"http://qiracle.github.io/tags/python/"}]},{"title":"python学习（一）——常用字符串函数","slug":"20161227","date":"2016-12-26T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2016/12/27/20161227/","link":"","permalink":"http://qiracle.github.io/2016/12/27/20161227/","excerpt":"字母处理1.string.capitalize() 返回元字符串，且将字符串第一个字母转为大写，其它字母小写 2.string.title() 返回元字符串，且将字符串第一个字母转为大写，其它字母小写 3.string.swapcase() 用于对字符串的大小写字母进行转换，小写字符转为大写，大写字母转为小写","text":"字母处理1.string.capitalize() 返回元字符串，且将字符串第一个字母转为大写，其它字母小写 2.string.title() 返回元字符串，且将字符串第一个字母转为大写，其它字母小写 3.string.swapcase() 用于对字符串的大小写字母进行转换，小写字符转为大写，大写字母转为小写 4.string.upper() 将字符串全部转为大写 5.string.lower() 将字符串全部转为小写 去除空格或者指定字符串1.string.strip([string]) 去除字符串中首尾的字符串，不带参数默认去除空格 2.string.lstrip([string]) 去除字符串左边字符串，不带参数默认去除空格 3.string.rstrip([string]) 去除字符串右边字符串，不带参数默认去除空格 格式化对齐1.string.center(width[, fillchar]) 返回一个原字符串居中对齐，width为总长度，两边用一个字符fillchar填充，如果指定的长度小于原字符串的长度则返回原字符串。注意：如果fillchar超过1个长度或为非字符串或为汉字，则会报出异常 2.string.ljust(width[, fillchar]) 返回原字符串左对齐,并使用空格填充至指定长度的新字符串，如果指定的长度小于原字符串的长度则返回原字符串。注意：如果fillchar超过1个长度或为非字符串或为汉字，则会报出异常 3.string.rjust(width[, fillchar]) 返回原字符串右对齐,并使用空格填充至指定长度的新字符串，如果指定的长度小于字符串的长度则返回原字符串。注意：如果fillchar超过1个长度或为非字符串或为汉字，则会报出异常 4.string.zfill() 返回指定长度的字符串，原字符串右对齐，前面填充0 替换1.string.replace(old, new[, count]) 用新的字符替换老字符，还可以指定替换的个数，默认全部替换 2.string.expandtabs([n]) 将字符串中(tab符号)\\t转换成n个空格 字符串搜索1.string.find(sub [,start [,end]]) 返回sub字符串第一次出现的索引位置，可以通过start和stop参数设置搜索范围，如果未找到sub时返回-1 2.string.rfind(sub [,start [,end]]) 返回sub字符串最后一次出现的索引位置，如果没有匹配项则返回-1，可以通过start和stop参数设置搜索范围 3.string.index(sub [,start [,end]]) 类似于string.find()方法。注意：未找到sub时会报出异常 4.string.rindex(sub [,start [,end]]) 类似于string.rfind()方法。注意：未找到sub时会报出异常 字符串分割1.string.split([sep [,maxsplit]]) 用来根据指定的分隔符将字符串进行分割，不包含分隔符，结果存为列表，不指定sep时，默认将将空格作为分隔符 2.string.partition(sep) 用来根据指定的分隔符将字符串进行分割，分割点为首次出现sep的地方，且包含分隔符，结果存为元组，且固定为3个元素，如果sep不存在字符串中，则后面2个元素为空 3.string.rpartiton() 用来根据指定的分隔符将字符串进行分割，分割点为最后一次出现sep的地方，且包含分隔符，结果存为元组，且固定为3个元素，如果sep不存在字符串中，则前面2个元素为空 字符串判断1.string.isupper() 返回字符串中是否全为大写 –&gt; True/False 2.string.islower() 返回字符串中是否全为小写 –&gt; True/False 3.string.isdigit() 返回字符串中是否只包含数字 –&gt; True/False 4.string.isalpha() 返回字符串中是否只包含字母 –&gt; True/False 5.string.isalnum() 返回字符串中是否只包含字母或数字 –&gt; True/False 6.string.isspace() 返回字符串中是否只包含空格（tab也算空格） –&gt; True/False 7.string.istitle() 返回字符串中首字母是否大写 –&gt; True/False 8.string.startswith(prefix[, start[, end]]) 返回字符串是否以某字符串开始，可以通过start和stop参数设置搜索范围 9.string.endswith(suffix[, start[, end]]) 返回字符串是否以某个字符串结束 可以通过start和stop参数设置搜索范围 其它1.string.count(sub[, start[, end]]) 计数字符串中某子集的数量，可以通过start和stop参数设置搜索范围 2.len(string) 获取字符串的长度 3.list(string) 字符串转列表 4.string.join(iterable) 列表转字符串，用于将序列中的元素以指定的字符string连接生成一个新的字符串。注意：iterable只能是字符串类型，否则会报出异常 5.string.encode(encoding=’UTF-8’,errors=’strict’) 以 encoding 指定的编码格式编码字符串 6.string.decode(encoding=’UTF-8’,errors=’strict’) 解码字符串，出错默认报ValueError,除非errors是ignore或replace 7.string.translate(table [,deletechars]) 根据参数table给出的表(包含 256 个字符)转换字符串的字符, 要过滤掉的字符放到deletechars参数中","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"python","slug":"python","permalink":"http://qiracle.github.io/tags/python/"}]},{"title":"java中throws和throw的区别","slug":"20161226","date":"2016-12-25T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2016/12/26/20161226/","link":"","permalink":"http://qiracle.github.io/2016/12/26/20161226/","excerpt":"throws 用在方法声明后面，跟的是异常类名 可以跟多个异常类名，用逗号隔开 表示抛出异常，由该方法的调用者来处理 throws表示出现异常的一种可能性，并不一定会发生这些异常","text":"throws 用在方法声明后面，跟的是异常类名 可以跟多个异常类名，用逗号隔开 表示抛出异常，由该方法的调用者来处理 throws表示出现异常的一种可能性，并不一定会发生这些异常 throw 用在方法体内，跟的是异常对象名 只能抛出一个异常对象名 表示抛出异常，由方法体内的语句处理 throw则是抛出了异常，执行throw则一定抛出了某种异常","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"java","slug":"java","permalink":"http://qiracle.github.io/tags/java/"}]},{"title":"Android中实现Listview下拉刷新的核心代码解析","slug":"20161225","date":"2016-12-24T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2016/12/25/20161225/","link":"","permalink":"http://qiracle.github.io/2016/12/25/20161225/","excerpt":"private void initHeaderView(){ //初始化headerView mHeaderView = View.inflate(getContext(), R.layout.refresh_header, null);//获得headerView this.addHeaderView(mHeaderView);//将headerView加在listView的上面 tvTitle = (TextView) mHeaderView.findViewById(R.id.tv_title);//刷新的提示文字 tvTime = (TextView) mHeaderView.findViewById(R.id.tv_time);//刷新的时间显示 ivArrow = (ImageView) mHeaderView.findViewById(R.id.iv_arr);//下拉箭头 pbProgress = (ProgressBar) mHeaderView.findViewById(R.id.pb_progress);//旋转的进度条 mHeaderView.measure(0, 0); mHeaderViewHeight = mHeaderView.getMeasuredHeight();//测得headerView的高度 mHeaderView.setPadding(0, -mHeaderViewHeight, 0, 0);// 隐藏头布局 initArrowAnim();// 初始化箭头动画 }","text":"private void initHeaderView(){ //初始化headerView mHeaderView = View.inflate(getContext(), R.layout.refresh_header, null);//获得headerView this.addHeaderView(mHeaderView);//将headerView加在listView的上面 tvTitle = (TextView) mHeaderView.findViewById(R.id.tv_title);//刷新的提示文字 tvTime = (TextView) mHeaderView.findViewById(R.id.tv_time);//刷新的时间显示 ivArrow = (ImageView) mHeaderView.findViewById(R.id.iv_arr);//下拉箭头 pbProgress = (ProgressBar) mHeaderView.findViewById(R.id.pb_progress);//旋转的进度条 mHeaderView.measure(0, 0); mHeaderViewHeight = mHeaderView.getMeasuredHeight();//测得headerView的高度 mHeaderView.setPadding(0, -mHeaderViewHeight, 0, 0);// 隐藏头布局 initArrowAnim();// 初始化箭头动画 } @Override public boolean onTouchEvent(MotionEvent ev) { switch (ev.getAction()) { case MotionEvent.ACTION_DOWN://手指按在屏幕上时 startY = (int) ev.getRawY();//获取手指所按的Y坐标 break; case MotionEvent.ACTION_MOVE://手指在屏幕上滑动 if (startY == -1) {// 确保startY有效 startY = (int) ev.getRawY(); } if (mCurrrentState == STATE_REFRESHING) {// 正在刷新时不做处理 break; } int endY = (int) ev.getRawY();//时刻获取手指滑动时的坐标 int dy = endY - startY;// 移动偏移量 if (dy &gt; 0 &amp;&amp; getFirstVisiblePosition() == 0) {// 只有下拉并且当前是第一个item,才允许下拉 /* 计算padding，最开始时padding为负的mHeaderViewHeight， 此时HeaderView隐藏在Listview上方,随着手指下滑，移动偏移量dy增大，HeaderView一点点被拖出来显示在屏幕上， 当dy正好等于mHeaderViewHeight时，padding为0，也就说此时HeaderView正好完全在屏幕上方显示出来*/ int padding = dy - mHeaderViewHeight; mHeaderView.setPadding(0, padding, 0, 0);// 设置当前padding if (padding &gt; 0 &amp;&amp; mCurrrentState != STATE_RELEASE_REFRESH) { /* 当padding大于0时，说明此时HeaderView已经完全展示出来,可以松开手指进行刷新了， 如果此时状态不为松开刷新状态则将状态改为松开刷新，提示用户。*/ mCurrrentState = STATE_RELEASE_REFRESH; refreshState(); } else if (padding &lt; 0 &amp;&amp; mCurrrentState != STATE_PULL_REFRESH) { /* 如果padding小于0，这说明HeaderView并没有完全展示出来， 用户可以继续下拉，此时如果状态不为下拉刷新则将状态改为下拉刷新提示用户。*/ mCurrrentState = STATE_PULL_REFRESH; refreshState(); } return true; } break; case MotionEvent.ACTION_UP://手指抬起 startY = -1;// 重置 if (mCurrrentState == STATE_RELEASE_REFRESH){//如果此时状态为松开刷新 mCurrrentState = STATE_REFRESHING;//将状态改为正在刷新 正在刷新 mHeaderView.setPadding(0, 0, 0, 0);// 显示HeaderView refreshState(); } else if (mCurrrentState == STATE_PULL_REFRESH) {//如果此时状态为下拉刷新,说明HeaderView没有 被完全显示出来，按照实际,只有完全拖拽显示出来才进行刷新 mHeaderView.setPadding(0, -mHeaderViewHeight, 0, 0);// 将HeaderView收缩回去隐藏起来， } break; default: break; } return super.onTouchEvent(ev); } /* * 刷新下拉控件的布局 */ private void refreshState() { switch (mCurrrentState) { case STATE_PULL_REFRESH: tvTitle.setText(&quot;下拉刷新&quot;);//更改状态显示文字 ivArrow.setVisibility(View.VISIBLE);//设置下拉箭头可见 pbProgress.setVisibility(View.INVISIBLE);//进度条不可见 ivArrow.startAnimation(animDown);开启动画 break; case STATE_RELEASE_REFRESH: tvTitle.setText(&quot;松开刷新&quot;); ivArrow.setVisibility(View.VISIBLE); pbProgress.setVisibility(View.INVISIBLE); ivArrow.startAnimation(animUp); break; case STATE_REFRESHING: tvTitle.setText(&quot;正在刷新...&quot;); ivArrow.clearAnimation();// 必须先清除动画,才能隐藏 ivArrow.setVisibility(View.INVISIBLE); pbProgress.setVisibility(View.VISIBLE); if (mListener != null) { mListener.onRefresh(); } break; default: break; } } /** * 初始化箭头动画 */ private void initArrowAnim() { // 箭头向上动画 animUp = new RotateAnimation(0, -180, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); animUp.setDuration(200); animUp.setFillAfter(true); // 箭头向下动画 animDown = new RotateAnimation(-180, 0, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); animDown.setDuration(200); animDown.setFillAfter(true); }","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiracle.github.io/tags/Android/"}]},{"title":"Eclipse下Android应用程序签名打包","slug":"20161224","date":"2016-12-23T16:00:00.000Z","updated":"2019-10-26T07:19:05.323Z","comments":true,"path":"2016/12/24/20161224/","link":"","permalink":"http://qiracle.github.io/2016/12/24/20161224/","excerpt":"1.右击项目，选择Android Tools—&gt;Export Signed Application Package 2.没有签名文件的话则选择第二个Create new keystore，选择签名文件保存的路径，记住自己所填的密码","text":"1.右击项目，选择Android Tools—&gt;Export Signed Application Package 2.没有签名文件的话则选择第二个Create new keystore，选择签名文件保存的路径，记住自己所填的密码 3.填写相应信息 4.选择apk文件生成的路径，点击finish完成即可","categories":[{"name":"教程","slug":"教程","permalink":"http://qiracle.github.io/categories/教程/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiracle.github.io/tags/Android/"}]},{"title":"回忆2016","slug":"2016summary","date":"2016-12-22T16:00:00.000Z","updated":"2019-10-26T07:15:48.764Z","comments":true,"path":"2016/12/23/2016summary/","link":"","permalink":"http://qiracle.github.io/2016/12/23/2016summary/","excerpt":"2016年对我来说是充满收获与回忆的一年，更是不寻常的一年，经历了太多之前从未经历过的事情。我想这一年可以大致可以分为三个阶段。 迪拜-德黑兰之旅 从去年年底开始，老师就一直提醒我寒假回家记得办护照，明年出国比赛，去的是伊朗首都德黑兰和德国的莱比锡（这个后来没去成）。当时我知道我们学校RoboCup团队每年都会有学生出国比赛，而且成绩还不错，所以我当时我就觉得这是个难得的机会但对我来说更是个挑战。因为学校花了那么多钱让你出国，成绩难看的话，也不好交代。所以寒假在家一方面在不停的改代码，调试球队，另一方面则在准备比赛报名审核的材料，由于报名网站全英文再加上与那边互通邮件也用的英文，所以当时觉得英语水平好真的是太重要了！开学那天，伊朗那边比赛的审核认证通过了，这就代表我们伊朗那边肯定能去了。然后是等德国那边的审核结果，过了俩星期，结果出来了，出事了，由于代码不恰当的引用，涉及侵权，然后被拒绝参赛。好吧确实有些伤感。。","text":"2016年对我来说是充满收获与回忆的一年，更是不寻常的一年，经历了太多之前从未经历过的事情。我想这一年可以大致可以分为三个阶段。 迪拜-德黑兰之旅 从去年年底开始，老师就一直提醒我寒假回家记得办护照，明年出国比赛，去的是伊朗首都德黑兰和德国的莱比锡（这个后来没去成）。当时我知道我们学校RoboCup团队每年都会有学生出国比赛，而且成绩还不错，所以我当时我就觉得这是个难得的机会但对我来说更是个挑战。因为学校花了那么多钱让你出国，成绩难看的话，也不好交代。所以寒假在家一方面在不停的改代码，调试球队，另一方面则在准备比赛报名审核的材料，由于报名网站全英文再加上与那边互通邮件也用的英文，所以当时觉得英语水平好真的是太重要了！开学那天，伊朗那边比赛的审核认证通过了，这就代表我们伊朗那边肯定能去了。然后是等德国那边的审核结果，过了俩星期，结果出来了，出事了，由于代码不恰当的引用，涉及侵权，然后被拒绝参赛。好吧确实有些伤感。。 到了去的前几天，就一直在办签证，由于伊朗对中国是落地签，相对比较方便。老师跟我们介绍了那边的一些风俗习惯，特产，还有一些景点。最后说了句，比赛的时候代码交完后，就多出去逛逛，多玩玩。。。哈哈，这说的，，我们都懂，，比赛嘛重在参与哈哈。到了4月3号这天，我们从合肥南站出发，整个行程是坐高铁到上海浦东国际机场，晚上12点的飞机飞去迪拜，在迪拜待几个小时然后转机到德黑兰。 凌晨的飞机飞了斤十个小时终于到了迪拜，飞机上又累又困，睡不好，一下飞机瞬间精神抖擞，因为很想逛一下这世界上最大的机场免税店迪拜机场免税店，里面确实很大！来来回回竟然都要坐地铁，里面的东西的价格相对国内确实便宜了很多，还有各种奢侈品，我看到的有Hermes（爱马仕），Chanel(香奈儿)还有Dior（迪奥），，这些东西确实也就只能看看啊哈哈，由于我们回国还会经过迪拜停留，所以准备先四处逛逛，选好自己想要的回来再买。凌晨5点的迪拜（时差关系，国内应该9点左右了）依然熙熙攘攘，人来人往，有各式各样的人，黑种人，白种人，黄种人还有棕色人种。 免税店的销售人员也会各种语言，英语是必须会的。其中有不少中国人，语言不通时会给你分配跟你同一语言的销售人员，所以在这干销售是很赚钱的，折合人民币月薪能过万。在这的统一货币是阿联酋的迪拉姆，当然美元也通用，如果用人民币的话似乎汇率上不是很划算。在迪拜逛了几个小时，我们转机飞了两个多小时就到了德黑兰。 到了德黑兰，出机场前首先办落地签证，竟然每人100欧！，当初不知谁告诉我们是15刀的，这价格落差有点大，不过还好后来钱学校都给报销了。出了机场，那边派了两个小哥来接我们，也没举牌子，他们一眼就认出我们了，因为这边很少有中国人。问了我们一句RoboCup2D?确认之后跟我们每个人热情的拥抱握手，然后带我们换了当地货币和手机卡，100刀能换300多万当地货币里亚尔，花了30万买了张手机卡，感觉好土豪。。紧接着就带我们上车去酒店和比赛场地，，话说我们一行四个人，他们竟然叫了辆中巴来接我们，，太夸张了。。 在这里抬头就能看见雪山，主餐是吃的是一种叫Kebab的烤肉饭（如下图），在这里我们吃饭住宿都是免费的，当地居民真的是很热情，一天到晚都有志愿者跟着你，为你服务，带你吃饭，带你参观旅游，给你翻译，确实很贴心。在这第一天由于时差关系，显得一天特别长，特别累。登记完后，跟他们闲聊一会，晚饭都没吃直接睡了，因为第二天没比赛，准备养足精力再出去逛。 到了第二天，自然很早的就醒了，打电话联系了志愿者带我们出去玩，包了辆出租车，当地的出租车司机大都是年龄较大的老头，跟国内不同，他们收费不是按路程收费的，而是按时间收费，因为伊朗靠近波斯湾，石油资源丰富，油价特别便宜。我们加志愿者5个人超载了一个人也没关系，最后来回收了折合人民币100多块吧，算是很便宜了吧。然后我们逛了当地的古列斯坦皇宫还有当地的巴扎（集市的意思），一路上不停有人主动跟我们打招呼‘你好’，真是特别热情，似乎当地很多人都会说中国的‘你好’。 下图是皇宫此处应有自拍。。(^__^) 嘻嘻……下图为当地巴扎 接下来第三天到了比赛日，比赛一直都一如既往的顺利。保持不败战绩到了最后一轮，在赛场上，感觉自己简直就是明星，，走到哪都有人过来想要跟你搭讪，跟你合影。他们的热情和友好让我深深爱上了这里。还有不得不值得一提的是这里的妹纸都长的相当的漂亮，不仅是漂亮，可以用妖艳来形容吧，还有一些小孩子长得特别可爱，她们好像很小就学会化妆了，虽然由于当地风俗她们都必须戴黑色头巾，但是也无法遮住她们的美貌。 到了临走的前一天下午，一位似乎很喜欢中国文化的志愿者，再次带我们出去逛逛，买点当地特产啥的，这个志愿者是位大叔，很喜欢跟我们交流，了解中国文化，同时了解到他似乎是当地的公务员，还有些志愿者是当地的大学生什么的，虽然他们的母语是波斯语，但是他们的英语水平确实比我好太多，这位大叔可厉害了，不仅给我们做导游，还帮我们砍价，看到好多小朋友上来想跟我们交流，就把他们轰走，怕打扰我们。这次他带我们去了当地的一座雪山，名字忘了叫啥，还去了清真寺以及巴扎上买特产，这里的最著名的特产就是波斯地毯吧，，但是十分昂贵，带不回来。还有就是当地藏红花很有名，价格比淘宝上卖的便宜多了。 比赛最后一天，本以为我们拿冠军了，结果意外的在最后一场比赛以一分之差输了，变成了亚军。当时那个失落啊，现在想想感觉没啥了，亚军也已经很好了，当初的目标可是8强啊，已经超额完成目标了，回学校也能算是凯旋了。。 暑假培训的回忆 从伊朗回来之后，我也就基本告别了我大学近三年的RoboCup2D生涯，准备着去找工作，当时的我对市场行情并不了解，可能认为现在工作不好找，抱着能找着个工作就不错和求安稳的想法，签了讯飞的某子公司，协议规定要先去那免费培训几个月才能上班，我也感觉自己需要再充充电，完善一下自己。然后就去了，地点在芜湖。也就是在那让我认识了一群让我有着美好回忆但今后可能不会再见面的小伙伴。 先说说在那的室友，张翀，沉迷于Linux系统，整天跟我说Linux下的C，还有TCP/IP协议啥的，可以看出专业方面的书读的确实挺多。章文凯，简直就是我心中的黑客大神啊，擅长易语言，写各种外挂，大学四年通过这方面赚了20w，真心牛逼，把所学瞬间转化为经济效益。再就是李虎，让我印象最深的就是打游戏的时候脏话连篇啊，‘你个骚货，让你骚。。。’等等语句，有时听着觉得真搞笑。 除了在寝室的日子，最多的时间就是跟自己组的人在一起了，我们学习时六个人分为一组，然后我自荐为了组长，主要感觉自己懂得算挺多的，可以教教他们，，事后证明我的自荐是对的。再说说我们组的几个人。杜慧玲，明明是淑女非要喜欢把自己装成女汉子，让我带她去地里偷西瓜，讲义气，，挺赞的。。我也是在课上课下花了很多时间教她写代码，没事时坐旁边看着她敲。告诉她写代码思路，解决bug的方法，一步一步的调试，真是尽力用最简单的方式让她听懂，，慢慢的感觉她那千奇百怪的bug真的只有我能解了。。。后来听利鹏说她是他们班好多男生心中的女神，，搞得我之后都不太敢大中午跟她一起打伞去吃饭了，，毕竟合肥学院人多势重哈哈。但是后来发现不打伞实在太热了，从机房走到寝室全身湿透，还是甘愿冒着招惹仇恨的风险还是一起打伞吧哈哈，那个夏天谢谢你的伞更谢谢你。。李孟霞,在女生当中写代码的天赋确实算比较高的，让我教的次数相对少一些，并且一点就通。在我感觉是个学霸，对事情有自己的见解，让我最印象深刻的就是喜欢跟人抬扛哈哈，每次在去吃饭的路上见到她和杜慧玲抬杠，，莫名的想笑。。陈文涛，很认真的boy，由于坐我旁边，教他的次数也挺多的，对代码还是有点灵性的，但似乎缺少点debug技巧，不过学习的很认真，肯花时间，应该也弥补过来了。。曹博，很真实很坚持的boy，每天永远最后几个离开机房，然后还去锻炼，，但似乎不怎么喜欢问我，，所以交流不多。。叶玉宝，很开心的一个人，跟我们班人玩的最high了，人缘好，好像经常跟我们组人故意讲一些自己多受女孩子欢迎的话，然后遭到我们无情嘲讽。。至于我，虽说是培训，但感觉每天都是玩一样的感觉，很轻松，因为学的知识，之前在大学里都自学过了，所以有充足的时间去教别人。。但是，，毕竟不能一直这样下去，人生还很长，不能这么贪图安逸，奋斗的青春才更加精彩，以后老了回首往事才不会后悔，于是有一天晚上我就决定要离开这，根据自己的实力找一份更好的工作，但同时也就永远的离开了我在这认识一个多月的小伙伴，天下没有不散的筵席，只愿小伙伴们今后安好。 在写代码枯燥的日子里，最快乐的时莫过于每周四晚上班级在操场上集体做游戏了，感觉大学里最缺的就是这样的班级的集体活动了，大家一起度过在这可以说是野外的无聊的夜晚。 校招记忆 离开培训之后，刚开学9月份便开始准备校招，刚开始没有经验，投了好多社招的简历，结果收到的面试邀请屈指可数，而且好多培训的骗子机构，当时确实受到了一定的打击，后来在安大和合工大的同学的帮助下，加了他们那边的校招群，然后里面有大量安大，合工大的宣讲会，招聘会信息。于是，我频繁的往安大那边的校招投简历，参加宣讲会。效果出奇的好，收到了好多笔试面试邀请,最终也找到了自己较为满意的工作。所以我的经验告诉我应届生还是尽量走校招容易，机会确实多，工作也没有那么难找。校招的整个过程在之前写的一篇博客迟来的面试总结里写过，可以直接点击查看，这里不再赘述。 2016年已经过去，到了2017年，我的大学生涯也将结束，转而步入职场，，为自己的梦想坚持奋斗！","categories":[{"name":"生活感悟","slug":"生活感悟","permalink":"http://qiracle.github.io/categories/生活感悟/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://qiracle.github.io/tags/随笔/"}]},{"title":"ActionBar的使用","slug":"20161222","date":"2016-12-21T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2016/12/22/20161222/","link":"","permalink":"http://qiracle.github.io/2016/12/22/20161222/","excerpt":"ActionBar的引入 引用v7-appcompat Activity继承ActionBarActivity android:theme=”@style/Theme.AppCompat.Light” &gt;","text":"ActionBar的引入 引用v7-appcompat Activity继承ActionBarActivity android:theme=”@style/Theme.AppCompat.Light” &gt; 添加搜索按钮menu文件中添加yourapp:actionViewClass=”android.support.v7.widget.SearchView”重写onCreateOptionsMenu方法@Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.activity_main, menu); SearchView searchView = (SearchView) menu.findItem(R.id.action_search) .getActionView(); searchView.setOnQueryTextListener(this);// 搜索的监听 return true; } 实现onQueryTextSubmit和onQueryTextChange方法// 当搜索提交的时候 @Override public boolean onQueryTextSubmit(String query) { Toast.makeText(getApplicationContext(), query, 0).show(); return true; } // 当搜索的文本发生变化 @Override public boolean onQueryTextChange(String newText) { //Toast.makeText(getApplicationContext(), newText, 0).show(); return true; }","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiracle.github.io/tags/Android/"}]},{"title":"小记（二）","slug":"20161221","date":"2016-12-20T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2016/12/21/20161221/","link":"","permalink":"http://qiracle.github.io/2016/12/21/20161221/","excerpt":"何为成熟？与你在乎的人吵架的最高潮，能让他全盘崩溃的那句话就在你的舌尖上，你却忍住了没有说。对局面有掌控，对未来留余地，对他人有宽容，对自己有约束。","text":"何为成熟？与你在乎的人吵架的最高潮，能让他全盘崩溃的那句话就在你的舌尖上，你却忍住了没有说。对局面有掌控，对未来留余地，对他人有宽容，对自己有约束。","categories":[{"name":"生活感悟","slug":"生活感悟","permalink":"http://qiracle.github.io/categories/生活感悟/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://qiracle.github.io/tags/随笔/"}]},{"title":"设计模式六大原则","slug":"20161220","date":"2016-12-19T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2016/12/20/20161220/","link":"","permalink":"http://qiracle.github.io/2016/12/20/20161220/","excerpt":"1.单一职责原则:不要存在多于一个导致类变更的原因。通俗的说:即一个类只负责一项职责。 2.里氏替换原则:所有引用基类的地方必须能透明地使用其子类的对象。通俗的说:当使用继承时。类 B 继承类 A 时，除添加新的方法完成新增功能 外，尽量不要重写父类 A的方法， 也尽量不要重载父类 A 的方法。 如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。子类可以扩展父类的功能，但不能改变父类原有的功能。","text":"1.单一职责原则:不要存在多于一个导致类变更的原因。通俗的说:即一个类只负责一项职责。 2.里氏替换原则:所有引用基类的地方必须能透明地使用其子类的对象。通俗的说:当使用继承时。类 B 继承类 A 时，除添加新的方法完成新增功能 外，尽量不要重写父类 A的方法， 也尽量不要重载父类 A 的方法。 如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。子类可以扩展父类的功能，但不能改变父类原有的功能。 3.依赖倒置原则:高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。通俗的说:在 java 中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。依赖倒置原则的核心思想是面向接口编程. 4.接口隔离原则:客户端不应该依赖它不需要的接口； 一个类对另一个类的依赖应该建立在最小的接口上。通俗的说:建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。 5.迪米特法则:一个对象应该对其他对象保持最少的了解通俗的说:尽量降低类与类之间的耦合。 6.开闭原则:一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。通俗的说:用抽象构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://qiracle.github.io/tags/设计模式/"}]},{"title":"Android开发中，那些让你相见恨晚的方法、类或接口(转)","slug":"20161219","date":"2016-12-18T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2016/12/19/20161219/","link":"","permalink":"http://qiracle.github.io/2016/12/19/20161219/","excerpt":"getParent().requestDisallowInterceptTouchEvent(true);剥夺父view 对touch 事件的处理权，谁用谁知道。 ArgbEvaluator.evaluate(float fraction, Object startValue, Object endValue); 用于根据一个起始颜色值和一个结束颜色值以及一个偏移量生成一个新的颜色，分分钟实现类似于微信底部栏滑动颜色渐变。 Canvas中clipRect、clipPath和clipRegion 剪切区域的API。 Bitmap.extractAlpha ();返回一个新的Bitmap，capture原始图片的alpha 值。有的时候我们需要动态的修改一个元素的背景图片又不希望使用多张图片的时候，通过这个方法，","text":"getParent().requestDisallowInterceptTouchEvent(true);剥夺父view 对touch 事件的处理权，谁用谁知道。 ArgbEvaluator.evaluate(float fraction, Object startValue, Object endValue); 用于根据一个起始颜色值和一个结束颜色值以及一个偏移量生成一个新的颜色，分分钟实现类似于微信底部栏滑动颜色渐变。 Canvas中clipRect、clipPath和clipRegion 剪切区域的API。 Bitmap.extractAlpha ();返回一个新的Bitmap，capture原始图片的alpha 值。有的时候我们需要动态的修改一个元素的背景图片又不希望使用多张图片的时候，通过这个方法，结合Canvas 和Paint 可以动态的修改一个纯色Bitmap的颜色。 HandlerThread，代替不停new Thread 开子线程的重复体力写法。 IntentService,一个可以干完活后自己去死且不需要我们去管理子线程的Service。 Palette，5.0加入的可以提取一个Bitmap 中突出颜色的类，结合上面的Bitmap.extractAlpha，你懂的。 Executors. newSingleThreadExecutor();这个是java 的，之前不知道它，自己花很大功夫去研究了单线程顺序执行的任务队列。。 android:animateLayoutChanges=”true”，LinearLayout中添加View 的动画的办法，支持通过setLayoutTransition()自定义动画。 ViewDragHelper，自定义一个子View可拖拽的ViewGroup 时，处理各种事件很累吧，嗯? what the fuck!! GradientDrawable，之前接手公司的项目，发现有个阴影效果还不错，以为是切的图片，一看代码，什么鬼= =！-AsyncQueryHandler，如果做系统工具类的开发，比如联系人短信辅助工具等，肯定免不了和ContentProvider打交道，如果数据量不是很大的情况下，随便搞，如果数据量大的情况下，了解下这个类是很有必要的，需要注意的是，这玩意儿吃异常.. ViewFlipper，实现多个view的切换(循环)，可自定义动画效果，且可针对单个切换指定动画。 View.setLayerType(View.LAYER_TYPE_SOFTWARE, null);有朋友提到了在自定义View时有些方法在开启硬件加速的时候没有效果的问题，在API16之后确实有很多方法不支持硬件加速，通常我们关闭硬件加速都是在清单文件中通过，其实android也提供了针对特定View关闭硬件加速的方法,调用View.setLayerType(View.LAYER_TYPE_SOFTWARE, null)即可。 android util包中的Pair类，可以方便的用来存储一”组”数据。注意不是key value。 PointF，graphics包中的一个类，我们经常见到在处理Touch事件的时候分别定义一个downX，一个downY用来存储一个坐标，如果坐标少还好，如果要记录的坐标过多那代码就不好看了。用PointF(float x, float y);来描述一个坐标点会清楚很多。 StateListDrawable，定义Selector通常的办法都是xml文件，但是有的时候我们的图片资源可能是从服务器动态获取的，比如很多app所谓的皮肤，这种时候就只能通StateListDrawable来完成了，各种addState即可。 android:descendantFocusability，ListView的item中CheckBox等元素抢焦点导致item点击事件无法响应时，除了给对应的元素设置 focusable,更简单的是在item根布局加上android:descendantFocusability=”blocksDescendants” android:duplicateParentState=”true”，让子View跟随其Parent的状态，如pressed等。常见的使用场景是某些时候一个按钮很小，我们想要扩大其点击区域的时候通常会再给其包裹一层布局，将点击事件写到Parent上，这时候如果希望被包裹按钮的点击效果对应的Selector继续生效的话，这时候duplicateParentState就派上用场了。 includeFontPadding=”false”，TextView默认上下是有一定的padding的，有时候我们可能不需要上下这部分留白，加上它即可。 Messenger，面试的时候通常都会被问到进程间通信，一般情况下大家都是开始背书，AIDL巴拉巴拉。。有一天在鸿神的博客看到这个，嗯，如他所说，又可以装一下了。 TextView.setError();用于验证用户输入。 ViewConfiguration.getScaledTouchSlop();触发移动事件的最小距离，自定义View处理touch事件的时候，有的时候需要判断用户是否真的存在movie，系统提供了这样的方法。 ValueAnimator.reverse(); 顺畅的取消动画效果。 ViewStub，有的时候一块区域需要根据情况显示不同的布局，通常我们都会通过setVisibility的方法来显示和隐藏不同的布局，但是这样默认是全部加载的，用ViewStub可以更好的提升性能。 onTrimMemory，在Activity中重写此方法，会在内存紧张的时候回调（支持多个级别），便于我们主动的进行资源释放，避免OOM。 EditTxt.setImeOptions， 使用EditText弹出软键盘时，修改回车键的显示内容(一直很讨厌用回车键来交互，所以之前一直不知道这玩意儿) TextView.setCompoundDrawablePadding，代码设置TextView的drawable padding。 ImageSwitcher，可以用来做图片切换的一个类，类似于幻灯片。 WeakHashMap，直接使用HashMap有时候会带来内存溢出的风险，使用WaekHashMap实例化Map。当使用者不再有对象引用的时候，WeakHashMap将自动被移除对应Key值的对象 注：本文转自：http://liukun.engineer/2016/04/11/Android开发中，那些让你相见恨晚的方法、类或接口/","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"转载","slug":"转载","permalink":"http://qiracle.github.io/tags/转载/"}]},{"title":"Windows下MySQL 5.6 解压版配置与安装","slug":"20161218_mysql","date":"2016-12-17T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2016/12/18/20161218_mysql/","link":"","permalink":"http://qiracle.github.io/2016/12/18/20161218_mysql/","excerpt":"设置环境变量我的电脑-&gt;属性-&gt;高级-&gt;环境变量选择PATH,在其后面添加: 你的mysql bin文件夹的路径 (如:C:\\Program Files\\MySQL\\MySQL Server 5.6\\bin ) 配置default.ini文件mysql-5.6.1X默认的配置文件是在C:\\Program Files\\MySQL\\MySQL Server 5.6\\my-default.ini，或者自己建立一个my.ini文件，找到[mysqld] 位置，配置如下：","text":"设置环境变量我的电脑-&gt;属性-&gt;高级-&gt;环境变量选择PATH,在其后面添加: 你的mysql bin文件夹的路径 (如:C:\\Program Files\\MySQL\\MySQL Server 5.6\\bin ) 配置default.ini文件mysql-5.6.1X默认的配置文件是在C:\\Program Files\\MySQL\\MySQL Server 5.6\\my-default.ini，或者自己建立一个my.ini文件，找到[mysqld] 位置，配置如下：[mysqld]basedir=C:\\Program Files\\MySQL\\MySQL Server 5.6（mysql所在目录）datadir=C:\\Program Files\\MySQL\\MySQL Server 5.6\\data （mysql所在目录\\data） 安装环境变量设置完成后，打开终端输入mysqld -install。 登录输入mysql -u root -p（第一次登录没有密码，直接按回车过）,登录成功 修改密码在Windows命令行下修改mysql数据库密码步骤如下： 打开终端 输入“mysql -u root -p”，回车进入mysql命令状态； 如果root原来有密码，mysql将提示输入原密码，再进入mysql命令状态； 这里假设将root用户密码修改为mysql56，则在mysql命令状态下输入：update mysql.user set password=PASSWORD(‘mysql56’) where user=’root’;提示Query OK，说明已更新。 输入FLUSH PRIVILEGES;来保存修改内容，在mysql命令状态下输入：FLUSH PRIVILEGES;回车，至此，密码修改完成 附：mysql解压缩版下载地址：http://dev.mysql.com/downloads/mysql/5.6.html#downloads","categories":[{"name":"教程","slug":"教程","permalink":"http://qiracle.github.io/categories/教程/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://qiracle.github.io/tags/mysql/"}]},{"title":"差距是怎么产生的？","slug":"20161217","date":"2016-12-16T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2016/12/17/20161217/","link":"","permalink":"http://qiracle.github.io/2016/12/17/20161217/","excerpt":"当你在想玩什么，有人在想学什么——时间；当你在做计划，有人已出发——执行；当你为上次失败沮丧，有人已开始下次尝试——心态；当你想放弃，有人却坚信前进就有希望。所以，道理真的很简单，那些比你走得远的人，并不比你聪慧，只是每天多走了一点。","text":"当你在想玩什么，有人在想学什么——时间；当你在做计划，有人已出发——执行；当你为上次失败沮丧，有人已开始下次尝试——心态；当你想放弃，有人却坚信前进就有希望。所以，道理真的很简单，那些比你走得远的人，并不比你聪慧，只是每天多走了一点。","categories":[{"name":"生活感悟","slug":"生活感悟","permalink":"http://qiracle.github.io/categories/生活感悟/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://qiracle.github.io/tags/随笔/"}]},{"title":"Linux命令小结","slug":"linuxSum","date":"2016-12-15T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2016/12/16/linuxSum/","link":"","permalink":"http://qiracle.github.io/2016/12/16/linuxSum/","excerpt":"cdcd 进入某个目录 cd ~ 返回最初目录 cd - 返回上次目录 文件touch 1.txt 创建1.txt文件 cp 复制文件，格式：cp 源文件 目标文件","text":"cdcd 进入某个目录 cd ~ 返回最初目录 cd - 返回上次目录 文件touch 1.txt 创建1.txt文件 cp 复制文件，格式：cp 源文件 目标文件mv 移动文件 格式如上 rm 删除文件 （rm 文件夹 -r 递归删除文件夹内所有内容，并删除文件夹） 文件夹mkdir 创建文件夹 rmdir 删除文件夹 文件夹有内容时不可删 lsls -alh 显示当前目录下所有文件并显示文件大小 ls 1* 显示所有文件名以1开头的文件 ls 1? 显示文件名只有两个字母且第一个字符为1的文件 ls &gt;1.txt 重定向 将ls的内容显示在1.txt中 ls &gt;&gt;1.txt 将ls的内容追加在1.txt中 查看cat、morecat 1.txt 查看1.txt里的内容 more 1.txt 1.txt内容过多时，分页显示 查找grep、findgrep -n ‘123’ ./1.txt 显示当前目录下1.txt里含有字符123所在的行，并显示其行号 （可用正则表达式表示） find ./ -name ‘qq*’ 显示当前目录下文件名以qq的开头的文件 软、硬链接lnln 1.txt link1.txt 给1.txt建立一个硬链接link1.txt ln -s 1.txt link1.txt 给1.txt建立一个软链接link1.txt 系统集成ps、top、killps 显示当前进程信息 top 动态显示显示当前系统进程信息 kill 根据进程id杀死进程 kill -9 强制杀死某进程 解压打包tar -zxvf FileName.tar 解压 tar -zcvf FileName.tar DirName 打包并压缩 用户操作useradd 用户名 -m passwd ssh user@ip地址 su 用户名 切到其他用户 cat /etc/group groupmod tab*3 groupadd groupdelgroups 用户名 查看所在组 usermod -a -G 组名 用户名 修改用户所在组。。必须在adm和sudo组的用户才能拥有root权限 权限修改chmoda 所有的 u 当前用户 g 当前用户组 o 其他用户 r 读 w写 x执行 a+r 表示给所有用户增加读权限 a-r 表示给所有用户删除读权限 u+r 表示给当前用户增加读权限 u-r 表示给当前用户删除读权限 a=rw 给所有用户增加读写权限 其他以此类推 例子：chmod u+r,g+r,o+r 文件名 表示被所有用户增加读写可执行权限 与 chmod a+r 用户名 作用相同 权限表示： 1 执行 2 写 4 读 7=1+2+4表示可读可写可执行，类似的6=4+2可读可写，，以此类推 chmod 776 文件名 则表示当前用户和当前用户组拥有可读可写可执行权限，其他用户拥有可读可写权限 chown 用户 文件名 表示修改文件所有者 chgrp 用户组 文件名 表示修改用户所在用户组 vimvim i 命令模式进入编辑模式 shift+；进入末行模式 esc 返回上个模式 wq等价于x 保存并退出","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://qiracle.github.io/tags/Linux/"}]},{"title":"面试注意事项（转）","slug":"stornzhangTalk","date":"2016-12-14T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2016/12/15/stornzhangTalk/","link":"","permalink":"http://qiracle.github.io/2016/12/15/stornzhangTalk/","excerpt":"基本 简历不要太花哨, 你是应聘的技术, 不是设计师 简历把一些基本信息要说清楚（无关的不要写, 比如头像之类的） 有个人博客, 跟GitHub的写上, 若没有内容那就算了 应届毕业生需写上相关证书之类, 有经验的可不写 简历控制在两页 A4 纸","text":"基本 简历不要太花哨, 你是应聘的技术, 不是设计师 简历把一些基本信息要说清楚（无关的不要写, 比如头像之类的） 有个人博客, 跟GitHub的写上, 若没有内容那就算了 应届毕业生需写上相关证书之类, 有经验的可不写 简历控制在两页 A4 纸 项目经验 一般写 2, 3个代表性的项目就好, 优先写本职工作相关的 时间为倒序 说明你在项目当中的职责作用 项目模块需要了解大概逻辑与思路, 以及一些关键的技术点, 以防面试官问到 没有项目经验的也要模仿一两个小 Demo 闲聊 自己亲自做的东西一定要明白, 如果不是自己亲自做的, 请慎重骗面试官 问的时候会问一些知识点相关的话题, 比如你的数据是需要api交互的, 那可能会问http相关, json数据解析相关, 缓存相关, 图片加载相关等 对用到的知识点虽用不着一定要看源码的地步, 但是最好要懂原理, 比如图片加载一定要知道二级缓存, 一些常见的缓存算法 注意事项 去面试前一定要花点时间了解下你面试的这家公司(本身有自己产品的下载体验一下, 以防面试过程中问到, 或者可以给产品提点意见) 面试的时候态度要谦虚点 学习能力很重要(一定要让面试官感受到你是一个好学的人) 个人兴趣(不要提什么打游戏, 唱歌之类的, 可以说一下业余时间提下自己经常上一些技术社区,看一些技术博客之类的) 除了基本的知识点, 面试官通常都会问一些比较深的领域(可能你没有接触过,但不要气馁, 面试官在考察下你的技术的深度, 这些领域一般包括设计模式, 虚拟机, 插件化, React Native之类的) 常问的知识点 初级 那基本的 Activity/Fragment的生命周期 四大组件的具体作用以及用法 Activity四种启动模式的区别 ListView的优化 一些动画的使用 Java一些基础知识(如最基本的 String, StringBuilder, StringBuffer的区别; 如ArrayList, LinkedList的区别; Java线程的几种用法) 中级 屏幕适配经验，性能优化的经验 中级的还有Java线程几种用法等 高级 如插件化, 如网络的优化, 如缓存的处理, 如插件化, 如Service保活 对产品的一些看法, 对代码质量的要求, 对团队合作的理解等 工资(一线城市, 不同的公司水平也有高低, 只能是大概) 一年以下一般8k以下吧(能力优秀的可以达到1w左右) 中级的大概在10k—15k左右 高级的在15-25k范围 注:本文转自stormZhang，微信公众号：AndroidDeveloper","categories":[{"name":"生活感悟","slug":"生活感悟","permalink":"http://qiracle.github.io/categories/生活感悟/"}],"tags":[{"name":"转载","slug":"转载","permalink":"http://qiracle.github.io/tags/转载/"}]},{"title":"CSS中清除浮动的方法","slug":"float_clear","date":"2016-12-13T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2016/12/14/float_clear/","link":"","permalink":"http://qiracle.github.io/2016/12/14/float_clear/","excerpt":"1.加高法浮动的元素，只能被有高度的盒子关住。 也就是说，如果盒子内部有浮动，这个盒子有高，那么妥妥的，浮动不会互相影响。但是，工作上，我们绝对不会给所有的盒子加高度，这是因为麻烦，并且不能适应页面的快速变化。 &lt;div&gt; → 设置height &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt;","text":"1.加高法浮动的元素，只能被有高度的盒子关住。 也就是说，如果盒子内部有浮动，这个盒子有高，那么妥妥的，浮动不会互相影响。但是，工作上，我们绝对不会给所有的盒子加高度，这是因为麻烦，并且不能适应页面的快速变化。 &lt;div&gt; → 设置height &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; → 设置height &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; 2.clear:both法最简单的清除浮动的方法，就是给盒子增加clear:both；表示自己的内部元素，不受其他盒子的影响。 &lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; → clear:both; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; 浮动确实被清除了，不会互相影响了。但是有一个问题，就是margin失效。两个div之间，没有任何的间隙了。 3.隔墙法在两部分浮动元素中间，建一个墙。隔开两部分浮动，让后面的浮动元素，不去追前面的浮动元素。墙用自己的身体当做了间隙。 &lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;cl h10&quot;&gt;&lt;/div&gt; &lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; 我们发现，隔墙法好用，但是第一个div，还是没有高度。如果我们现在想让第一个div，自动的根据自己的儿子，撑出高度，我们就要想一些“小伎俩”，“奇淫技巧”。 4.内墙法&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;div class=&quot;cl h10&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; 内墙法的优点就是，不仅仅能够让后部分的p不去追前部分的p了，并且能把第一个div撑出高度。这样，这个div的背景、边框就能够根据p的高度来撑开了。 5.overflow:hidden这个属性的本意，就是将所有溢出盒子的内容，隐藏掉。但是，我们发现这个东西能够用于浮动的清除。我们知道，一个父亲，不能被自己浮动的儿子撑出高度，但是，如果这个父亲加上了overflow:hidden；那么这个父亲就能够被浮动的儿子撑出高度了。这个现象，不能解释，就是浏览器的小偏方。并且,overflow:hidden;能够让margin生效。 &lt;div&gt; ----&gt;设置overflow:hidden属性 &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt;","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://qiracle.github.io/tags/CSS/"}]},{"title":"小记(一)","slug":"life_code","date":"2016-12-12T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2016/12/13/life_code/","link":"","permalink":"http://qiracle.github.io/2016/12/13/life_code/","excerpt":"做自己必须的要做事还是做自己喜欢的事，鱼和熊掌不可兼得 for（day=start；；day++）｛ doMymustTodoThings（）； knowledge++； experience++; happy–; if(i want）{","text":"做自己必须的要做事还是做自己喜欢的事，鱼和熊掌不可兼得 for（day=start；；day++）｛ doMymustTodoThings（）； knowledge++； experience++; happy–; if(i want）{ continue; } else{ break; } } doMyLoveThings(); happy++;","categories":[{"name":"生活感悟","slug":"生活感悟","permalink":"http://qiracle.github.io/categories/生活感悟/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://qiracle.github.io/tags/随笔/"}]},{"title":"markdown语法小结","slug":"markdown","date":"2016-12-11T16:00:00.000Z","updated":"2019-10-26T07:12:38.875Z","comments":true,"path":"2016/12/12/markdown/","link":"","permalink":"http://qiracle.github.io/2016/12/12/markdown/","excerpt":"1.标题","text":"1.标题 2.列表 3.引用 4.代码块 5.粗体和斜体 6.超链接 7.分割线 8.表格 9.工具栏 10.总结","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://qiracle.github.io/tags/markdown/"}]},{"title":"javaSE基础-集合","slug":"java.set","date":"2016-12-10T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2016/12/11/java.set/","link":"","permalink":"http://qiracle.github.io/2016/12/11/java.set/","excerpt":"当初学java基础的时候感觉集合这块挺复杂的，但是在之后的java，Android项目中运用的特别多，所以感觉比较重要，今天翻电脑偶然翻到之前的笔记，分享一下","text":"当初学java基础的时候感觉集合这块挺复杂的，但是在之后的java，Android项目中运用的特别多，所以感觉比较重要，今天翻电脑偶然翻到之前的笔记，分享一下 Collection(单列集合):List(有序,可重复):ArrayList底层数据结构是数组,查询快,增删慢 线程不安全,效率高 Vector底层数据结构是数组,查询快,增删慢 线程安全,效率低 LinkedList底层数据结构是链表,查询慢,增删快 线程不安全,效率高 Set(无序,唯一): HashSet底层数据结构是哈希表。 哈希表依赖两个方法：hashCode()和equals() 执行顺序： 首先判断hashCode()值是否相同 是：继续执行equals(),看其返回值 是true:说明元素重复，不添加 是false:就直接添加到集合 否：就直接添加到集合 最终： 自动生成hashCode()和equals()即可 LinkedHashSet底层数据结构由链表和哈希表组成。 由链表保证元素有序。 由哈希表保证元素唯一。 TreeSet底层数据结构是红黑树。(是一种自平衡的二叉树) 如何保证元素唯一性呢? 根据比较的返回值是否是0来决定 如何保证元素的排序呢? 两种方式 自然排序(元素具备比较性) 让元素所属的类实现Comparable接口 比较器排序(集合具备比较性) 让集合接收一个Comparator的实现类对象 Map(双列集合):A:Map集合的数据结构仅仅针对键有效，与值无关。 B:存储的是键值对形式的元素，键唯一，值可重复。 HashMap底层数据结构是哈希表。线程不安全，效率高 哈希表依赖两个方法：hashCode()和equals() 执行顺序： 首先判断hashCode()值是否相同 是：继续执行equals(),看其返回值 是true:说明元素重复，不添加 是false:就直接添加到集合 否：就直接添加到集合 最终： 自动生成hashCode()和equals()即可 LinkedHashMap底层数据结构由链表和哈希表组成。 由链表保证元素有序。 由哈希表保证元素唯一。 Hashtable底层数据结构是哈希表。线程安全，效率低 哈希表依赖两个方法：hashCode()和equals() 执行顺序： 首先判断hashCode()值是否相同 是：继续执行equals(),看其返回值 是true:说明元素重复，不添加 是false:就直接添加到集合 否：就直接添加到集合 最终： 自动生成hashCode()和equals()即可 TreeMap底层数据结构是红黑树。(是一种自平衡的二叉树) 如何保证元素唯一性呢? 根据比较的返回值是否是0来决定 如何保证元素的排序呢? 两种方式 自然排序(元素具备比较性) 让元素所属的类实现Comparable接口 比较器排序(集合具备比较性) 让集合接收一个Comparator的实现类对象 2:到底使用那种集合 看需求。 是否是键值对象形式: 是：Map 键是否需要排序: 是：TreeMap 否：HashMap 不知道，就使用HashMap。 否：Collection 元素是否唯一: 是：Set 元素是否需要排序: 是：TreeSet 否：HashSet 不知道，就使用HashSet 否：List 要安全吗: 是：Vector(其实我们也不用它，有其他方法可以替代) 否：ArrayList或者LinkedList 增删多：LinkedList 查询多：ArrayList 不知道，就使用ArrayList 不知道，就使用ArrayList 3:集合的常见方法及遍历方式 Collection:常见方法： add() remove() contains() iterator() size() 遍历： 增强for 迭代器 |--List get() 遍历： 普通for |--Set Map:put() remove() containskey(),containsValue() keySet() get() value() entrySet() size() 遍历： 根据键找值 根据键值对对象分别找键和值 4:ArrayList,LinkedList,HashSet,HashMap(掌握) 存储字符串和自定义对象数据并遍历 5:集合的嵌套遍历(理解)","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://qiracle.github.io/categories/知识总结/"}],"tags":[{"name":"java","slug":"java","permalink":"http://qiracle.github.io/tags/java/"}]},{"title":"迟来的面试总结","slug":"mianshi","date":"2016-12-09T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2016/12/10/mianshi/","link":"","permalink":"http://qiracle.github.io/2016/12/10/mianshi/","excerpt":"从今年九月底开始，一直到十月底，前前后后总共大概面试了十来家公司，其中有少于二十人的创业公司，也有像美团那样的大公司，也算是面试经历丰富了。因为是校招，所谓金九银十，但当时自己并不知情，所以错过了好多大公司在九月份的校招，实在是挺可惜的。 简历筛选 先从简历投递开始说起，我想说毕业院校真的很重要，笔者是一所普通二本院校，虽然面试的是技术岗位，但是那些985,211毕业的学生确实还是具有很大优势","text":"从今年九月底开始，一直到十月底，前前后后总共大概面试了十来家公司，其中有少于二十人的创业公司，也有像美团那样的大公司，也算是面试经历丰富了。因为是校招，所谓金九银十，但当时自己并不知情，所以错过了好多大公司在九月份的校招，实在是挺可惜的。 简历筛选 先从简历投递开始说起，我想说毕业院校真的很重要，笔者是一所普通二本院校，虽然面试的是技术岗位，但是那些985,211毕业的学生确实还是具有很大优势，最明显的就是在简历筛选环节，其实大多数hr看你简历上一个毕业院校就决定你是否被pass了，其实 也不必抱怨不公平，hr从985,211里挑出优秀学生的概率确实是要比在普通学校挑出优秀学生的概率大的多，hr每天面对上百份简历，没那么多时间慢慢看，大多数简历一扫而过，毕业院校当然是观察的重点了。几年前的那场高考就决定了你是否输在了起跑线。普通的学生除非你曾获得过好多荣誉，才能让hr多看一眼你的简历。不过还好笔者大学并没有荒废，拿过一些小奖，做个一些小项目，写在简历上确实很加分。所以简历通过率还是很高的。 笔试 简历筛选完后，技术岗一般都会有笔试，笔者应聘的是Android开发工程师，java语言运用比较熟练，但在笔试阶段，好多公司对于不同技术岗位都是同一套试卷，好多都是用C/C++答题，说来羞愧，虽然笔者在大一大二花过时间学习过C/C++，但是大三一年基本在学java，所以C方面的知识好多都忘了，尤其指针方面的，导致有些公司笔试时被刷了。也有一些比较良心的公司会针对不同职位安排不同的试卷，这样的笔试我一般做起来比较顺手，基本都通过了。之后拿到几个offer的公司当中也都是这样分开出题的。不过还是建议大家有时间多看看C/C++，因为我们只能去适应市场，不可能让市场来适应你。然后C/C++也是学校规定的课程，企业有这样的要求也没有错。 然后说一下我遇到的校招笔试的大体内容，常见排序算法至少能手写出两个吧，他们的时间复杂度都必须记得，二分查找也要会写，面向对象的特点，，hashcode和equals方法，，Sting类的常用方法，java集合类的特点和用法（必须搞清楚），多线程（笔试比较常考，面试必问的），数据库多表查询（这是笔者最薄弱的部分），反射，，设计模式（单例模式必须懂），IO流和网络编程（这两个笔试较少）然后就是一些编程题（以对字符串的操作居多，还有数据结构算法题）。。一般一些大公司必考数据结构与算法，像栈，，队列，二叉树，，红黑树，图啊等等他们的一些特性，，最好能手写代码（笔者目前还做不到）。另外还有还会考一些CS的基本素养了，比如计算机网络（TCP/IP协议，HTTP等协议），，操作系统（FIFO，LRU等分页算法）啥的。还有就是智力题也占一部分，常见的就是找规律填数字，求概率等等。。笔者所做的Android部分常考的有：Acticity生命周期，Fragment生命周期，广播注册的两种方式，andorid的数据存储方式，四大组件的基本使用，，五大布局的各自特点，handler消息机制，listview的优化，防止内存泄露的方法，intent意图，Android动画等等。 面试 最后说说面试，面试时笔者感觉一直都是很不错的，问的问题基本都能答上来，越面越自信，也是重在基础。下面就以科大讯飞和美团作为例子吧，虽然这两家公司都没通过，但笔者认为很有借鉴意义，可以从失败中吸取教训，这两家公司问的问题几乎涵盖了我面试的其他家公司问的问题，所以十几次面试我就准备了一次，有时上午面完下午面，一面完了二面，晚上又去参加宣讲会笔试，总之是没那么多时间准备的，其实也不需要要多次准备，充足准备好一次就行了。回到正题，先说说科大讯飞，介绍完后，两面试官，上来就问我如何实现线程同步，这其实是很老的问题了，百度上都有，五种方法吧，我当时只答了个synchronized ，就这个问题没答好，确实没准备。后来又问我面向对象特点，java集合，接口与抽象类的区别，json解析，设计模式，盒子模型（css里的），还有好多问题忘了。反正后面的答的都很好，然后就是闲聊，重在突出自己知识面广，学习能力强，对cs抱有很大热情。最好面试官问我考不考研，，我说不考，然后面试官说，像你这样的是不用考研了，你比很多研究生水平都要好了。当时心里很开心。过了两天。没出意外，告诉我面试过了，准备二面。到了二面，是一个面试官，没想到它不安常理出牌。我以为他会问java，，Android方面的，没想到他一直问网络通信方面的知识，比如tcp与udp的区别，get与post请求的区别，tcp在网络哪一层，还有对http协议的了解等等，我完全蒙蔽了带猜带蒙的回答了一点。。结果，，然后就没有结果了。从这次失败的面试中我也真的是收获不少，恶补了线程同步以及网络方面的知识，，在之后的面试（如美团）中，果然有再次被问到，然后我回答的都很不错。。恩，聪明的人总会从失败中吸取经验。 再说说美团面试，在一家逼格挺高的酒店进行的，我对自己简历筛选和笔试通过已经很惊讶了，然后当时已经有了别的公司的offer，所以全当体验一把。因为我知道这类大公司最喜欢问数据结构与算法，现场手写代码，而这正是我最薄弱的，因为之前并没有特意的去刷数据结果与算法题，当时去现场看到很多人拿着本剑指offer在那刷题，没有意外最后我也就死在了算法题上。。。面试我的只有一个面试官，先是针对我简历上的项目问的特别细致，花了将近一半的时间，然后跟他说了Android的事件传递机制，handler消息机制，图片的三级缓存，内存泄露，listview的下拉刷新和上拉加载更多以及常用的Android网络请求开源框架（Okhttp，Volley，Retrofit）以及自己经常使用的一些开源项目（Slidingmenu，XUtils，Gson）等问题，接着就是大量的多线程方面的问题，如sleep与wait方法的区别，多线程启动方法，线程同步问题（这个之前在科大讯飞就被问到，这次答的就很顺利），这些我答的都很轻松。然后给我假设Android里的一些特殊情景，怎样用多线程实现，具体啥问题记不得了。然后问我java反射的一些问题，感觉答得也还行，然后又问了好多网络方面的问题，tcp与udp的区别，get与post请求的区别，http请求除了get，post还有哪些，tcp协议几次握手几次挥手等等，这些问题我之前面试都被问过，所以回答的很完整。。到最好，果然还是出了两道算法题，一道是二叉树左右子树互换，我直接放弃了，因为我根本没去复习数据结构这块，还有一道是链表的逆序，这题我写出来了，他说时间复杂度太高。面试总体感觉百分之七八十的问题都答出来了。。最后出来，，hr说没过，好吧，，我估计就死在算法题上了，也没有遗憾，这方面确实不足啊。 总结 现在挺怀念面试那个时候的，很享受面试的过程，每天过得很充实，，有目标，特别是最后收到offer的时候，这是别人对你的认可，毕竟从简历筛选到笔试再到面试一面二面，感觉自己的辛苦有了回报。最后一共收到三个offer，选择了一家上海的公司，对于我们这类二本院校的学生来说也还行吧，找好落脚点，重在以后发展，加油吧骚年！","categories":[{"name":"生活感悟","slug":"生活感悟","permalink":"http://qiracle.github.io/categories/生活感悟/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://qiracle.github.io/tags/Android/"},{"name":"java","slug":"java","permalink":"http://qiracle.github.io/tags/java/"},{"name":"面试","slug":"面试","permalink":"http://qiracle.github.io/tags/面试/"}]},{"title":"初识github.io","slug":"github.io","date":"2016-12-08T16:00:00.000Z","updated":"2018-11-25T08:40:22.000Z","comments":true,"path":"2016/12/09/github.io/","link":"","permalink":"http://qiracle.github.io/2016/12/09/github.io/","excerpt":"很早之前就想用github搭建自己的blog，但之前由于比赛和找工作的事情一直没时间，其实是自己嫌麻烦吧。。第一次听说用github.io做个人博客时还是在半年之前在实验室看学弟在弄，当时心里还有点嘲笑他的，因为这个给我的印象就是在套网页模板，没啥技术含量，而不是我想的自己纯用手写代码做出的网站那样有逼格。直到后来看到越来越多的人都在用github.io搭个人博客，然后","text":"很早之前就想用github搭建自己的blog，但之前由于比赛和找工作的事情一直没时间，其实是自己嫌麻烦吧。。第一次听说用github.io做个人博客时还是在半年之前在实验室看学弟在弄，当时心里还有点嘲笑他的，因为这个给我的印象就是在套网页模板，没啥技术含量，而不是我想的自己纯用手写代码做出的网站那样有逼格。直到后来看到越来越多的人都在用github.io搭个人博客，然后自己在google搜了一下，发现这个确实蛮有意思的。趁这段时间没啥事就自己搭个博客玩玩。 具体流程也网上有很多，大概就是先注册个github账号，然后安装hexo和node.js，然后github上建一个仓库名字必须是 你的用户名.github.io(如qiracle.github.io)。我的是在Linux下搭建的。hexo主要有三个命令需要记住： hexo g ：这个命令是在public里生成网页文件 hexo d :将博客部署到网站上，也就是将网页推送到了github上 hexo s ：启动本地服务器，这样就可以在浏览器中输入localhost:4000来访问。 另外，我们可以下载各类主题放在theme文件夹下，然后修改config.yml,将里面的theme替换成你下载的主题主题名字就可以了。预览效果需要输入hexo g 和hexo d。然后浏览器中输入网址username.github.io就可以看到效果了，记得每次修改文件都需要在终端输入hexo g和hexo d。","categories":[{"name":"教程","slug":"教程","permalink":"http://qiracle.github.io/categories/教程/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://qiracle.github.io/tags/Hexo/"}]}]}